{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1}],"Cache":[{"_id":"source/_drafts/JavaScript 学习记录.md","hash":"c8a48bb44beed14877369a7f9725d7d8e6ff9b61","modified":1622794087237},{"_id":"source/CNAME","hash":"a9751b5c4fdd4167aafcdd5b1fccc7024e5db9eb","modified":1622794087237},{"_id":"source/_drafts/React Native 学习记录.md","hash":"b1b12c5deabc1298265eca591fec69b27dc1cde4","modified":1622794087238},{"_id":"source/_drafts/数据结构学习记录.md","hash":"a04e3124a4e40bf94514ff2bcfc60bc425f9887f","modified":1622794087238},{"_id":"source/_posts/Adyen SDK 接入（一）账号注册 & 准备工作.md","hash":"f6bf2343b388d18ddd74b1a5c0b1fa27a15f963c","modified":1622794087238},{"_id":"source/_drafts/杭州看房记录.md","hash":"50d3ae3536a50a6588780e44a6b9d4f8c82b1edc","modified":1622794087238},{"_id":"source/_posts/Adyen SDK 接入（二）.md","hash":"38e868309c23e0566a5c7e87d77d0885bbf562a4","modified":1622794087239},{"_id":"source/_posts/Bazel 问题.md","hash":"c69299492297a0d29cf78ae87a4d70256cb2018d","modified":1625628150496},{"_id":"source/_posts/Bazel 构建步骤.md","hash":"0e2d9dd21172e55fc7afbe53ba98de7b0a3a7f17","modified":1625628075542},{"_id":"source/_posts/JavaScript 语法.md","hash":"fe2cf95bfcf4eadb5446c2740fbfe5ac97650f1a","modified":1622794087242},{"_id":"source/_posts/JavaScript 学习资料.md","hash":"0fe6a5099a36c4357adb3d4a4b565e73df6df82d","modified":1622794087242},{"_id":"source/_posts/LeetCode 资料.md","hash":"c9dc5bd84f341fb8e74d26366ef1723fd40b5806","modified":1656656551273},{"_id":"source/categories/index.md","hash":"745d4c61d49bafa076597cc5ee10a4b8335701f7","modified":1622794087245},{"_id":"source/_posts/Block 写法备忘.md","hash":"acdad64e054535d780af5f3140f6a3edfc859377","modified":1628835790771},{"_id":"source/_posts/OC Swift 混编问题.md","hash":"c932336688c5722a85d4a146c454f8689bf130fb","modified":1622794087243},{"_id":"source/_posts/React Native Flexbox 布局.md","hash":"229e12464e5229dee8c3a3c783bf8bb982280905","modified":1622794087243},{"_id":"source/_posts/React Native 学习资料.md","hash":"515bab87ee03beea8499c73f35dea043ead062b8","modified":1622794087243},{"_id":"source/_posts/React 语法.md","hash":"126b7fb551bf1b581dad3fc7f20ac4c41bab235c","modified":1622794087243},{"_id":"source/_posts/Swift 语法.md","hash":"366fff77f517ed06c8b9a995d9ec3eaadf7af9c0","modified":1622794087243},{"_id":"source/_posts/iOS 启动时间优化.md","hash":"8861b23359426d205ad54c3628447ba5ee6dca6a","modified":1622794087244},{"_id":"source/_posts/TypeScript.md","hash":"d62886219f9463715b16720bc4bf0cbc2fbcbfbb","modified":1622794087244},{"_id":"source/_posts/常用工具 & 网站 & 命令.md","hash":"e3ae34b9d9e0118caed663592a8b8ca752553f6d","modified":1622794087244},{"_id":"source/_posts/iPhone 屏幕尺寸.md","hash":"baba738651999570c51690fa4bd41c4d2db046e9","modified":1656656551290},{"_id":"source/_posts/热修复.md","hash":"bcf572b573a9faf69d01c11d3aedcc9c3012b5b8","modified":1622794087245},{"_id":"source/tags/index.md","hash":"5fbb313cac3cc1782aeddcb6f8d758beeeada73b","modified":1622794087245},{"_id":"themes/next/.gitignore","hash":"56f3470755c20311ddd30d421b377697a6e5e68b","modified":1622794087249},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1622794087245},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1622794087245},{"_id":"themes/next/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1622794087246},{"_id":"themes/next/.travis.yml","hash":"ecca3b919a5b15886e3eca58aa84aafc395590da","modified":1622794087249},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1622794087249},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1622794087249},{"_id":"themes/next/package.json","hash":"62fad6de02adbbba9fb096cbe2dcc15fe25f2435","modified":1622794087289},{"_id":"themes/next/README.md","hash":"9b4b7d66aca47f9c65d6321b14eef48d95c4dff1","modified":1622794087249},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1622794087250},{"_id":"themes/next/_config.yml","hash":"0610a8525f12c3cebe9df99b58b4f3a29db0fff2","modified":1622794087249},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"e554931b98f251fd49ff1d2443006d9ea2c20461","modified":1622794087246},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1a435c20ae8fa183d49bbf96ac956f7c6c25c8af","modified":1622794087247},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"aa4cb7aff595ca628cb58160ee1eee117989ec4e","modified":1622794087246},{"_id":"themes/next/.github/config.yml","hash":"1d3f4e8794986817c0fead095c74f756d45f91ed","modified":1622794087247},{"_id":"themes/next/.github/issue-close-app.yml","hash":"7cba457eec47dbfcfd4086acd1c69eaafca2f0cd","modified":1622794087247},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1622794087248},{"_id":"themes/next/.github/mergeable.yml","hash":"0ee56e23bbc71e1e76427d2bd255a9879bd36e22","modified":1622794087248},{"_id":"themes/next/.github/lock.yml","hash":"61173b9522ebac13db2c544e138808295624f7fd","modified":1622794087248},{"_id":"themes/next/.github/stale.yml","hash":"fdf82de9284f8bc8e0b0712b4cc1cb081a94de59","modified":1622794087248},{"_id":"themes/next/.github/release-drafter.yml","hash":"3cc10ce75ecc03a5ce86b00363e2a17eb65d15ea","modified":1622794087248},{"_id":"themes/next/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1622794087248},{"_id":"themes/next/gulpfile.js","hash":"1b4fc262b89948937b9e3794de812a7c1f2f3592","modified":1622794087257},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"c7a994b9542040317d8f99affa1405c143a94a38","modified":1622794087250},{"_id":"themes/next/docs/AUTHORS.md","hash":"10135a2f78ac40e9f46b3add3e360c025400752f","modified":1622794087250},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1622794087250},{"_id":"themes/next/docs/DATA-FILES.md","hash":"cddbdc91ee9e65c37a50bec12194f93d36161616","modified":1622794087250},{"_id":"themes/next/docs/INSTALLATION.md","hash":"af88bcce035780aaa061261ed9d0d6c697678618","modified":1622794087251},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"94dc3404ccb0e5f663af2aa883c1af1d6eae553d","modified":1622794087251},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1622794087251},{"_id":"themes/next/languages/ar.yml","hash":"9815e84e53d750c8bcbd9193c2d44d8d910e3444","modified":1622794087257},{"_id":"themes/next/docs/MATH.md","hash":"d645b025ec7fb9fbf799b9bb76af33b9f5b9ed93","modified":1622794087251},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"8b6e4b2c9cfcb969833092bdeaed78534082e3e6","modified":1622794087251},{"_id":"themes/next/languages/en.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1622794087258},{"_id":"themes/next/languages/default.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1622794087258},{"_id":"themes/next/languages/de.yml","hash":"74c59f2744217003b717b59d96e275b54635abf5","modified":1622794087258},{"_id":"themes/next/languages/es.yml","hash":"c64cf05f356096f1464b4b1439da3c6c9b941062","modified":1622794087259},{"_id":"themes/next/languages/fa.yml","hash":"3676b32fda37e122f3c1a655085a1868fb6ad66b","modified":1622794087259},{"_id":"themes/next/languages/fr.yml","hash":"752bf309f46a2cd43890b82300b342d7218d625f","modified":1622794087259},{"_id":"themes/next/languages/hu.yml","hash":"b1ebb77a5fd101195b79f94de293bcf9001d996f","modified":1622794087260},{"_id":"themes/next/languages/it.yml","hash":"44759f779ce9c260b895532de1d209ad4bd144bf","modified":1622794087261},{"_id":"themes/next/languages/ja.yml","hash":"0cf0baa663d530f22ff380a051881216d6adcdd8","modified":1622794087261},{"_id":"themes/next/languages/id.yml","hash":"572ed855d47aafe26f58c73b1394530754881ec2","modified":1622794087261},{"_id":"themes/next/languages/ko.yml","hash":"0feea9e43cd399f3610b94d755a39fff1d371e97","modified":1622794087262},{"_id":"themes/next/languages/nl.yml","hash":"5af3473d9f22897204afabc08bb984b247493330","modified":1622794087262},{"_id":"themes/next/languages/pt-BR.yml","hash":"67555b1ba31a0242b12fc6ce3add28531160e35b","modified":1622794087262},{"_id":"themes/next/languages/pt.yml","hash":"718d131f42f214842337776e1eaddd1e9a584054","modified":1622794087263},{"_id":"themes/next/languages/ru.yml","hash":"e993d5ca072f7f6887e30fc0c19b4da791ca7a88","modified":1622794087263},{"_id":"themes/next/languages/vi.yml","hash":"93393b01df148dcbf0863f6eee8e404e2d94ef9e","modified":1622794087264},{"_id":"themes/next/languages/tr.yml","hash":"fe793f4c2608e3f85f0b872fd0ac1fb93e6155e2","modified":1622794087263},{"_id":"themes/next/languages/uk.yml","hash":"3a6d635b1035423b22fc86d9455dba9003724de9","modified":1622794087264},{"_id":"themes/next/languages/zh-CN.yml","hash":"a1f15571ee7e1e84e3cc0985c3ec4ba1a113f6f8","modified":1622794087264},{"_id":"themes/next/languages/zh-HK.yml","hash":"3789f94010f948e9f23e21235ef422a191753c65","modified":1622794087265},{"_id":"themes/next/layout/_layout.swig","hash":"6a6e92a4664cdb981890a27ac11fd057f44de1d5","modified":1622794087265},{"_id":"themes/next/languages/zh-TW.yml","hash":"8c09da7c4ec3fca2c6ee897b2eea260596a2baa1","modified":1622794087265},{"_id":"themes/next/layout/category.swig","hash":"1bde61cf4d2d171647311a0ac2c5c7933f6a53b0","modified":1622794087287},{"_id":"themes/next/layout/index.swig","hash":"7f403a18a68e6d662ae3e154b2c1d3bbe0801a23","modified":1622794087288},{"_id":"themes/next/layout/post.swig","hash":"2f6d992ced7e067521fdce05ffe4fd75481f41c5","modified":1622794087288},{"_id":"themes/next/scripts/renderer.js","hash":"49a65df2028a1bc24814dc72fa50d52231ca4f05","modified":1622794087296},{"_id":"themes/next/layout/page.swig","hash":"db581bdeac5c75fabb0f17d7c5e746e47f2a9168","modified":1622794087288},{"_id":"themes/next/layout/tag.swig","hash":"0dfb653bd5de980426d55a0606d1ab122bd8c017","modified":1622794087289},{"_id":"themes/next/layout/archive.swig","hash":"e4e31317a8df68f23156cfc49e9b1aa9a12ad2ed","modified":1622794087287},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"c3e6b8196c983c40fd140bdeca012d03e6e86967","modified":1622794087246},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d3efc0df0275c98440e69476f733097916a2d579","modified":1622794087247},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"53df7d537e26aaf062d70d86835c5fd8f81412f3","modified":1622794087247},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"12d99fb8b62bd9e34d9672f306c9ae4ace7e053e","modified":1622794087246},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"0bd2d696f62a997a11a7d84fec0130122234174e","modified":1622794087251},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"9c4fe2873123bf9ceacab5c50d17d8a0f1baef27","modified":1622794087251},{"_id":"themes/next/docs/ru/README.md","hash":"85dd68ed1250897a8e4a444a53a68c1d49eb7e11","modified":1622794087252},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"34b88784ec120dfdc20fa82aadeb5f64ef614d14","modified":1622794087253},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"5237a368ab99123749d724b6c379415f2c142a96","modified":1622794087252},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"fb23b85db6f7d8279d73ae1f41631f92f64fc864","modified":1622794087255},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"ca1030efdfca5e20f9db2e7a428998e66a24c0d0","modified":1622794087255},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"d3f03be036b75dc71cf3c366cd75aee7c127c874","modified":1622794087255},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"579c7bd8341873fb8be4732476d412814f1a3df7","modified":1622794087256},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"b92585d251f1f9ebe401abb5d932cb920f9b8b10","modified":1622794087256},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"8b18f84503a361fc712b0fe4d4568e2f086ca97d","modified":1622794087256},{"_id":"themes/next/docs/zh-CN/README.md","hash":"c038629ff8f3f24e8593c4c8ecf0bef3a35c750d","modified":1622794087256},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"d9ce7331c1236bbe0a551d56cef2405e47e65325","modified":1622794087256},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"9c8dc0b8170679cdc1ee9ee8dbcbaebf3f42897b","modified":1622794087266},{"_id":"themes/next/layout/_macro/post.swig","hash":"090b5a9b6fca8e968178004cbd6cff205b7eba57","modified":1622794087266},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"71655ca21907e9061b6e8ac52d0d8fbf54d0062b","modified":1622794087266},{"_id":"themes/next/layout/_partials/comments.swig","hash":"db6ab5421b5f4b7cb32ac73ad0e053fdf065f83e","modified":1622794087266},{"_id":"themes/next/layout/_partials/footer.swig","hash":"4369b313cbbeae742cb35f86d23d99d4285f7359","modified":1622794087267},{"_id":"themes/next/layout/_partials/languages.swig","hash":"ba9e272f1065b8f0e8848648caa7dea3f02c6be1","modified":1622794087270},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1622794087272},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"83a40ce83dfd5cada417444fb2d6f5470aae6bb0","modified":1622794087275},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"d1f2bfde6f1da51a2b35a7ab9e7e8eb6eefd1c6b","modified":1622794087276},{"_id":"themes/next/layout/_scripts/index.swig","hash":"cea942b450bcb0f352da78d76dc6d6f1d23d5029","modified":1622794087275},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"4d2c93c66e069852bb0e3ea2e268d213d07bfa3f","modified":1622794087276},{"_id":"themes/next/layout/_scripts/three.swig","hash":"a4f42f2301866bd25a784a2281069d8b66836d0b","modified":1622794087278},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"b782eb2e34c0c15440837040b5d65b093ab6ec04","modified":1622794087279},{"_id":"themes/next/layout/_third-party/index.swig","hash":"70c3c01dd181de81270c57f3d99b6d8f4c723404","modified":1622794087283},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"ef38c213679e7b6d2a4116f56c9e55d678446069","modified":1622794087278},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"2731e262a6b88eaee2a3ca61e6a3583a7f594702","modified":1622794087284},{"_id":"themes/next/scripts/events/index.js","hash":"5743cde07f3d2aa11532a168a652e52ec28514fd","modified":1622794087290},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"311e5eceec9e949f1ea8d623b083cec0b8700ff2","modified":1622794087284},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"aec50ed57b9d5d3faf2db3c88374f107203617e0","modified":1622794087293},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"703bdd142a671b4b67d3d9dfb4a19d1dd7e7e8f7","modified":1622794087294},{"_id":"themes/next/scripts/filters/locals.js","hash":"b193a936ee63451f09f8886343dcfdca577c0141","modified":1622794087294},{"_id":"themes/next/scripts/filters/minify.js","hash":"19985723b9f677ff775f3b17dcebf314819a76ac","modified":1622794087294},{"_id":"themes/next/scripts/filters/post.js","hash":"44ba9b1c0bdda57590b53141306bb90adf0678db","modified":1622794087295},{"_id":"themes/next/scripts/helpers/engine.js","hash":"bdb424c3cc0d145bd0c6015bb1d2443c8a9c6cda","modified":1622794087295},{"_id":"themes/next/scripts/helpers/font.js","hash":"40cf00e9f2b7aa6e5f33d412e03ed10304b15fd7","modified":1622794087295},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"5e11f30ddb5093a88a687446617a46b048fa02e5","modified":1622794087296},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"958e86b2bd24e4fdfcbf9ce73e998efe3491a71f","modified":1622794087296},{"_id":"themes/next/scripts/tags/button.js","hash":"8c6b45f36e324820c919a822674703769e6da32c","modified":1622794087296},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"94e0bbc7999b359baa42fa3731bdcf89c79ae2b3","modified":1622794087297},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f1826ade2d135e2f60e2d95cb035383685b3370c","modified":1622794087297},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"d902fd313e8d35c3cc36f237607c2a0536c9edf1","modified":1622794087297},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1622794087297},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1622794087297},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1622794087298},{"_id":"themes/next/scripts/tags/pdf.js","hash":"8c613b39e7bff735473e35244b5629d02ee20618","modified":1622794087298},{"_id":"themes/next/scripts/tags/tabs.js","hash":"93d8a734a3035c1d3f04933167b500517557ba3e","modified":1622794087298},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1622794087298},{"_id":"themes/next/source/css/_colors.styl","hash":"a8442520f719d3d7a19811cb3b85bcfd4a596e1f","modified":1622794087299},{"_id":"themes/next/source/css/main.styl","hash":"a3a3bbb5a973052f0186b3523911cb2539ff7b88","modified":1622794087328},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1622794087329},{"_id":"themes/next/source/css/_mixins.styl","hash":"e31a557f8879c2f4d8d5567ee1800b3e03f91f6e","modified":1622794087318},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1622794087329},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1622794087329},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1622794087330},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1622794087331},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1622794087331},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1622794087330},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1622794087332},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1622794087332},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1622794087333},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1622794087333},{"_id":"themes/next/source/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1622794087334},{"_id":"themes/next/source/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1622794087334},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1622794087333},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1622794087333},{"_id":"themes/next/source/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1622794087335},{"_id":"themes/next/source/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1622794087335},{"_id":"themes/next/source/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1622794087336},{"_id":"themes/next/source/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1622794087335},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"000bad572d76ee95d9c0a78f9ccdc8d97cc7d4b4","modified":1622794087267},{"_id":"themes/next/source/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1622794087337},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"c70f8e71e026e878a4e9d5ab3bbbf9b0b23c240c","modified":1622794087267},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"810d544019e4a8651b756dd23e5592ee851eda71","modified":1622794087267},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"7dbe93b8297b746afb89700b4d29289556e85267","modified":1622794087268},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"9440d8a3a181698b80e1fa47f5104f4565d8cdf3","modified":1622794087268},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"d31f896680a6c2f2c3f5128b4d4dd46c87ce2130","modified":1622794087268},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"c851717497ca64789f2176c9ecd1dedab237b752","modified":1622794087271},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"ae2261bea836581918a1c2b0d1028a78718434e0","modified":1622794087268},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"954ad71536b6eb08bd1f30ac6e2f5493b69d1c04","modified":1622794087272},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"9b7a66791d7822c52117fe167612265356512477","modified":1622794087271},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"ceba16b9bd3a0c5c8811af7e7e49d0f9dcb2f41e","modified":1622794087272},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1622794087273},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1622794087273},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"2b1a73556595c37951e39574df5a3f20b2edeaef","modified":1622794087273},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"2be50f9bfb1c56b85b3b6910a7df27f51143632c","modified":1622794087274},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"48430bd03b8f19c9b8cdb2642005ed67d56c6e0b","modified":1622794087274},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"f48a6a8eba04eb962470ce76dd731e13074d4c45","modified":1622794087275},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"c46849e0af8f8fb78baccd40d2af14df04a074af","modified":1622794087275},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"077b5d66f6309f2e7dcf08645058ff2e03143e6c","modified":1622794087276},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1622794087277},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1622794087277},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1622794087277},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1622794087277},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1622794087278},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"2fa2b51d56bfac6a1ea76d651c93b9c20b01c09b","modified":1622794087278},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1622794087278},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"1472cabb0181f60a6a0b7fec8899a4d03dfb2040","modified":1622794087279},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"f910618292c63871ca2e6c6e66c491f344fa7b1f","modified":1622794087279},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1622794087279},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"f39a5bf3ce9ee9adad282501235e0c588e4356ec","modified":1622794087280},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b14908644225d78c864cd0a9b60c52407de56183","modified":1622794087280},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"82f5b6822aa5ec958aa987b101ef860494c6cf1f","modified":1622794087281},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"d6ceb70648555338a80ae5724b778c8c58d7060d","modified":1622794087281},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"f7a9eca599a682479e8ca863db59be7c9c7508c8","modified":1622794087281},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"be0a8eccf1f6dc21154af297fc79555343031277","modified":1622794087282},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"6c5976621efd5db5f7c4c6b4f11bc79d6554885f","modified":1622794087283},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"4791c977a730f29c846efcf6c9c15131b9400ead","modified":1622794087283},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"ecf751321e799f0fb3bf94d049e535130e2547aa","modified":1622794087283},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"d35a999d67f4c302f76fdf13744ceef3c6506481","modified":1622794087284},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1622794087284},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1622794087285},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"4b1986e43d6abce13450d2b41a736dd6a5620a10","modified":1622794087285},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1622794087285},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"b26ac2bfbe91dd88267f8b96aee6bb222b265b7a","modified":1622794087286},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"5f6a966c509680dbfa70433f9d658cee59c304d7","modified":1622794087286},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"d56d5af427cdfecc33a0f62ee62c056b4e33d095","modified":1622794087286},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"f3c43664a071ff3c0b28bd7e59b5523446829576","modified":1622794087286},{"_id":"themes/next/scripts/events/lib/config.js","hash":"d34c6040b13649714939f59be5175e137de65ede","modified":1622794087290},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"d30b0e255a8092043bac46441243f943ed6fb09b","modified":1622794087287},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1622794087290},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"f233d8d0103ae7f9b861344aa65c1a3c1de8a845","modified":1622794087291},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"a54708fd9309b4357c423a3730eb67f395344a5e","modified":1622794087291},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"2486f3e0150c753e5f3af1a3665d074704b8ee2c","modified":1622794087291},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"7f2d93af012c1e14b8596fecbfc7febb43d9b7f5","modified":1622794087291},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"4c0c99c7e0f00849003dfce02a131104fb671137","modified":1622794087292},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"7f8b92913d21070b489457fa5ed996d2a55f2c32","modified":1622794087292},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"e51dc3072c1ba0ea3008f09ecae8b46242ec6021","modified":1622794087292},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"d5fefc31fba4ab0188305b1af1feb61da49fdeb0","modified":1622794087292},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"6cbd85f9433c06bae22225ccf75ac55e04f2d106","modified":1622794087292},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"f4e694e5db81e57442c7e34505a416d818b3044a","modified":1622794087327},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"f70be8e229da7e1715c11dd0e975a2e71e453ac8","modified":1622794087327},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"62df49459d552bbf73841753da8011a1f5e875c8","modified":1622794087327},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"612ec843372dae709acb17112c1145a53450cc59","modified":1622794087328},{"_id":"themes/next/source/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1622794087335},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1622794087336},{"_id":"themes/next/source/css/_variables/base.styl","hash":"818508748b7a62e02035e87fe58e75b603ed56dc","modified":1622794087328},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"a47725574e1bee3bc3b63b0ff2039cc982b17eff","modified":1622794087300},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"ca5e70662dcfb261c25191cc5db5084dcf661c76","modified":1622794087299},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"8e7b57a72e757cf95278239641726bb2d5b869d1","modified":1622794087300},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"2e3bf7baf383c9073ec5e67f157d3cb3823c0957","modified":1622794087304},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1622794087346},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1622794087346},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"681d33e3bc85bdca407d93b134c089264837378c","modified":1622794087307},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"a1690e035b505d28bdef2b4424c13fc6312ab049","modified":1622794087307},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"0b2c4b78eead410020d7c4ded59c75592a648df8","modified":1622794087311},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a2e9e00962e43e98ec2614d6d248ef1773bb9b78","modified":1622794087311},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"b1f0fab7344a20ed6748b04065b141ad423cf4d9","modified":1622794087311},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1622794087313},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"8f58570a1bbc34c4989a47a1b7d42a8030f38b06","modified":1622794087313},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1622794087313},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"18ce72d90459c9aa66910ac64eae115f2dde3767","modified":1622794087314},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"179e33b8ac7f4d8a8e76736a7e4f965fe9ab8b42","modified":1622794087318},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"f6516d0f7d89dc7b6c6e143a5af54b926f585d82","modified":1622794087319},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"7785bd756e0c4acede3a47fec1ed7b55988385a5","modified":1622794087319},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"6136da4bbb7e70cec99f5c7ae8c7e74f5e7c261a","modified":1622794087319},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"a717969829fa6ef88225095737df3f8ee86c286b","modified":1622794087320},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"bb7ace23345364eb14983e860a7172e1683a4c94","modified":1622794087319},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"7104b9cef90ca3b140d7a7afcf15540a250218fc","modified":1622794087319},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"4d1c17345d2d39ef7698f7acf82dfc0f59308c34","modified":1622794087320},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"93db5dafe9294542a6b5f647643cb9deaced8e06","modified":1622794087322},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"2b2e7b5cea7783c9c8bb92655e26a67c266886f0","modified":1622794087323},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"f0131db6275ceaecae7e1a6a3798b8f89f6c850d","modified":1622794087320},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1622794087324},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1622794087324},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"70a4324b70501132855b5e59029acfc5d3da1ebd","modified":1622794087325},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"e282df938bd029f391c466168d0e68389978f120","modified":1622794087324},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"85da2f3006f4bef9a2199416ecfab4d288f848c4","modified":1622794087325},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"44f47c88c06d89d06f220f102649057118715828","modified":1622794087325},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"e740deadcfc4f29c5cb01e40f9df6277262ba4e3","modified":1622794087326},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1622794087326},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1622794087338},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1622794087342},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fafc96c86926b22afba8bb9418c05e6afbc05a57","modified":1622794087300},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1622794087300},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1622794087301},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"e771dcb0b4673e063c0f3e2d73e7336ac05bcd57","modified":1622794087301},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"e75693f33dbc92afc55489438267869ae2f3db54","modified":1622794087302},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"d21d4ac1982c13d02f125a67c065412085a92ff2","modified":1622794087302},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f49ca072b5a800f735e8f01fc3518f885951dd8e","modified":1622794087302},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"902569a9dea90548bec21a823dd3efd94ff7c133","modified":1622794087302},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ded41fd9d20a5e8db66aaff7cc50f105f5ef2952","modified":1622794087303},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"1e4190c10c9e0c9ce92653b0dbcec21754b0b69d","modified":1622794087303},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"72d495a88f7d6515af425c12cbc67308a57d88ea","modified":1622794087303},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"65cb6edb69e94e70e3291e9132408361148d41d5","modified":1622794087303},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"6a97bcfa635d637dc59005be3b931109e0d1ead5","modified":1622794087303},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"d114b2a531129e739a27ba6271cfe6857aa9a865","modified":1622794087304},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1622794087304},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"99e12c9ce3d14d4837e3d3f12fc867ba9c565317","modified":1622794087304},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"a760ee83ba6216871a9f14c5e56dc9bd0d9e2103","modified":1622794087304},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1622794087304},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"b49e9fbd3c182b8fc066b8c2caf248e3eb748619","modified":1622794087305},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1622794087305},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"e2992846b39bf3857b5104675af02ba73e72eed5","modified":1622794087305},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"9f0b93d109c9aec79450c8a0cf4a4eab717d674d","modified":1622794087305},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9a878d0119785a2316f42aebcceaa05a120b9a7a","modified":1622794087305},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"454a4aebfabb4469b92a8cbb49f46c49ac9bf165","modified":1622794087306},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e2d606f1ac343e9be4f15dbbaf3464bc4df8bf81","modified":1622794087306},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"e7a9fdb6478b8674b1cdf94de4f8052843fb71d9","modified":1622794087306},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"a793cfff86ad4af818faef04c18013077873f8f0","modified":1622794087306},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1622794087306},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"5f432a6ed9ca80a413c68b00e93d4a411abf280a","modified":1622794087306},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"45a239edca44acecf971d99b04f30a1aafbf6906","modified":1622794087307},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b2fc519828fe89a1f8f03ff7b809ad68cd46f3d7","modified":1622794087307},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2cb1876e9e0c9ac32160888af27b1178dbcb0616","modified":1622794087307},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"44487d9ab290dc97871fa8dd4487016deb56e123","modified":1622794087308},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"fa0222197b5eee47e18ac864cdc6eac75678b8fe","modified":1622794087307},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"1f0e7fbe80956f47087c2458ea880acf7a83078b","modified":1622794087308},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"9b479c2f9a9bfed77885e5093b8245cc5d768ec7","modified":1622794087308},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"a960a2dd587b15d3b3fe1b59525d6fa971c6a6ec","modified":1622794087308},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"a05a4031e799bc864a4536f9ef61fe643cd421af","modified":1622794087308},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"b3220db827e1adbca7880c2bb23e78fa7cbe95cb","modified":1622794087309},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"a9cd93c36bae5af9223e7804963096274e8a4f03","modified":1622794087310},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"2a47f8a6bb589c2fb635e6c1e4a2563c7f63c407","modified":1622794087310},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"f71a3e86c05ea668b008cf05a81f67d92b6d65e4","modified":1622794087312},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1622794087312},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"35c871a809afa8306c8cde13651010e282548bc6","modified":1622794087312},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"3b3acc5caa0b95a2598bef4eeacb21bab21bea56","modified":1622794087312},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"1d2778ca5aeeeafaa690dc2766b01b352ab76a02","modified":1622794087314},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"709d10f763e357e1472d6471f8be384ec9e2d983","modified":1622794087314},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"d7fce4b51b5f4b7c31d93a9edb6c6ce740aa0d6b","modified":1622794087314},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"e4d9a77ffe98e851c1202676940097ba28253313","modified":1622794087314},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b49c64f8e9a6ca1c45c0ba98febf1974fdd03616","modified":1622794087317},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"f23670f1d8e749f3e83766d446790d8fd9620278","modified":1622794087317},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1622794087318},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1622794087342},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1622794087345},{"_id":"public/categories/index.html","hash":"ad60d1cf3d6ff3744fac1ffb0b3bcd764514a5f2","modified":1656252653696},{"_id":"public/tags/index.html","hash":"c53bd92251f47610753ca437fcabbad4478b5878","modified":1656252653696},{"_id":"public/2021/06/04/Block 写法备忘/index.html","hash":"6ad0feb40243fdace40f688f14e7231acda46e43","modified":1625628229364},{"_id":"public/2021/06/04/Bazel 问题/index.html","hash":"9d9daf9ef418587e9ec4864142b508ffd493f49d","modified":1656252653696},{"_id":"public/2021/06/04/Bazel 构建步骤/index.html","hash":"c95b7be0174bf89697e6e194c3cda97c7b9199c6","modified":1656252653696},{"_id":"public/2021/01/21/热修复/index.html","hash":"7763d784271d8c67518c3bdbfda0b8cda60c0c82","modified":1656252653696},{"_id":"public/2021/01/11/常用工具 & 网站 & 命令/index.html","hash":"8156d80d28037831f98c3f9896c9c8c58c615032","modified":1656252653696},{"_id":"public/2021/01/07/Swift 语法/index.html","hash":"51f3a82e9a8f9502ea049c63f9fc7d334ec59b23","modified":1656252653696},{"_id":"public/2021/01/08/React 语法/index.html","hash":"6dd6f641705898394f7394fce3045dcf5138f896","modified":1656252653696},{"_id":"public/2021/01/06/Adyen SDK 接入（二）/index.html","hash":"6f35b05f8780453a9e692dbf289256666d9b4943","modified":1656252653696},{"_id":"public/2021/01/04/OC Swift 混编问题/index.html","hash":"cc59ccf7b28af1b881173c088bea36c3afdb9f14","modified":1656252653696},{"_id":"public/2020/12/29/TypeScript/index.html","hash":"220b4b69f760036f0b152f3579a8516be1e5ca99","modified":1656252653696},{"_id":"public/2020/12/23/JavaScript 学习资料/index.html","hash":"e740ef2412a4fc75367dc0e37adeeff3c7e3591c","modified":1656252653696},{"_id":"public/2020/11/23/iPhone 屏幕尺寸/index.html","hash":"94501f3ddeef6ce783d29ad42634df6c31fc7a5f","modified":1661764871005},{"_id":"public/tags/iOS/index.html","hash":"dda67b7a7394d2595de4f824d95655062ac3f210","modified":1656252653696},{"_id":"public/tags/SDK/index.html","hash":"5cc0cb4c81deb8d5e585a28e325a148fae73acc2","modified":1656252653696},{"_id":"public/tags/学习资料/index.html","hash":"589020e1bbf2882d279dc07daa81d716634c4374","modified":1656252653696},{"_id":"public/tags/支付/index.html","hash":"af80d71d9b19c038670b9c755a89049b4034f745","modified":1656252653696},{"_id":"public/tags/编程语言/index.html","hash":"83c3b3455bb29feb1f3f8646cb288d126fe50276","modified":1656252653696},{"_id":"public/tags/语法基础/index.html","hash":"5a351b4df338aa4e6cb7e713f0c50acb177127bd","modified":1656252653696},{"_id":"public/tags/数据结构与算法/index.html","hash":"08b163ab56bd423a79376aba7a4d77bc79c12b96","modified":1656252653696},{"_id":"public/tags/问题/index.html","hash":"3c27bd00361601caee9c29e497745b739938748e","modified":1656252653696},{"_id":"public/tags/UI/index.html","hash":"fab8c69af1ae3975c94889661bf8631c537e9171","modified":1656252653696},{"_id":"public/tags/优化/index.html","hash":"7a5cc89376ff0ab7db6befd96af103272240238d","modified":1656252653696},{"_id":"public/tags/总结/index.html","hash":"a90e6d6c83f4c3f4543da7dec22a13643e2541a1","modified":1656252653696},{"_id":"public/tags/Tools/index.html","hash":"72df7767f5925c28ab316aba20075f948657a695","modified":1656252653696},{"_id":"public/tags/热修复/index.html","hash":"dd8c7cfdd0c99af13babde2d12e21e37c7af3ffc","modified":1656252653696},{"_id":"public/categories/JavaScript/index.html","hash":"7630a8fe25696349c899f5a28a9bb437de7ebb96","modified":1656252653696},{"_id":"public/categories/React-Native/index.html","hash":"7f4401d0f282bb56fa7f94bba1394e6b4d477200","modified":1656252653696},{"_id":"public/categories/iOS-开发笔记/index.html","hash":"eb29fb957978f0c29c80d40c47823060d39255b4","modified":1656252653696},{"_id":"public/categories/LeetCode/index.html","hash":"a8dffcfd92c92d72fe2bfd64e51ce8920328b3bf","modified":1656252653696},{"_id":"public/categories/React/index.html","hash":"36b0b23e4428b5030aa3e727d486fb057d0bdfc0","modified":1656252653696},{"_id":"public/categories/Swift/index.html","hash":"c6e9fddb304393f7d246d9cb8c16d576024e7fe8","modified":1656252653696},{"_id":"public/categories/TypeScript/index.html","hash":"b410499caad8b6cc3def76be624841d64ec339c2","modified":1656252653696},{"_id":"public/categories/Others/index.html","hash":"0e0051897b4513975ae66900004158d75f7a8d9b","modified":1656252653696},{"_id":"public/archives/index.html","hash":"5d507ac79467a42b63059bb98f887d877adcd129","modified":1656252653696},{"_id":"public/archives/page/2/index.html","hash":"70e9dbf06e52c7cdfd50d58ddaaee7daa626042b","modified":1656252653696},{"_id":"public/archives/2020/index.html","hash":"ce600c3385bd972eed68767d3d507a4c8953b9f7","modified":1656252653696},{"_id":"public/archives/2020/11/index.html","hash":"6d8e15246b18bd3599d0fbc4a4ed83d307598285","modified":1656252653696},{"_id":"public/archives/2020/12/index.html","hash":"76573b2493680b730f9b56475f7203ba93d86f84","modified":1656252653696},{"_id":"public/archives/2021/index.html","hash":"4e49f40f9109ebd3eab12ef1111231b4be814cdb","modified":1656252653696},{"_id":"public/archives/2021/page/2/index.html","hash":"2ccd4707177aab14e0bd1841549800b6f50a3d49","modified":1656252653696},{"_id":"public/archives/2021/01/index.html","hash":"2799ed71e343d57371e193f235970905d722f4b0","modified":1656252653696},{"_id":"public/archives/2021/06/index.html","hash":"ad24c2393df3e98051f55b406dafdc83a277b281","modified":1656252653696},{"_id":"public/2021/01/25/LeetCode 资料/index.html","hash":"4489c45839bdb5a5620f956decbbe3fb78ca8c97","modified":1661764871005},{"_id":"public/2021/01/18/iOS 启动时间优化/index.html","hash":"f2dd7ff42162a2da453d75ce00ef250d565d184f","modified":1656252653696},{"_id":"public/2021/01/06/Adyen SDK 接入（一）账号注册 & 准备工作/index.html","hash":"403713d3c10dcd7d45ffc188cbb60c5870d53e23","modified":1656252653696},{"_id":"public/2020/12/23/React Native Flexbox 布局/index.html","hash":"84cc82fc05752c14c7a6a5ea326531aa5c6e46ff","modified":1656252653696},{"_id":"public/2020/12/23/React Native 学习资料/index.html","hash":"9febcf5a65af36e40d87516e05caab399547790c","modified":1656252653696},{"_id":"public/2020/12/22/JavaScript 语法/index.html","hash":"259287660dee063ea9c04b7f9370cc9a1663a898","modified":1656252653696},{"_id":"public/index.html","hash":"8a4ba643da64fd32fc730643cd711e0a6bd98506","modified":1661764871005},{"_id":"public/page/2/index.html","hash":"d0b6f1994ca0aa6ad5fad9f085f53662ca14ba8c","modified":1661764871005},{"_id":"public/CNAME","hash":"a9751b5c4fdd4167aafcdd5b1fccc7024e5db9eb","modified":1625626546170},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1625626546170},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1625626546170},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1625626546170},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1625626546170},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1625626546170},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1625626546170},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1625626546170},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1625626546170},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1625626546170},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1625626546170},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1625626546170},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1625626546170},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1625626546170},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1625626546170},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1625626546170},{"_id":"public/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1625626546170},{"_id":"public/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1625626546170},{"_id":"public/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1625626546170},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1625626546170},{"_id":"public/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1625626546170},{"_id":"public/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1625626546170},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1625626546170},{"_id":"public/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1625626546170},{"_id":"public/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1625626546170},{"_id":"public/css/main.css","hash":"0ab80e49e432648756695ce3f8325c756f4f8633","modified":1625626546170},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1625626546170},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1625626546170},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1625626546170},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1625626546170},{"_id":"public/categories/构建工具/index.html","hash":"f873875be03de80be81682064bae3af5a92793ce","modified":1656252653696},{"_id":"public/tags/Bazel/index.html","hash":"add095e24da50eac7a2bd0b38567bfaa814f3dab","modified":1656252653696},{"_id":"public/tags/Block/index.html","hash":"11d7a31ca570962adf1b371f73e1d3c6c7365c95","modified":1656252653696},{"_id":"source/_drafts/WWDC 22 - 110352 拥抱 Swift 泛型 直译.md","hash":"8af15c5e5f021fe2c37ff032ef7899ce9e8e6367","modified":1656752708868},{"_id":"source/_posts/iOS 动态化.md","hash":"59d5fffbe05179be773689a10e6c7c98d3b75342","modified":1642408603703},{"_id":"public/2022/01/17/iOS 动态化/index.html","hash":"e47622df262a56f27749a1df0ce30988db1defad","modified":1656252653696},{"_id":"public/2021/07/07/Block 写法备忘/index.html","hash":"3925b4271a0ebc0c0a58a959c28c89371eba03c3","modified":1656252653696},{"_id":"public/archives/2021/07/index.html","hash":"af80be448252d3018b9edce918485e6c65baed08","modified":1656252653696},{"_id":"public/archives/2022/index.html","hash":"f757f3ac43ec6ef09edf0a3d116e2a8aeb70fd01","modified":1656252653696},{"_id":"public/archives/2022/01/index.html","hash":"b59758dc4a05ad3cd665876671d11d84eb5d7bd1","modified":1656252653696},{"_id":"public/tags/动态化/index.html","hash":"4fad791d6bf664f1bbc9504cb631675457c53b77","modified":1656252653696},{"_id":"source/_drafts/WWDC 22 - 110352 拥抱 Swift 泛型 直译无图.md","hash":"90d06689d4e257a24da21002d07f76656b7ebe76","modified":1656407638292},{"_id":"source/_drafts/WWDC 22 - 110352 拥抱 Swift 泛型 概述&大纲.md","hash":"2993304a54878516b5b29abee2a9937d04850daa","modified":1656658479379},{"_id":"source/_drafts/WWDC 22 - 110353 设计 Swift 协议接口 直译.md","hash":"db07d0703cfdf981bf25916cb99f6af77ce965ca","modified":1656656853422},{"_id":"source/_drafts/WWDC 22 - 110353 设计 Swift 协议接口 第一次整理.md","hash":"dced7bd97a6dba807d5a17d03051c07d44e00613","modified":1656738180381},{"_id":"source/_drafts/WWDC 22 - 110352 拥抱 Swift 泛型 第一次整理.md","hash":"ca915aa1aa9511e8471224511eef4c9fa68d33b9","modified":1656482123368}],"Category":[{"name":"JavaScript","_id":"ckqsw2n6v000451dxetdz3q52"},{"name":"React Native","_id":"ckqsw2n6y000951dxcpfi1gpz"},{"name":"数据结构","_id":"ckqsw2n74000g51dxgglmayi3"},{"name":"买房","_id":"ckqsw2n76000m51dx1ney4b3i"},{"name":"iOS 开发笔记","_id":"ckqsw2n79000s51dxf87bfd9b"},{"name":"LeetCode","_id":"ckqsw2n7e001551dx0fav1pjd"},{"name":"React","_id":"ckqsw2n7h001d51dx33idh9g9"},{"name":"Swift","_id":"ckqsw2n7l001k51dx41s805xu"},{"name":"TypeScript","_id":"ckqsw2n7s001r51dxgl4q0tye"},{"name":"Others","_id":"ckqsw2n7u001y51dx1efiggox"},{"name":"构建工具","_id":"ckqsx2q150000kfdxcd505kgw"}],"Data":[],"Page":[{"title":"分类","type":"categories","date":"2021-01-12T09:16:01.000Z","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ntype: \"categories\"\ndate: 2021-01-12 17:16:01\n---\n","updated":"2021-06-04T08:08:07.245Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckqsw2n6p000051dx8b1y2gfn","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","type":"tags","date":"2021-01-12T09:15:56.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ntype: \"tags\"\ndate: 2021-01-12 17:15:56\n---\n","updated":"2021-06-04T08:08:07.245Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckqsw2n6t000251dxhaof6k4r","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"JavaScript 学习记录","date":"2020-12-23T09:19:21.000Z","_content":"\n\n\n| Date        |                                                  |\n| ----------- | ------------------------------------------------ |\n| 12.22 12.23 | 语法 https://www.youtube.com/watch?v=PkZNo7MFNFg |","source":"_drafts/JavaScript 学习记录.md","raw":"---\ntitle: JavaScript 学习记录\ndate: 2020-12-23 17:19:21\ntags:\n- 学习记录\ncategories:\n- JavaScript\n---\n\n\n\n| Date        |                                                  |\n| ----------- | ------------------------------------------------ |\n| 12.22 12.23 | 语法 https://www.youtube.com/watch?v=PkZNo7MFNFg |","slug":"JavaScript 学习记录","published":0,"updated":"2021-06-04T08:08:07.237Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqsw2n6r000151dx9oro0292","content":"<table>\n<thead>\n<tr>\n<th>Date</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>12.22 12.23</td>\n<td>语法 <a href=\"https://www.youtube.com/watch?v=PkZNo7MFNFg\">https://www.youtube.com/watch?v=PkZNo7MFNFg</a></td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<table>\n<thead>\n<tr>\n<th>Date</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>12.22 12.23</td>\n<td>语法 <a href=\"https://www.youtube.com/watch?v=PkZNo7MFNFg\">https://www.youtube.com/watch?v=PkZNo7MFNFg</a></td>\n</tr>\n</tbody></table>\n"},{"title":"React Native 学习记录","date":"2020-12-28T09:19:21.000Z","_content":"\n\n\n| Date        |                                                      |\n| ----------- | ---------------------------------------------------- |\n| 12.23 12.24 | 购物清单 https://www.youtube.com/watch?v=Hf4MJH0jDb4 |\n| 12.25 12.28 | 各种组件 https://www.youtube.com/watch?v=0-S5a0eXPoc |\n\n","source":"_drafts/React Native 学习记录.md","raw":"---\ntitle: React Native 学习记录\ndate: 2020-12-28 17:19:21\ntags:\n- 学习记录\ncategories:\n- React Native\n---\n\n\n\n| Date        |                                                      |\n| ----------- | ---------------------------------------------------- |\n| 12.23 12.24 | 购物清单 https://www.youtube.com/watch?v=Hf4MJH0jDb4 |\n| 12.25 12.28 | 各种组件 https://www.youtube.com/watch?v=0-S5a0eXPoc |\n\n","slug":"React Native 学习记录","published":0,"updated":"2021-06-04T08:08:07.238Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqsw2n6u000351dx8wbu6kz4","content":"<table>\n<thead>\n<tr>\n<th>Date</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>12.23 12.24</td>\n<td>购物清单 <a href=\"https://www.youtube.com/watch?v=Hf4MJH0jDb4\">https://www.youtube.com/watch?v=Hf4MJH0jDb4</a></td>\n</tr>\n<tr>\n<td>12.25 12.28</td>\n<td>各种组件 <a href=\"https://www.youtube.com/watch?v=0-S5a0eXPoc\">https://www.youtube.com/watch?v=0-S5a0eXPoc</a></td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<table>\n<thead>\n<tr>\n<th>Date</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>12.23 12.24</td>\n<td>购物清单 <a href=\"https://www.youtube.com/watch?v=Hf4MJH0jDb4\">https://www.youtube.com/watch?v=Hf4MJH0jDb4</a></td>\n</tr>\n<tr>\n<td>12.25 12.28</td>\n<td>各种组件 <a href=\"https://www.youtube.com/watch?v=0-S5a0eXPoc\">https://www.youtube.com/watch?v=0-S5a0eXPoc</a></td>\n</tr>\n</tbody></table>\n"},{"title":"数据结构学习记录","date":"2020-12-31T09:19:21.000Z","_content":"\n\n\n| Date                                                         |                                             |\n| ------------------------------------------------------------ | ------------------------------------------- |\n| 12.29 1-7<br />12.30 8-15<br />1.1 15-47<br />1.2 48-49<br />1.4 49-50<br />1.11 50-54<br />1.13 55-60 | https://www.bilibili.com/video/BV17y4y1U7Np |","source":"_drafts/数据结构学习记录.md","raw":"---\ntitle: 数据结构学习记录\ndate: 2020-12-31 17:19:21\ntags:\n- 学习记录\ncategories:\n- 数据结构\n---\n\n\n\n| Date                                                         |                                             |\n| ------------------------------------------------------------ | ------------------------------------------- |\n| 12.29 1-7<br />12.30 8-15<br />1.1 15-47<br />1.2 48-49<br />1.4 49-50<br />1.11 50-54<br />1.13 55-60 | https://www.bilibili.com/video/BV17y4y1U7Np |","slug":"数据结构学习记录","published":0,"updated":"2021-06-04T08:08:07.238Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqsw2n6w000651dxh1ai8bdk","content":"<table>\n<thead>\n<tr>\n<th>Date</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>12.29 1-7<br />12.30 8-15<br />1.1 15-47<br />1.2 48-49<br />1.4 49-50<br />1.11 50-54<br />1.13 55-60</td>\n<td><a href=\"https://www.bilibili.com/video/BV17y4y1U7Np\">https://www.bilibili.com/video/BV17y4y1U7Np</a></td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<table>\n<thead>\n<tr>\n<th>Date</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>12.29 1-7<br />12.30 8-15<br />1.1 15-47<br />1.2 48-49<br />1.4 49-50<br />1.11 50-54<br />1.13 55-60</td>\n<td><a href=\"https://www.bilibili.com/video/BV17y4y1U7Np\">https://www.bilibili.com/video/BV17y4y1U7Np</a></td>\n</tr>\n</tbody></table>\n"},{"title":"杭州看房记录","date":"2021-01-24T12:14:03.000Z","_content":"\n\n\n| 楼盘 | 板块 | 房价 | 开盘时间 | 冻资/验资 | 容积率 | 绿化率 | 交付时间 | 物业费 |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| 杭语清澄<br />地暖 中央空调<br />高架直线距离 100 米 | 崇贤 | 2.3 万 | 2021.3 | 验资 50 万 | 2.2 | 35% | 2023.6.30 | 2.75 |\n| 祥生湛景星合映 | 崇贤 | 2.3 万 | 2021.3 | 验资 50 万 | 2.2 | 35% | 2023.6.30 | 2.75+0.5 |\n| 路劲银城澜仕里 | 崇贤 | 2.3 万 | 2021.3 | 验资 60 万 | 2.2 | 35% | 2022.9.30 | 2.75 |\n| 绿地众安宸瀚里<br />自带商业街 | 崇贤 | 2.3 万 | 2021.3 | 验资 50 万 | 2.3 | 30% | 2023.4.30 | 2.75+0.5 |\n| | | | | | | | | |\n| 彩虹天空之城 | 新塘 | 2.56 万<br />63-128 方 | 2021.3 | 冻资 70 万 | 2.6 | 35% | 2023.8.31 | 3.1 |\n| 保利欣品华庭<br />自带商业街 | 新街 | 2.7 万<br />96-106 方 | 2021.1 | | 2.4 | 35.1% | 2023.6.30 | 3.2 |\n| 保利和者时光印象府<br />自带商业街<br />厨房小 | 新街 | 2.5 万<br />85-105 方 | 2021.2 | 验资 60 万 | 2.5 | 35% | 2023.10 | |\n| | | | | | | | | |\n| 建发金辉紫璋台<br />噪音 | 三墩 | 3.0 万<br />95-139 方 | 2021.1 | | 3 | 30% | 2020.12.30 | |\n| 招商融信天澜 | 三墩 | 2.81 万<br />103-133 方 | 2021.1 | | 3.1 | 35% | 2023.9 | |\n| | | | | | | | | |\n| 万科前宸 | 北部新城 | 3.05 万 | | | | | | |\n| 星创城映月璟园 | 北部新城 | 2.9 万<br />102-133 方 | 2021.1 | | | | | |\n| | | | | | | | | |\n| 锦上文澜 | 下沙沿江 | 3 万<br />89 方 | 2021.1 | | 2.6 | 35% | 2023.11 | |\n\n\n南部卧城\n\n萧山南站\n\n钱塘新区\n\n乔司\n\n良渚\n\n瓶窑\n\n闲林\n\n临平山北\n\n临平新城\n\n未来科技城\n\n未来科技城 2.0\n\n星桥\n\n江干\n\n\n\n","source":"_drafts/杭州看房记录.md","raw":"---\ntitle: 杭州看房记录\ndate: 2021-01-24 20:14:03\ntags:\ncategories:\n- 买房\n---\n\n\n\n| 楼盘 | 板块 | 房价 | 开盘时间 | 冻资/验资 | 容积率 | 绿化率 | 交付时间 | 物业费 |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| 杭语清澄<br />地暖 中央空调<br />高架直线距离 100 米 | 崇贤 | 2.3 万 | 2021.3 | 验资 50 万 | 2.2 | 35% | 2023.6.30 | 2.75 |\n| 祥生湛景星合映 | 崇贤 | 2.3 万 | 2021.3 | 验资 50 万 | 2.2 | 35% | 2023.6.30 | 2.75+0.5 |\n| 路劲银城澜仕里 | 崇贤 | 2.3 万 | 2021.3 | 验资 60 万 | 2.2 | 35% | 2022.9.30 | 2.75 |\n| 绿地众安宸瀚里<br />自带商业街 | 崇贤 | 2.3 万 | 2021.3 | 验资 50 万 | 2.3 | 30% | 2023.4.30 | 2.75+0.5 |\n| | | | | | | | | |\n| 彩虹天空之城 | 新塘 | 2.56 万<br />63-128 方 | 2021.3 | 冻资 70 万 | 2.6 | 35% | 2023.8.31 | 3.1 |\n| 保利欣品华庭<br />自带商业街 | 新街 | 2.7 万<br />96-106 方 | 2021.1 | | 2.4 | 35.1% | 2023.6.30 | 3.2 |\n| 保利和者时光印象府<br />自带商业街<br />厨房小 | 新街 | 2.5 万<br />85-105 方 | 2021.2 | 验资 60 万 | 2.5 | 35% | 2023.10 | |\n| | | | | | | | | |\n| 建发金辉紫璋台<br />噪音 | 三墩 | 3.0 万<br />95-139 方 | 2021.1 | | 3 | 30% | 2020.12.30 | |\n| 招商融信天澜 | 三墩 | 2.81 万<br />103-133 方 | 2021.1 | | 3.1 | 35% | 2023.9 | |\n| | | | | | | | | |\n| 万科前宸 | 北部新城 | 3.05 万 | | | | | | |\n| 星创城映月璟园 | 北部新城 | 2.9 万<br />102-133 方 | 2021.1 | | | | | |\n| | | | | | | | | |\n| 锦上文澜 | 下沙沿江 | 3 万<br />89 方 | 2021.1 | | 2.6 | 35% | 2023.11 | |\n\n\n南部卧城\n\n萧山南站\n\n钱塘新区\n\n乔司\n\n良渚\n\n瓶窑\n\n闲林\n\n临平山北\n\n临平新城\n\n未来科技城\n\n未来科技城 2.0\n\n星桥\n\n江干\n\n\n\n","slug":"杭州看房记录","published":0,"updated":"2021-06-04T08:08:07.238Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqsw2n6x000751dxazf1031p","content":"<table>\n<thead>\n<tr>\n<th>楼盘</th>\n<th>板块</th>\n<th>房价</th>\n<th>开盘时间</th>\n<th>冻资/验资</th>\n<th>容积率</th>\n<th>绿化率</th>\n<th>交付时间</th>\n<th>物业费</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>杭语清澄<br />地暖 中央空调<br />高架直线距离 100 米</td>\n<td>崇贤</td>\n<td>2.3 万</td>\n<td>2021.3</td>\n<td>验资 50 万</td>\n<td>2.2</td>\n<td>35%</td>\n<td>2023.6.30</td>\n<td>2.75</td>\n</tr>\n<tr>\n<td>祥生湛景星合映</td>\n<td>崇贤</td>\n<td>2.3 万</td>\n<td>2021.3</td>\n<td>验资 50 万</td>\n<td>2.2</td>\n<td>35%</td>\n<td>2023.6.30</td>\n<td>2.75+0.5</td>\n</tr>\n<tr>\n<td>路劲银城澜仕里</td>\n<td>崇贤</td>\n<td>2.3 万</td>\n<td>2021.3</td>\n<td>验资 60 万</td>\n<td>2.2</td>\n<td>35%</td>\n<td>2022.9.30</td>\n<td>2.75</td>\n</tr>\n<tr>\n<td>绿地众安宸瀚里<br />自带商业街</td>\n<td>崇贤</td>\n<td>2.3 万</td>\n<td>2021.3</td>\n<td>验资 50 万</td>\n<td>2.3</td>\n<td>30%</td>\n<td>2023.4.30</td>\n<td>2.75+0.5</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>彩虹天空之城</td>\n<td>新塘</td>\n<td>2.56 万<br />63-128 方</td>\n<td>2021.3</td>\n<td>冻资 70 万</td>\n<td>2.6</td>\n<td>35%</td>\n<td>2023.8.31</td>\n<td>3.1</td>\n</tr>\n<tr>\n<td>保利欣品华庭<br />自带商业街</td>\n<td>新街</td>\n<td>2.7 万<br />96-106 方</td>\n<td>2021.1</td>\n<td></td>\n<td>2.4</td>\n<td>35.1%</td>\n<td>2023.6.30</td>\n<td>3.2</td>\n</tr>\n<tr>\n<td>保利和者时光印象府<br />自带商业街<br />厨房小</td>\n<td>新街</td>\n<td>2.5 万<br />85-105 方</td>\n<td>2021.2</td>\n<td>验资 60 万</td>\n<td>2.5</td>\n<td>35%</td>\n<td>2023.10</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>建发金辉紫璋台<br />噪音</td>\n<td>三墩</td>\n<td>3.0 万<br />95-139 方</td>\n<td>2021.1</td>\n<td></td>\n<td>3</td>\n<td>30%</td>\n<td>2020.12.30</td>\n<td></td>\n</tr>\n<tr>\n<td>招商融信天澜</td>\n<td>三墩</td>\n<td>2.81 万<br />103-133 方</td>\n<td>2021.1</td>\n<td></td>\n<td>3.1</td>\n<td>35%</td>\n<td>2023.9</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>万科前宸</td>\n<td>北部新城</td>\n<td>3.05 万</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>星创城映月璟园</td>\n<td>北部新城</td>\n<td>2.9 万<br />102-133 方</td>\n<td>2021.1</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>锦上文澜</td>\n<td>下沙沿江</td>\n<td>3 万<br />89 方</td>\n<td>2021.1</td>\n<td></td>\n<td>2.6</td>\n<td>35%</td>\n<td>2023.11</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>南部卧城</p>\n<p>萧山南站</p>\n<p>钱塘新区</p>\n<p>乔司</p>\n<p>良渚</p>\n<p>瓶窑</p>\n<p>闲林</p>\n<p>临平山北</p>\n<p>临平新城</p>\n<p>未来科技城</p>\n<p>未来科技城 2.0</p>\n<p>星桥</p>\n<p>江干</p>\n","site":{"data":{}},"excerpt":"","more":"<table>\n<thead>\n<tr>\n<th>楼盘</th>\n<th>板块</th>\n<th>房价</th>\n<th>开盘时间</th>\n<th>冻资/验资</th>\n<th>容积率</th>\n<th>绿化率</th>\n<th>交付时间</th>\n<th>物业费</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>杭语清澄<br />地暖 中央空调<br />高架直线距离 100 米</td>\n<td>崇贤</td>\n<td>2.3 万</td>\n<td>2021.3</td>\n<td>验资 50 万</td>\n<td>2.2</td>\n<td>35%</td>\n<td>2023.6.30</td>\n<td>2.75</td>\n</tr>\n<tr>\n<td>祥生湛景星合映</td>\n<td>崇贤</td>\n<td>2.3 万</td>\n<td>2021.3</td>\n<td>验资 50 万</td>\n<td>2.2</td>\n<td>35%</td>\n<td>2023.6.30</td>\n<td>2.75+0.5</td>\n</tr>\n<tr>\n<td>路劲银城澜仕里</td>\n<td>崇贤</td>\n<td>2.3 万</td>\n<td>2021.3</td>\n<td>验资 60 万</td>\n<td>2.2</td>\n<td>35%</td>\n<td>2022.9.30</td>\n<td>2.75</td>\n</tr>\n<tr>\n<td>绿地众安宸瀚里<br />自带商业街</td>\n<td>崇贤</td>\n<td>2.3 万</td>\n<td>2021.3</td>\n<td>验资 50 万</td>\n<td>2.3</td>\n<td>30%</td>\n<td>2023.4.30</td>\n<td>2.75+0.5</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>彩虹天空之城</td>\n<td>新塘</td>\n<td>2.56 万<br />63-128 方</td>\n<td>2021.3</td>\n<td>冻资 70 万</td>\n<td>2.6</td>\n<td>35%</td>\n<td>2023.8.31</td>\n<td>3.1</td>\n</tr>\n<tr>\n<td>保利欣品华庭<br />自带商业街</td>\n<td>新街</td>\n<td>2.7 万<br />96-106 方</td>\n<td>2021.1</td>\n<td></td>\n<td>2.4</td>\n<td>35.1%</td>\n<td>2023.6.30</td>\n<td>3.2</td>\n</tr>\n<tr>\n<td>保利和者时光印象府<br />自带商业街<br />厨房小</td>\n<td>新街</td>\n<td>2.5 万<br />85-105 方</td>\n<td>2021.2</td>\n<td>验资 60 万</td>\n<td>2.5</td>\n<td>35%</td>\n<td>2023.10</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>建发金辉紫璋台<br />噪音</td>\n<td>三墩</td>\n<td>3.0 万<br />95-139 方</td>\n<td>2021.1</td>\n<td></td>\n<td>3</td>\n<td>30%</td>\n<td>2020.12.30</td>\n<td></td>\n</tr>\n<tr>\n<td>招商融信天澜</td>\n<td>三墩</td>\n<td>2.81 万<br />103-133 方</td>\n<td>2021.1</td>\n<td></td>\n<td>3.1</td>\n<td>35%</td>\n<td>2023.9</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>万科前宸</td>\n<td>北部新城</td>\n<td>3.05 万</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>星创城映月璟园</td>\n<td>北部新城</td>\n<td>2.9 万<br />102-133 方</td>\n<td>2021.1</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>锦上文澜</td>\n<td>下沙沿江</td>\n<td>3 万<br />89 方</td>\n<td>2021.1</td>\n<td></td>\n<td>2.6</td>\n<td>35%</td>\n<td>2023.11</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>南部卧城</p>\n<p>萧山南站</p>\n<p>钱塘新区</p>\n<p>乔司</p>\n<p>良渚</p>\n<p>瓶窑</p>\n<p>闲林</p>\n<p>临平山北</p>\n<p>临平新城</p>\n<p>未来科技城</p>\n<p>未来科技城 2.0</p>\n<p>星桥</p>\n<p>江干</p>\n"},{"title":"Adyen SDK 接入（一）账号注册 & 准备工作","date":"2021-01-06T09:19:21.000Z","_content":"\n[TOC]\n\nAdyen SDK 与其他常见的 SDK 不太一样，API Key 与 Client Key 都是需要自己手动生成的，live 与 test 的环境区分也较为严格，想要申请 live 账号必须通过公司，这就导致个人测试时相对比较麻烦。\n\n## 准备工作\n\n### 1. 注册账号\n\nhttps://docs.adyen.com/checkout/get-started#step-1-sign-up-for-a-test-account\n\n### 2. 生成 API Key\n\nhttps://docs.adyen.com/checkout/get-started#api-key\n\n生成后 24 小时失效，保存后无法再显示。\n\n#### 1- 选择 API credentials\n\n![Adyen-API credentials](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112143926.png)\n\n#### 2- 选择 ws@Company.{YourCompany}\n\n![Adyen-API credentials2](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144047.png)\n\n#### 3- 点击 Generate New API Key\n\n![Adyen-API credentials3](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144102.png)\n\n#### 4- 复制 API Key 并保存起来\n\n#### 5- 点击 Save Generated API Key\n\n#### 6- 弹窗确认\n\n![Adyen-API credentials4](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144120.JPG)\n\n### 3. 测试一笔支付\n\nhttps://docs.adyen.com/checkout/get-started#step-3-make-a-test-payment\n\n#### 终端测试\n\n将下列代码中的 `YOUR_API_KEY` 和 `YourCompanyECOM` 替换掉并拷贝到终端运行。\n\n```\ncurl https://checkout-test.adyen.com/v66/payments \\\n-H 'x-api-key: YOUR_API_KEY' \\\n-H 'content-type: application/json' \\\n-d '{\n  \"merchantAccount\": \"YourCompanyECOM\",\n  \"reference\": \"My first Adyen test payment\",\n  \"amount\": {\n    \"value\": 1000,\n    \"currency\": \"EUR\"\n  },\n    \"paymentMethod\": {\n    \"type\": \"scheme\",\n    \"encryptedCardNumber\": \"test_4111111111111111\",\n    \"encryptedExpiryMonth\": \"test_03\",\n    \"encryptedExpiryYear\": \"test_2030\",\n    \"encryptedSecurityCode\": \"test_737\"\n  }\n}'\n```\n\n##### 1- `YOUR_API_KEY` 获取\n\n`YOUR_API_KEY` 在第二步已经获取到了。\n\n##### 2- `YourCompanyECOM` 获取\n\n###### 1- 选择 Merchant accounts\n\n![Adyen-Merchant accounts](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144205.png)\n\n###### 2- Account code 下的内容即 `YourCompanyECOM`\n\n![Adyen-Merchant accounts2](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144217.png)\n\n#### 测试结果\n\n![Adyen-Test](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144331.JPG)\n\n支付结果在后台也能看到。","source":"_posts/Adyen SDK 接入（一）账号注册 & 准备工作.md","raw":"---\ntitle: Adyen SDK 接入（一）账号注册 & 准备工作\ndate: 2021-01-06 17:19:21\ntags:\n- iOS\n- SDK\n- 支付\ncategories:\n- iOS 开发笔记\n---\n\n[TOC]\n\nAdyen SDK 与其他常见的 SDK 不太一样，API Key 与 Client Key 都是需要自己手动生成的，live 与 test 的环境区分也较为严格，想要申请 live 账号必须通过公司，这就导致个人测试时相对比较麻烦。\n\n## 准备工作\n\n### 1. 注册账号\n\nhttps://docs.adyen.com/checkout/get-started#step-1-sign-up-for-a-test-account\n\n### 2. 生成 API Key\n\nhttps://docs.adyen.com/checkout/get-started#api-key\n\n生成后 24 小时失效，保存后无法再显示。\n\n#### 1- 选择 API credentials\n\n![Adyen-API credentials](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112143926.png)\n\n#### 2- 选择 ws@Company.{YourCompany}\n\n![Adyen-API credentials2](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144047.png)\n\n#### 3- 点击 Generate New API Key\n\n![Adyen-API credentials3](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144102.png)\n\n#### 4- 复制 API Key 并保存起来\n\n#### 5- 点击 Save Generated API Key\n\n#### 6- 弹窗确认\n\n![Adyen-API credentials4](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144120.JPG)\n\n### 3. 测试一笔支付\n\nhttps://docs.adyen.com/checkout/get-started#step-3-make-a-test-payment\n\n#### 终端测试\n\n将下列代码中的 `YOUR_API_KEY` 和 `YourCompanyECOM` 替换掉并拷贝到终端运行。\n\n```\ncurl https://checkout-test.adyen.com/v66/payments \\\n-H 'x-api-key: YOUR_API_KEY' \\\n-H 'content-type: application/json' \\\n-d '{\n  \"merchantAccount\": \"YourCompanyECOM\",\n  \"reference\": \"My first Adyen test payment\",\n  \"amount\": {\n    \"value\": 1000,\n    \"currency\": \"EUR\"\n  },\n    \"paymentMethod\": {\n    \"type\": \"scheme\",\n    \"encryptedCardNumber\": \"test_4111111111111111\",\n    \"encryptedExpiryMonth\": \"test_03\",\n    \"encryptedExpiryYear\": \"test_2030\",\n    \"encryptedSecurityCode\": \"test_737\"\n  }\n}'\n```\n\n##### 1- `YOUR_API_KEY` 获取\n\n`YOUR_API_KEY` 在第二步已经获取到了。\n\n##### 2- `YourCompanyECOM` 获取\n\n###### 1- 选择 Merchant accounts\n\n![Adyen-Merchant accounts](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144205.png)\n\n###### 2- Account code 下的内容即 `YourCompanyECOM`\n\n![Adyen-Merchant accounts2](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144217.png)\n\n#### 测试结果\n\n![Adyen-Test](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144331.JPG)\n\n支付结果在后台也能看到。","slug":"Adyen SDK 接入（一）账号注册 & 准备工作","published":1,"updated":"2021-06-04T08:08:07.238Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqsw2n6y000851dxapo06css","content":"<p>[TOC]</p>\n<p>Adyen SDK 与其他常见的 SDK 不太一样，API Key 与 Client Key 都是需要自己手动生成的，live 与 test 的环境区分也较为严格，想要申请 live 账号必须通过公司，这就导致个人测试时相对比较麻烦。</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><h3 id=\"1-注册账号\"><a href=\"#1-注册账号\" class=\"headerlink\" title=\"1. 注册账号\"></a>1. 注册账号</h3><p><a href=\"https://docs.adyen.com/checkout/get-started#step-1-sign-up-for-a-test-account\">https://docs.adyen.com/checkout/get-started#step-1-sign-up-for-a-test-account</a></p>\n<h3 id=\"2-生成-API-Key\"><a href=\"#2-生成-API-Key\" class=\"headerlink\" title=\"2. 生成 API Key\"></a>2. 生成 API Key</h3><p><a href=\"https://docs.adyen.com/checkout/get-started#api-key\">https://docs.adyen.com/checkout/get-started#api-key</a></p>\n<p>生成后 24 小时失效，保存后无法再显示。</p>\n<h4 id=\"1-选择-API-credentials\"><a href=\"#1-选择-API-credentials\" class=\"headerlink\" title=\"1- 选择 API credentials\"></a>1- 选择 API credentials</h4><p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112143926.png\" alt=\"Adyen-API credentials\"></p>\n<h4 id=\"2-选择-ws-Company-YourCompany\"><a href=\"#2-选择-ws-Company-YourCompany\" class=\"headerlink\" title=\"2- 选择 ws@Company.{YourCompany}\"></a>2- 选择 ws@Company.{YourCompany}</h4><p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144047.png\" alt=\"Adyen-API credentials2\"></p>\n<h4 id=\"3-点击-Generate-New-API-Key\"><a href=\"#3-点击-Generate-New-API-Key\" class=\"headerlink\" title=\"3- 点击 Generate New API Key\"></a>3- 点击 Generate New API Key</h4><p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144102.png\" alt=\"Adyen-API credentials3\"></p>\n<h4 id=\"4-复制-API-Key-并保存起来\"><a href=\"#4-复制-API-Key-并保存起来\" class=\"headerlink\" title=\"4- 复制 API Key 并保存起来\"></a>4- 复制 API Key 并保存起来</h4><h4 id=\"5-点击-Save-Generated-API-Key\"><a href=\"#5-点击-Save-Generated-API-Key\" class=\"headerlink\" title=\"5- 点击 Save Generated API Key\"></a>5- 点击 Save Generated API Key</h4><h4 id=\"6-弹窗确认\"><a href=\"#6-弹窗确认\" class=\"headerlink\" title=\"6- 弹窗确认\"></a>6- 弹窗确认</h4><p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144120.JPG\" alt=\"Adyen-API credentials4\"></p>\n<h3 id=\"3-测试一笔支付\"><a href=\"#3-测试一笔支付\" class=\"headerlink\" title=\"3. 测试一笔支付\"></a>3. 测试一笔支付</h3><p><a href=\"https://docs.adyen.com/checkout/get-started#step-3-make-a-test-payment\">https://docs.adyen.com/checkout/get-started#step-3-make-a-test-payment</a></p>\n<h4 id=\"终端测试\"><a href=\"#终端测试\" class=\"headerlink\" title=\"终端测试\"></a>终端测试</h4><p>将下列代码中的 <code>YOUR_API_KEY</code> 和 <code>YourCompanyECOM</code> 替换掉并拷贝到终端运行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl https:&#x2F;&#x2F;checkout-test.adyen.com&#x2F;v66&#x2F;payments \\</span><br><span class=\"line\">-H &#39;x-api-key: YOUR_API_KEY&#39; \\</span><br><span class=\"line\">-H &#39;content-type: application&#x2F;json&#39; \\</span><br><span class=\"line\">-d &#39;&#123;</span><br><span class=\"line\">  &quot;merchantAccount&quot;: &quot;YourCompanyECOM&quot;,</span><br><span class=\"line\">  &quot;reference&quot;: &quot;My first Adyen test payment&quot;,</span><br><span class=\"line\">  &quot;amount&quot;: &#123;</span><br><span class=\"line\">    &quot;value&quot;: 1000,</span><br><span class=\"line\">    &quot;currency&quot;: &quot;EUR&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">    &quot;paymentMethod&quot;: &#123;</span><br><span class=\"line\">    &quot;type&quot;: &quot;scheme&quot;,</span><br><span class=\"line\">    &quot;encryptedCardNumber&quot;: &quot;test_4111111111111111&quot;,</span><br><span class=\"line\">    &quot;encryptedExpiryMonth&quot;: &quot;test_03&quot;,</span><br><span class=\"line\">    &quot;encryptedExpiryYear&quot;: &quot;test_2030&quot;,</span><br><span class=\"line\">    &quot;encryptedSecurityCode&quot;: &quot;test_737&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;&#39;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"1-YOUR-API-KEY-获取\"><a href=\"#1-YOUR-API-KEY-获取\" class=\"headerlink\" title=\"1- YOUR_API_KEY 获取\"></a>1- <code>YOUR_API_KEY</code> 获取</h5><p><code>YOUR_API_KEY</code> 在第二步已经获取到了。</p>\n<h5 id=\"2-YourCompanyECOM-获取\"><a href=\"#2-YourCompanyECOM-获取\" class=\"headerlink\" title=\"2- YourCompanyECOM 获取\"></a>2- <code>YourCompanyECOM</code> 获取</h5><h6 id=\"1-选择-Merchant-accounts\"><a href=\"#1-选择-Merchant-accounts\" class=\"headerlink\" title=\"1- 选择 Merchant accounts\"></a>1- 选择 Merchant accounts</h6><p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144205.png\" alt=\"Adyen-Merchant accounts\"></p>\n<h6 id=\"2-Account-code-下的内容即-YourCompanyECOM\"><a href=\"#2-Account-code-下的内容即-YourCompanyECOM\" class=\"headerlink\" title=\"2- Account code 下的内容即 YourCompanyECOM\"></a>2- Account code 下的内容即 <code>YourCompanyECOM</code></h6><p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144217.png\" alt=\"Adyen-Merchant accounts2\"></p>\n<h4 id=\"测试结果\"><a href=\"#测试结果\" class=\"headerlink\" title=\"测试结果\"></a>测试结果</h4><p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144331.JPG\" alt=\"Adyen-Test\"></p>\n<p>支付结果在后台也能看到。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>[TOC]</p>\n<p>Adyen SDK 与其他常见的 SDK 不太一样，API Key 与 Client Key 都是需要自己手动生成的，live 与 test 的环境区分也较为严格，想要申请 live 账号必须通过公司，这就导致个人测试时相对比较麻烦。</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><h3 id=\"1-注册账号\"><a href=\"#1-注册账号\" class=\"headerlink\" title=\"1. 注册账号\"></a>1. 注册账号</h3><p><a href=\"https://docs.adyen.com/checkout/get-started#step-1-sign-up-for-a-test-account\">https://docs.adyen.com/checkout/get-started#step-1-sign-up-for-a-test-account</a></p>\n<h3 id=\"2-生成-API-Key\"><a href=\"#2-生成-API-Key\" class=\"headerlink\" title=\"2. 生成 API Key\"></a>2. 生成 API Key</h3><p><a href=\"https://docs.adyen.com/checkout/get-started#api-key\">https://docs.adyen.com/checkout/get-started#api-key</a></p>\n<p>生成后 24 小时失效，保存后无法再显示。</p>\n<h4 id=\"1-选择-API-credentials\"><a href=\"#1-选择-API-credentials\" class=\"headerlink\" title=\"1- 选择 API credentials\"></a>1- 选择 API credentials</h4><p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112143926.png\" alt=\"Adyen-API credentials\"></p>\n<h4 id=\"2-选择-ws-Company-YourCompany\"><a href=\"#2-选择-ws-Company-YourCompany\" class=\"headerlink\" title=\"2- 选择 ws@Company.{YourCompany}\"></a>2- 选择 ws@Company.{YourCompany}</h4><p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144047.png\" alt=\"Adyen-API credentials2\"></p>\n<h4 id=\"3-点击-Generate-New-API-Key\"><a href=\"#3-点击-Generate-New-API-Key\" class=\"headerlink\" title=\"3- 点击 Generate New API Key\"></a>3- 点击 Generate New API Key</h4><p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144102.png\" alt=\"Adyen-API credentials3\"></p>\n<h4 id=\"4-复制-API-Key-并保存起来\"><a href=\"#4-复制-API-Key-并保存起来\" class=\"headerlink\" title=\"4- 复制 API Key 并保存起来\"></a>4- 复制 API Key 并保存起来</h4><h4 id=\"5-点击-Save-Generated-API-Key\"><a href=\"#5-点击-Save-Generated-API-Key\" class=\"headerlink\" title=\"5- 点击 Save Generated API Key\"></a>5- 点击 Save Generated API Key</h4><h4 id=\"6-弹窗确认\"><a href=\"#6-弹窗确认\" class=\"headerlink\" title=\"6- 弹窗确认\"></a>6- 弹窗确认</h4><p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144120.JPG\" alt=\"Adyen-API credentials4\"></p>\n<h3 id=\"3-测试一笔支付\"><a href=\"#3-测试一笔支付\" class=\"headerlink\" title=\"3. 测试一笔支付\"></a>3. 测试一笔支付</h3><p><a href=\"https://docs.adyen.com/checkout/get-started#step-3-make-a-test-payment\">https://docs.adyen.com/checkout/get-started#step-3-make-a-test-payment</a></p>\n<h4 id=\"终端测试\"><a href=\"#终端测试\" class=\"headerlink\" title=\"终端测试\"></a>终端测试</h4><p>将下列代码中的 <code>YOUR_API_KEY</code> 和 <code>YourCompanyECOM</code> 替换掉并拷贝到终端运行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl https:&#x2F;&#x2F;checkout-test.adyen.com&#x2F;v66&#x2F;payments \\</span><br><span class=\"line\">-H &#39;x-api-key: YOUR_API_KEY&#39; \\</span><br><span class=\"line\">-H &#39;content-type: application&#x2F;json&#39; \\</span><br><span class=\"line\">-d &#39;&#123;</span><br><span class=\"line\">  &quot;merchantAccount&quot;: &quot;YourCompanyECOM&quot;,</span><br><span class=\"line\">  &quot;reference&quot;: &quot;My first Adyen test payment&quot;,</span><br><span class=\"line\">  &quot;amount&quot;: &#123;</span><br><span class=\"line\">    &quot;value&quot;: 1000,</span><br><span class=\"line\">    &quot;currency&quot;: &quot;EUR&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">    &quot;paymentMethod&quot;: &#123;</span><br><span class=\"line\">    &quot;type&quot;: &quot;scheme&quot;,</span><br><span class=\"line\">    &quot;encryptedCardNumber&quot;: &quot;test_4111111111111111&quot;,</span><br><span class=\"line\">    &quot;encryptedExpiryMonth&quot;: &quot;test_03&quot;,</span><br><span class=\"line\">    &quot;encryptedExpiryYear&quot;: &quot;test_2030&quot;,</span><br><span class=\"line\">    &quot;encryptedSecurityCode&quot;: &quot;test_737&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;&#39;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"1-YOUR-API-KEY-获取\"><a href=\"#1-YOUR-API-KEY-获取\" class=\"headerlink\" title=\"1- YOUR_API_KEY 获取\"></a>1- <code>YOUR_API_KEY</code> 获取</h5><p><code>YOUR_API_KEY</code> 在第二步已经获取到了。</p>\n<h5 id=\"2-YourCompanyECOM-获取\"><a href=\"#2-YourCompanyECOM-获取\" class=\"headerlink\" title=\"2- YourCompanyECOM 获取\"></a>2- <code>YourCompanyECOM</code> 获取</h5><h6 id=\"1-选择-Merchant-accounts\"><a href=\"#1-选择-Merchant-accounts\" class=\"headerlink\" title=\"1- 选择 Merchant accounts\"></a>1- 选择 Merchant accounts</h6><p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144205.png\" alt=\"Adyen-Merchant accounts\"></p>\n<h6 id=\"2-Account-code-下的内容即-YourCompanyECOM\"><a href=\"#2-Account-code-下的内容即-YourCompanyECOM\" class=\"headerlink\" title=\"2- Account code 下的内容即 YourCompanyECOM\"></a>2- Account code 下的内容即 <code>YourCompanyECOM</code></h6><p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144217.png\" alt=\"Adyen-Merchant accounts2\"></p>\n<h4 id=\"测试结果\"><a href=\"#测试结果\" class=\"headerlink\" title=\"测试结果\"></a>测试结果</h4><p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144331.JPG\" alt=\"Adyen-Test\"></p>\n<p>支付结果在后台也能看到。</p>\n"},{"title":"Adyen SDK 接入（二）","date":"2021-01-06T09:19:21.000Z","_content":"\n这是一份集成清单列表，里面罗列了集成所需的步骤。\n\nhttps://docs.adyen.com/checkout/integration-checklist\n\n客户端一直无法显示 Sofort 这一项，开始我以为是 demo 没有实现，后来发现是国家选择的问题，国家默认选择了荷兰，恰巧 Sofort 不支持荷兰。\n","source":"_posts/Adyen SDK 接入（二）.md","raw":"---\ntitle: Adyen SDK 接入（二）\ndate: 2021-01-06 17:19:21\ntags:\n  - iOS\n  - SDK\n  - 支付\ncategories:\n  - iOS 开发笔记\n---\n\n这是一份集成清单列表，里面罗列了集成所需的步骤。\n\nhttps://docs.adyen.com/checkout/integration-checklist\n\n客户端一直无法显示 Sofort 这一项，开始我以为是 demo 没有实现，后来发现是国家选择的问题，国家默认选择了荷兰，恰巧 Sofort 不支持荷兰。\n","slug":"Adyen SDK 接入（二）","published":1,"updated":"2021-06-04T08:08:07.239Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqsw2n71000c51dx23u15imh","content":"<p>这是一份集成清单列表，里面罗列了集成所需的步骤。</p>\n<p><a href=\"https://docs.adyen.com/checkout/integration-checklist\">https://docs.adyen.com/checkout/integration-checklist</a></p>\n<p>客户端一直无法显示 Sofort 这一项，开始我以为是 demo 没有实现，后来发现是国家选择的问题，国家默认选择了荷兰，恰巧 Sofort 不支持荷兰。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这是一份集成清单列表，里面罗列了集成所需的步骤。</p>\n<p><a href=\"https://docs.adyen.com/checkout/integration-checklist\">https://docs.adyen.com/checkout/integration-checklist</a></p>\n<p>客户端一直无法显示 Sofort 这一项，开始我以为是 demo 没有实现，后来发现是国家选择的问题，国家默认选择了荷兰，恰巧 Sofort 不支持荷兰。</p>\n"},{"title":"Bazel 构建步骤","_content":"\n1. 根目录创建 `WORKSPACE` 文件，填写。\n2. 项目目录创建 `BUILD` 文件，填写。\n3. 根目录运行 `bazel build //xxx:xxx` 编译项目。\n4. 使用 `Tusli` 创建 `Xcode` 工程。 https://tulsi.bazel.build/docs/gettingstarted.html\n5. 自动打开，运行。\n\n","source":"_posts/Bazel 构建步骤.md","raw":"---\ntitle: Bazel 构建步骤\ntags:\n- iOS\n- Bazel\ncategories:\n- 构建工具\n---\n\n1. 根目录创建 `WORKSPACE` 文件，填写。\n2. 项目目录创建 `BUILD` 文件，填写。\n3. 根目录运行 `bazel build //xxx:xxx` 编译项目。\n4. 使用 `Tusli` 创建 `Xcode` 工程。 https://tulsi.bazel.build/docs/gettingstarted.html\n5. 自动打开，运行。\n\n","slug":"Bazel 构建步骤","published":1,"date":"2021-06-04T08:08:07.239Z","updated":"2021-07-07T03:21:15.542Z","_id":"ckqsw2n72000d51dx9zhy54sw","comments":1,"layout":"post","photos":[],"link":"","content":"<ol>\n<li>根目录创建 <code>WORKSPACE</code> 文件，填写。</li>\n<li>项目目录创建 <code>BUILD</code> 文件，填写。</li>\n<li>根目录运行 <code>bazel build //xxx:xxx</code> 编译项目。</li>\n<li>使用 <code>Tusli</code> 创建 <code>Xcode</code> 工程。 <a href=\"https://tulsi.bazel.build/docs/gettingstarted.html\">https://tulsi.bazel.build/docs/gettingstarted.html</a></li>\n<li>自动打开，运行。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>根目录创建 <code>WORKSPACE</code> 文件，填写。</li>\n<li>项目目录创建 <code>BUILD</code> 文件，填写。</li>\n<li>根目录运行 <code>bazel build //xxx:xxx</code> 编译项目。</li>\n<li>使用 <code>Tusli</code> 创建 <code>Xcode</code> 工程。 <a href=\"https://tulsi.bazel.build/docs/gettingstarted.html\">https://tulsi.bazel.build/docs/gettingstarted.html</a></li>\n<li>自动打开，运行。</li>\n</ol>\n"},{"title":"Bazel 问题","_content":"\n### Proxy address 127.0.0.1:xxxx is not a valid URL\n\n```\nAn error occurred during the fetch of repository 'build_bazel_rules_apple':\n   Traceback (most recent call last):\n\tFile \"/private/var/tmp/_bazel_yanqizhao/041075cb14947c9864d661ff83fcfc83/external/bazel_tools/tools/build_defs/repo/http.bzl\", line 111, column 45, in _http_archive_impl\n\t\tdownload_info = ctx.download_and_extract(\nError in download_and_extract: java.io.IOException: Error downloading [https://github.com/bazelbuild/rules_apple/archive/762e3270c1b45cdf6755ad494ce4069fc9243b9d.tar.gz] to /private/var/tmp/_bazel_yanqizhao/041075cb14947c9864d661ff83fcfc83/external/build_bazel_rules_apple/temp6297134644689352116/762e3270c1b45cdf6755ad494ce4069fc9243b9d.tar.gz: Proxy address 127.0.0.1:7890 is not a valid URL\n```\n\n修改代理为：https://127.0.0.1:xxxx\n\n执行命令：`bazel clean --expunge`\n\n参考：https://stackoverflow.com/a/39173790/9049347\n\n\n\n### Error in int: invalid base-10 literal: \"0-homebrew\"\n\n```\nTraceback (most recent call last):\n\tFile \"/Users/yanqizhao/examples/tutorial/WORKSPACE\", line 46, column 28, in <toplevel>\n\t\tjava_appengine_repositories()\n\tFile \"/private/var/tmp/_bazel_yanqizhao/041075cb14947c9864d661ff83fcfc83/external/io_bazel_rules_appengine/appengine/java_appengine.bzl\", line 321, column 35, in java_appengine_repositories\n\t\tbazel_version = tuple([int(n) for n in native.bazel_version.split(\".\")])\nError in int: invalid base-10 literal: \"0-homebrew\"\n```\n\n修改 `appengine` 使用的 `commit`\n\n参考：https://github.com/bazelbuild/rules_appengine/issues/122","source":"_posts/Bazel 问题.md","raw":"---\ntitle: Bazel 问题\ntags:\n- iOS\n- Bazel\ncategories:\n- 构建工具\n---\n\n### Proxy address 127.0.0.1:xxxx is not a valid URL\n\n```\nAn error occurred during the fetch of repository 'build_bazel_rules_apple':\n   Traceback (most recent call last):\n\tFile \"/private/var/tmp/_bazel_yanqizhao/041075cb14947c9864d661ff83fcfc83/external/bazel_tools/tools/build_defs/repo/http.bzl\", line 111, column 45, in _http_archive_impl\n\t\tdownload_info = ctx.download_and_extract(\nError in download_and_extract: java.io.IOException: Error downloading [https://github.com/bazelbuild/rules_apple/archive/762e3270c1b45cdf6755ad494ce4069fc9243b9d.tar.gz] to /private/var/tmp/_bazel_yanqizhao/041075cb14947c9864d661ff83fcfc83/external/build_bazel_rules_apple/temp6297134644689352116/762e3270c1b45cdf6755ad494ce4069fc9243b9d.tar.gz: Proxy address 127.0.0.1:7890 is not a valid URL\n```\n\n修改代理为：https://127.0.0.1:xxxx\n\n执行命令：`bazel clean --expunge`\n\n参考：https://stackoverflow.com/a/39173790/9049347\n\n\n\n### Error in int: invalid base-10 literal: \"0-homebrew\"\n\n```\nTraceback (most recent call last):\n\tFile \"/Users/yanqizhao/examples/tutorial/WORKSPACE\", line 46, column 28, in <toplevel>\n\t\tjava_appengine_repositories()\n\tFile \"/private/var/tmp/_bazel_yanqizhao/041075cb14947c9864d661ff83fcfc83/external/io_bazel_rules_appengine/appengine/java_appengine.bzl\", line 321, column 35, in java_appengine_repositories\n\t\tbazel_version = tuple([int(n) for n in native.bazel_version.split(\".\")])\nError in int: invalid base-10 literal: \"0-homebrew\"\n```\n\n修改 `appengine` 使用的 `commit`\n\n参考：https://github.com/bazelbuild/rules_appengine/issues/122","slug":"Bazel 问题","published":1,"date":"2021-06-04T08:08:07.240Z","updated":"2021-07-07T03:22:30.496Z","_id":"ckqsw2n74000i51dx8ody69rg","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"Proxy-address-127-0-0-1-xxxx-is-not-a-valid-URL\"><a href=\"#Proxy-address-127-0-0-1-xxxx-is-not-a-valid-URL\" class=\"headerlink\" title=\"Proxy address 127.0.0.1:xxxx is not a valid URL\"></a>Proxy address 127.0.0.1:xxxx is not a valid URL</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">An error occurred during the fetch of repository &#39;build_bazel_rules_apple&#39;:</span><br><span class=\"line\">   Traceback (most recent call last):</span><br><span class=\"line\">\tFile &quot;&#x2F;private&#x2F;var&#x2F;tmp&#x2F;_bazel_yanqizhao&#x2F;041075cb14947c9864d661ff83fcfc83&#x2F;external&#x2F;bazel_tools&#x2F;tools&#x2F;build_defs&#x2F;repo&#x2F;http.bzl&quot;, line 111, column 45, in _http_archive_impl</span><br><span class=\"line\">\t\tdownload_info &#x3D; ctx.download_and_extract(</span><br><span class=\"line\">Error in download_and_extract: java.io.IOException: Error downloading [https:&#x2F;&#x2F;github.com&#x2F;bazelbuild&#x2F;rules_apple&#x2F;archive&#x2F;762e3270c1b45cdf6755ad494ce4069fc9243b9d.tar.gz] to &#x2F;private&#x2F;var&#x2F;tmp&#x2F;_bazel_yanqizhao&#x2F;041075cb14947c9864d661ff83fcfc83&#x2F;external&#x2F;build_bazel_rules_apple&#x2F;temp6297134644689352116&#x2F;762e3270c1b45cdf6755ad494ce4069fc9243b9d.tar.gz: Proxy address 127.0.0.1:7890 is not a valid URL</span><br></pre></td></tr></table></figure>\n\n<p>修改代理为：<a href=\"https://127.0.0.1:xxxx\">https://127.0.0.1:xxxx</a></p>\n<p>执行命令：<code>bazel clean --expunge</code></p>\n<p>参考：<a href=\"https://stackoverflow.com/a/39173790/9049347\">https://stackoverflow.com/a/39173790/9049347</a></p>\n<h3 id=\"Error-in-int-invalid-base-10-literal-“0-homebrew”\"><a href=\"#Error-in-int-invalid-base-10-literal-“0-homebrew”\" class=\"headerlink\" title=\"Error in int: invalid base-10 literal: “0-homebrew”\"></a>Error in int: invalid base-10 literal: “0-homebrew”</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">\tFile &quot;&#x2F;Users&#x2F;yanqizhao&#x2F;examples&#x2F;tutorial&#x2F;WORKSPACE&quot;, line 46, column 28, in &lt;toplevel&gt;</span><br><span class=\"line\">\t\tjava_appengine_repositories()</span><br><span class=\"line\">\tFile &quot;&#x2F;private&#x2F;var&#x2F;tmp&#x2F;_bazel_yanqizhao&#x2F;041075cb14947c9864d661ff83fcfc83&#x2F;external&#x2F;io_bazel_rules_appengine&#x2F;appengine&#x2F;java_appengine.bzl&quot;, line 321, column 35, in java_appengine_repositories</span><br><span class=\"line\">\t\tbazel_version &#x3D; tuple([int(n) for n in native.bazel_version.split(&quot;.&quot;)])</span><br><span class=\"line\">Error in int: invalid base-10 literal: &quot;0-homebrew&quot;</span><br></pre></td></tr></table></figure>\n\n<p>修改 <code>appengine</code> 使用的 <code>commit</code></p>\n<p>参考：<a href=\"https://github.com/bazelbuild/rules_appengine/issues/122\">https://github.com/bazelbuild/rules_appengine/issues/122</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Proxy-address-127-0-0-1-xxxx-is-not-a-valid-URL\"><a href=\"#Proxy-address-127-0-0-1-xxxx-is-not-a-valid-URL\" class=\"headerlink\" title=\"Proxy address 127.0.0.1:xxxx is not a valid URL\"></a>Proxy address 127.0.0.1:xxxx is not a valid URL</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">An error occurred during the fetch of repository &#39;build_bazel_rules_apple&#39;:</span><br><span class=\"line\">   Traceback (most recent call last):</span><br><span class=\"line\">\tFile &quot;&#x2F;private&#x2F;var&#x2F;tmp&#x2F;_bazel_yanqizhao&#x2F;041075cb14947c9864d661ff83fcfc83&#x2F;external&#x2F;bazel_tools&#x2F;tools&#x2F;build_defs&#x2F;repo&#x2F;http.bzl&quot;, line 111, column 45, in _http_archive_impl</span><br><span class=\"line\">\t\tdownload_info &#x3D; ctx.download_and_extract(</span><br><span class=\"line\">Error in download_and_extract: java.io.IOException: Error downloading [https:&#x2F;&#x2F;github.com&#x2F;bazelbuild&#x2F;rules_apple&#x2F;archive&#x2F;762e3270c1b45cdf6755ad494ce4069fc9243b9d.tar.gz] to &#x2F;private&#x2F;var&#x2F;tmp&#x2F;_bazel_yanqizhao&#x2F;041075cb14947c9864d661ff83fcfc83&#x2F;external&#x2F;build_bazel_rules_apple&#x2F;temp6297134644689352116&#x2F;762e3270c1b45cdf6755ad494ce4069fc9243b9d.tar.gz: Proxy address 127.0.0.1:7890 is not a valid URL</span><br></pre></td></tr></table></figure>\n\n<p>修改代理为：<a href=\"https://127.0.0.1:xxxx\">https://127.0.0.1:xxxx</a></p>\n<p>执行命令：<code>bazel clean --expunge</code></p>\n<p>参考：<a href=\"https://stackoverflow.com/a/39173790/9049347\">https://stackoverflow.com/a/39173790/9049347</a></p>\n<h3 id=\"Error-in-int-invalid-base-10-literal-“0-homebrew”\"><a href=\"#Error-in-int-invalid-base-10-literal-“0-homebrew”\" class=\"headerlink\" title=\"Error in int: invalid base-10 literal: “0-homebrew”\"></a>Error in int: invalid base-10 literal: “0-homebrew”</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">\tFile &quot;&#x2F;Users&#x2F;yanqizhao&#x2F;examples&#x2F;tutorial&#x2F;WORKSPACE&quot;, line 46, column 28, in &lt;toplevel&gt;</span><br><span class=\"line\">\t\tjava_appengine_repositories()</span><br><span class=\"line\">\tFile &quot;&#x2F;private&#x2F;var&#x2F;tmp&#x2F;_bazel_yanqizhao&#x2F;041075cb14947c9864d661ff83fcfc83&#x2F;external&#x2F;io_bazel_rules_appengine&#x2F;appengine&#x2F;java_appengine.bzl&quot;, line 321, column 35, in java_appengine_repositories</span><br><span class=\"line\">\t\tbazel_version &#x3D; tuple([int(n) for n in native.bazel_version.split(&quot;.&quot;)])</span><br><span class=\"line\">Error in int: invalid base-10 literal: &quot;0-homebrew&quot;</span><br></pre></td></tr></table></figure>\n\n<p>修改 <code>appengine</code> 使用的 <code>commit</code></p>\n<p>参考：<a href=\"https://github.com/bazelbuild/rules_appengine/issues/122\">https://github.com/bazelbuild/rules_appengine/issues/122</a></p>\n"},{"title":"Block 写法备忘","_content":"\n\n\nhttps://xtcmoons.github.io/ios/2018/10/29/OC-Block/\n\n","source":"_posts/Block 写法备忘.md","raw":"---\ntitle: Block 写法备忘\ntags:\n- iOS\n- Block\ncategories:\n- iOS 开发笔记\n---\n\n\n\nhttps://xtcmoons.github.io/ios/2018/10/29/OC-Block/\n\n","slug":"Block 写法备忘","published":1,"date":"2021-07-07T03:24:24.192Z","updated":"2021-08-13T06:23:10.771Z","_id":"ckqsw2n75000j51dx94l495st","comments":1,"layout":"post","photos":[],"link":"","content":"<p><a href=\"https://xtcmoons.github.io/ios/2018/10/29/OC-Block/\">https://xtcmoons.github.io/ios/2018/10/29/OC-Block/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://xtcmoons.github.io/ios/2018/10/29/OC-Block/\">https://xtcmoons.github.io/ios/2018/10/29/OC-Block/</a></p>\n"},{"title":"JavaScript 学习资料","date":"2020-12-23T09:19:21.000Z","_content":"\n\n\n## 3 小时入门教程(基础语法)\n\nhttps://www.youtube.com/watch?v=PkZNo7MFNFg\n\n\n\n## 数值表示\n\nJavaScript 中整数也是由 64 位双精度浮点数表示的，下文详细介绍了 IEEE754 64 位双精度浮点数的表示范围与精度范围。\n\nhttps://www.boatsky.com/blog/26","source":"_posts/JavaScript 学习资料.md","raw":"---\ntitle: JavaScript 学习资料\ndate: 2020-12-23 17:19:21\ntags:\n- 学习资料\ncategories:\n- JavaScript\n---\n\n\n\n## 3 小时入门教程(基础语法)\n\nhttps://www.youtube.com/watch?v=PkZNo7MFNFg\n\n\n\n## 数值表示\n\nJavaScript 中整数也是由 64 位双精度浮点数表示的，下文详细介绍了 IEEE754 64 位双精度浮点数的表示范围与精度范围。\n\nhttps://www.boatsky.com/blog/26","slug":"JavaScript 学习资料","published":1,"updated":"2021-06-04T08:08:07.242Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqsw2n77000o51dx661vd36v","content":"<h2 id=\"3-小时入门教程-基础语法\"><a href=\"#3-小时入门教程-基础语法\" class=\"headerlink\" title=\"3 小时入门教程(基础语法)\"></a>3 小时入门教程(基础语法)</h2><p><a href=\"https://www.youtube.com/watch?v=PkZNo7MFNFg\">https://www.youtube.com/watch?v=PkZNo7MFNFg</a></p>\n<h2 id=\"数值表示\"><a href=\"#数值表示\" class=\"headerlink\" title=\"数值表示\"></a>数值表示</h2><p>JavaScript 中整数也是由 64 位双精度浮点数表示的，下文详细介绍了 IEEE754 64 位双精度浮点数的表示范围与精度范围。</p>\n<p><a href=\"https://www.boatsky.com/blog/26\">https://www.boatsky.com/blog/26</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"3-小时入门教程-基础语法\"><a href=\"#3-小时入门教程-基础语法\" class=\"headerlink\" title=\"3 小时入门教程(基础语法)\"></a>3 小时入门教程(基础语法)</h2><p><a href=\"https://www.youtube.com/watch?v=PkZNo7MFNFg\">https://www.youtube.com/watch?v=PkZNo7MFNFg</a></p>\n<h2 id=\"数值表示\"><a href=\"#数值表示\" class=\"headerlink\" title=\"数值表示\"></a>数值表示</h2><p>JavaScript 中整数也是由 64 位双精度浮点数表示的，下文详细介绍了 IEEE754 64 位双精度浮点数的表示范围与精度范围。</p>\n<p><a href=\"https://www.boatsky.com/blog/26\">https://www.boatsky.com/blog/26</a></p>\n"},{"title":"JavaScript 语法","date":"2020-12-22T09:19:21.000Z","_content":"\n\n\n## var let const\n\n> let 不能声明多次\n\n\n\n```javascript\nvar i = \"global\";\n\nfunction test () {\n  var i = \"function\";\n  console.log(i);\n}\n\ntest();\nconsole.log(i);\n\n/*\nconsole log:\n\"function\"\n\"global\"\n*/\n```\n\n\n\n```javascript\nvar i = \"global\";\n\nfunction test () {\n  i = \"function\";\n  console.log(i);\n}\n\ntest();\nconsole.log(i);\n\n/*\nconsole log:\n\"function\"\n\"function\"\n*/\n```\n\n\n\n\n\n```javascript\nfunction test () {\n  i = \"function\";\n  console.log(i);\n}\n\ntest();\nconsole.log(i);\n\n/*\nconsole log:\n\"function\"\n\"function\"\n*/\n```\n\n\n\n\n\n```javascript\nlet i = \"global\";\nfunction test () {\n  let i = \"function\";\n  console.log(i);\n}\n\ntest();\nconsole.log(i);\n\n/*\nconsole log:\n\"function\"\n\"global\"\n*/\n```\n\n\n\n\n\n```javascript\nlet i = \"global\";\nfunction test () {\n  i = \"function\";\n  console.log(i);\n}\n\ntest();\nconsole.log(i);\n\n/*\nconsole log:\n\"function\"\n\"function\"\n*/\n```\n\n\n\n\n\n```javascript\nfunction test () {\n  let i = \"function\";\n  console.log(i);\n}\n\ntest();\nconsole.log(i);\n\n/*\nconsole log:\nUncaught ReferenceError: i is not defined \n*/\n```\n\n\n\n\n\n### Object.freeze()\n\n## undefined null\n\n## ===\n\n## !==\n\n## Array\n\n### push pop\n\n### shift unshift\n\n## Math.random()\n\n## Math.floor()\n\n## parseInt()\n\n字符串 -> 数值\n\n## Arrow Function\n\n匿名函数\n\n## Rest Operator\n\n参数封装为数组\n\n## Spread Operator\n\n深拷贝\n\n## use strict\n\n## import requires\n\n## import * as … from …\n\n## export default\n\n默认导出，引用时无需使用 `{}`\n\n## import subtract from …\n\n","source":"_posts/JavaScript 语法.md","raw":"---\ntitle: JavaScript 语法\ndate: 2020-12-22 17:19:21\ntags:\n- 编程语言\n- 语法基础\ncategories:\n- JavaScript\n---\n\n\n\n## var let const\n\n> let 不能声明多次\n\n\n\n```javascript\nvar i = \"global\";\n\nfunction test () {\n  var i = \"function\";\n  console.log(i);\n}\n\ntest();\nconsole.log(i);\n\n/*\nconsole log:\n\"function\"\n\"global\"\n*/\n```\n\n\n\n```javascript\nvar i = \"global\";\n\nfunction test () {\n  i = \"function\";\n  console.log(i);\n}\n\ntest();\nconsole.log(i);\n\n/*\nconsole log:\n\"function\"\n\"function\"\n*/\n```\n\n\n\n\n\n```javascript\nfunction test () {\n  i = \"function\";\n  console.log(i);\n}\n\ntest();\nconsole.log(i);\n\n/*\nconsole log:\n\"function\"\n\"function\"\n*/\n```\n\n\n\n\n\n```javascript\nlet i = \"global\";\nfunction test () {\n  let i = \"function\";\n  console.log(i);\n}\n\ntest();\nconsole.log(i);\n\n/*\nconsole log:\n\"function\"\n\"global\"\n*/\n```\n\n\n\n\n\n```javascript\nlet i = \"global\";\nfunction test () {\n  i = \"function\";\n  console.log(i);\n}\n\ntest();\nconsole.log(i);\n\n/*\nconsole log:\n\"function\"\n\"function\"\n*/\n```\n\n\n\n\n\n```javascript\nfunction test () {\n  let i = \"function\";\n  console.log(i);\n}\n\ntest();\nconsole.log(i);\n\n/*\nconsole log:\nUncaught ReferenceError: i is not defined \n*/\n```\n\n\n\n\n\n### Object.freeze()\n\n## undefined null\n\n## ===\n\n## !==\n\n## Array\n\n### push pop\n\n### shift unshift\n\n## Math.random()\n\n## Math.floor()\n\n## parseInt()\n\n字符串 -> 数值\n\n## Arrow Function\n\n匿名函数\n\n## Rest Operator\n\n参数封装为数组\n\n## Spread Operator\n\n深拷贝\n\n## use strict\n\n## import requires\n\n## import * as … from …\n\n## export default\n\n默认导出，引用时无需使用 `{}`\n\n## import subtract from …\n\n","slug":"JavaScript 语法","published":1,"updated":"2021-06-04T08:08:07.242Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqsw2n78000p51dx14yz3tm5","content":"<h2 id=\"var-let-const\"><a href=\"#var-let-const\" class=\"headerlink\" title=\"var let const\"></a>var let const</h2><blockquote>\n<p>let 不能声明多次</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> i = <span class=\"string\">&quot;global&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i = <span class=\"string\">&quot;function&quot;</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">console log:</span></span><br><span class=\"line\"><span class=\"comment\">&quot;function&quot;</span></span><br><span class=\"line\"><span class=\"comment\">&quot;global&quot;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> i = <span class=\"string\">&quot;global&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  i = <span class=\"string\">&quot;function&quot;</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">console log:</span></span><br><span class=\"line\"><span class=\"comment\">&quot;function&quot;</span></span><br><span class=\"line\"><span class=\"comment\">&quot;function&quot;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  i = <span class=\"string\">&quot;function&quot;</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">console log:</span></span><br><span class=\"line\"><span class=\"comment\">&quot;function&quot;</span></span><br><span class=\"line\"><span class=\"comment\">&quot;function&quot;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> i = <span class=\"string\">&quot;global&quot;</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"string\">&quot;function&quot;</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">console log:</span></span><br><span class=\"line\"><span class=\"comment\">&quot;function&quot;</span></span><br><span class=\"line\"><span class=\"comment\">&quot;global&quot;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> i = <span class=\"string\">&quot;global&quot;</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  i = <span class=\"string\">&quot;function&quot;</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">console log:</span></span><br><span class=\"line\"><span class=\"comment\">&quot;function&quot;</span></span><br><span class=\"line\"><span class=\"comment\">&quot;function&quot;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"string\">&quot;function&quot;</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">console log:</span></span><br><span class=\"line\"><span class=\"comment\">Uncaught ReferenceError: i is not defined </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"Object-freeze\"><a href=\"#Object-freeze\" class=\"headerlink\" title=\"Object.freeze()\"></a>Object.freeze()</h3><h2 id=\"undefined-null\"><a href=\"#undefined-null\" class=\"headerlink\" title=\"undefined null\"></a>undefined null</h2><h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"===\"></a>===</h2><h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"!==\"></a>!==</h2><h2 id=\"Array\"><a href=\"#Array\" class=\"headerlink\" title=\"Array\"></a>Array</h2><h3 id=\"push-pop\"><a href=\"#push-pop\" class=\"headerlink\" title=\"push pop\"></a>push pop</h3><h3 id=\"shift-unshift\"><a href=\"#shift-unshift\" class=\"headerlink\" title=\"shift unshift\"></a>shift unshift</h3><h2 id=\"Math-random\"><a href=\"#Math-random\" class=\"headerlink\" title=\"Math.random()\"></a>Math.random()</h2><h2 id=\"Math-floor\"><a href=\"#Math-floor\" class=\"headerlink\" title=\"Math.floor()\"></a>Math.floor()</h2><h2 id=\"parseInt\"><a href=\"#parseInt\" class=\"headerlink\" title=\"parseInt()\"></a>parseInt()</h2><p>字符串 -&gt; 数值</p>\n<h2 id=\"Arrow-Function\"><a href=\"#Arrow-Function\" class=\"headerlink\" title=\"Arrow Function\"></a>Arrow Function</h2><p>匿名函数</p>\n<h2 id=\"Rest-Operator\"><a href=\"#Rest-Operator\" class=\"headerlink\" title=\"Rest Operator\"></a>Rest Operator</h2><p>参数封装为数组</p>\n<h2 id=\"Spread-Operator\"><a href=\"#Spread-Operator\" class=\"headerlink\" title=\"Spread Operator\"></a>Spread Operator</h2><p>深拷贝</p>\n<h2 id=\"use-strict\"><a href=\"#use-strict\" class=\"headerlink\" title=\"use strict\"></a>use strict</h2><h2 id=\"import-requires\"><a href=\"#import-requires\" class=\"headerlink\" title=\"import requires\"></a>import requires</h2><h2 id=\"import-as-…-from-…\"><a href=\"#import-as-…-from-…\" class=\"headerlink\" title=\"import * as … from …\"></a>import * as … from …</h2><h2 id=\"export-default\"><a href=\"#export-default\" class=\"headerlink\" title=\"export default\"></a>export default</h2><p>默认导出，引用时无需使用 <code>&#123;&#125;</code></p>\n<h2 id=\"import-subtract-from-…\"><a href=\"#import-subtract-from-…\" class=\"headerlink\" title=\"import subtract from …\"></a>import subtract from …</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"var-let-const\"><a href=\"#var-let-const\" class=\"headerlink\" title=\"var let const\"></a>var let const</h2><blockquote>\n<p>let 不能声明多次</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> i = <span class=\"string\">&quot;global&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i = <span class=\"string\">&quot;function&quot;</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">console log:</span></span><br><span class=\"line\"><span class=\"comment\">&quot;function&quot;</span></span><br><span class=\"line\"><span class=\"comment\">&quot;global&quot;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> i = <span class=\"string\">&quot;global&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  i = <span class=\"string\">&quot;function&quot;</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">console log:</span></span><br><span class=\"line\"><span class=\"comment\">&quot;function&quot;</span></span><br><span class=\"line\"><span class=\"comment\">&quot;function&quot;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  i = <span class=\"string\">&quot;function&quot;</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">console log:</span></span><br><span class=\"line\"><span class=\"comment\">&quot;function&quot;</span></span><br><span class=\"line\"><span class=\"comment\">&quot;function&quot;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> i = <span class=\"string\">&quot;global&quot;</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"string\">&quot;function&quot;</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">console log:</span></span><br><span class=\"line\"><span class=\"comment\">&quot;function&quot;</span></span><br><span class=\"line\"><span class=\"comment\">&quot;global&quot;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> i = <span class=\"string\">&quot;global&quot;</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  i = <span class=\"string\">&quot;function&quot;</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">console log:</span></span><br><span class=\"line\"><span class=\"comment\">&quot;function&quot;</span></span><br><span class=\"line\"><span class=\"comment\">&quot;function&quot;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"string\">&quot;function&quot;</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">console log:</span></span><br><span class=\"line\"><span class=\"comment\">Uncaught ReferenceError: i is not defined </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"Object-freeze\"><a href=\"#Object-freeze\" class=\"headerlink\" title=\"Object.freeze()\"></a>Object.freeze()</h3><h2 id=\"undefined-null\"><a href=\"#undefined-null\" class=\"headerlink\" title=\"undefined null\"></a>undefined null</h2><h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"===\"></a>===</h2><h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"!==\"></a>!==</h2><h2 id=\"Array\"><a href=\"#Array\" class=\"headerlink\" title=\"Array\"></a>Array</h2><h3 id=\"push-pop\"><a href=\"#push-pop\" class=\"headerlink\" title=\"push pop\"></a>push pop</h3><h3 id=\"shift-unshift\"><a href=\"#shift-unshift\" class=\"headerlink\" title=\"shift unshift\"></a>shift unshift</h3><h2 id=\"Math-random\"><a href=\"#Math-random\" class=\"headerlink\" title=\"Math.random()\"></a>Math.random()</h2><h2 id=\"Math-floor\"><a href=\"#Math-floor\" class=\"headerlink\" title=\"Math.floor()\"></a>Math.floor()</h2><h2 id=\"parseInt\"><a href=\"#parseInt\" class=\"headerlink\" title=\"parseInt()\"></a>parseInt()</h2><p>字符串 -&gt; 数值</p>\n<h2 id=\"Arrow-Function\"><a href=\"#Arrow-Function\" class=\"headerlink\" title=\"Arrow Function\"></a>Arrow Function</h2><p>匿名函数</p>\n<h2 id=\"Rest-Operator\"><a href=\"#Rest-Operator\" class=\"headerlink\" title=\"Rest Operator\"></a>Rest Operator</h2><p>参数封装为数组</p>\n<h2 id=\"Spread-Operator\"><a href=\"#Spread-Operator\" class=\"headerlink\" title=\"Spread Operator\"></a>Spread Operator</h2><p>深拷贝</p>\n<h2 id=\"use-strict\"><a href=\"#use-strict\" class=\"headerlink\" title=\"use strict\"></a>use strict</h2><h2 id=\"import-requires\"><a href=\"#import-requires\" class=\"headerlink\" title=\"import requires\"></a>import requires</h2><h2 id=\"import-as-…-from-…\"><a href=\"#import-as-…-from-…\" class=\"headerlink\" title=\"import * as … from …\"></a>import * as … from …</h2><h2 id=\"export-default\"><a href=\"#export-default\" class=\"headerlink\" title=\"export default\"></a>export default</h2><p>默认导出，引用时无需使用 <code>&#123;&#125;</code></p>\n<h2 id=\"import-subtract-from-…\"><a href=\"#import-subtract-from-…\" class=\"headerlink\" title=\"import subtract from …\"></a>import subtract from …</h2>"},{"title":"LeetCode 资料","date":"2021-01-25T15:59:05.000Z","_content":"\n\n\n[TOC]\n\n## 视频讲解\n\n### JS 版 老毕\n\nhttps://space.bilibili.com/455848380/\n\n\n\n### C++ 版 花花酱\n\nhttps://space.bilibili.com/9880352/\n\nhttps://www.youtube.com/channel/UC5xDNEcvb1vgw3lE21Ack2Q\n\n\n\n### Java 版\n\nhttps://space.bilibili.com/59546029/\n\n\n\n### Python 版\n\nhttps://www.youtube.com/channel/UCRCqgMdsAHK3yfvW4en6JpA\n\n\n\n### C++ 版\n\nhttps://www.youtube.com/channel/UCE35PnPX7EZi8nHSegjMn6Q/videos\n\n\n\n## GitHub 仓库代码\n\n### Swift 版 故胤道长\n\nhttps://github.com/soapyigu/LeetCode-Swift\n\n\n\n### C++ Python\n\nhttps://github.com/pezy/LeetCode\n\n\n\n### JS\n\nhttps://github.com/MisterBooo/LeetCodeAnimation\n\n\n\n### C++ Python 左耳朵耗子\n\nhttps://github.com/haoel/leetcode\n\n\n\n### Java\n\nhttps://github.com/Blankj/awesome-java-leetcode\n\n\n\n### Go\n\nhttps://github.com/halfrost/LeetCode-Go\n\nhttps://github.com/aQuaYi/LeetCode-in-Go\n\n\n\n### 其他版本\n\nhttps://github.com/azl397985856/leetcode\n\nhttps://github.com/apachecn/Interview\n\nhttps://github.com/soulmachine/leetcode\n\n\n\n## 数据结构与算法\n\n### Swift\n\nhttps://www.jianshu.com/p/ee16bcf50a59\n\nhttps://github.com/raywenderlich/swift-algorithm-club\n\nhttps://github.com/apple/swift-algorithms\n\nhttps://swift.org/blog/swift-algorithms/\n\nhttps://forums.swift.org/c/related-projects/algorithms/70\n\nhttps://medium.com/swift-algorithms-data-structures\n\nhttps://www.udacity.com/course/data-structures-and-algorithms-in-swift--ud1011\n\n\n\n## 工具\n\n### 数据结构和算法动态可视化\n\nhttps://visualgo.net/zh\n\n\n\n### 函数图像绘制工具\n\nhttps://zh.numberempire.com/graphingcalculator.php\n\n\n\n### 二叉树动态可视化\n\nhttp://520it.com/binarytrees/\n\n\n\n### 二叉树动态可视化（二）\n\nhttp://btv.melezinek.cz/binary-search-tree.html\n\n\n\n### 二叉树动态可视化（三）\n\nhttps://yangez.github.io/btree-js/","source":"_posts/LeetCode 资料.md","raw":"---\ntitle: LeetCode 资料\ndate: 2021-01-25 23:59:05\ntags:\n- 数据结构与算法\ncategories:\n- LeetCode\n---\n\n\n\n[TOC]\n\n## 视频讲解\n\n### JS 版 老毕\n\nhttps://space.bilibili.com/455848380/\n\n\n\n### C++ 版 花花酱\n\nhttps://space.bilibili.com/9880352/\n\nhttps://www.youtube.com/channel/UC5xDNEcvb1vgw3lE21Ack2Q\n\n\n\n### Java 版\n\nhttps://space.bilibili.com/59546029/\n\n\n\n### Python 版\n\nhttps://www.youtube.com/channel/UCRCqgMdsAHK3yfvW4en6JpA\n\n\n\n### C++ 版\n\nhttps://www.youtube.com/channel/UCE35PnPX7EZi8nHSegjMn6Q/videos\n\n\n\n## GitHub 仓库代码\n\n### Swift 版 故胤道长\n\nhttps://github.com/soapyigu/LeetCode-Swift\n\n\n\n### C++ Python\n\nhttps://github.com/pezy/LeetCode\n\n\n\n### JS\n\nhttps://github.com/MisterBooo/LeetCodeAnimation\n\n\n\n### C++ Python 左耳朵耗子\n\nhttps://github.com/haoel/leetcode\n\n\n\n### Java\n\nhttps://github.com/Blankj/awesome-java-leetcode\n\n\n\n### Go\n\nhttps://github.com/halfrost/LeetCode-Go\n\nhttps://github.com/aQuaYi/LeetCode-in-Go\n\n\n\n### 其他版本\n\nhttps://github.com/azl397985856/leetcode\n\nhttps://github.com/apachecn/Interview\n\nhttps://github.com/soulmachine/leetcode\n\n\n\n## 数据结构与算法\n\n### Swift\n\nhttps://www.jianshu.com/p/ee16bcf50a59\n\nhttps://github.com/raywenderlich/swift-algorithm-club\n\nhttps://github.com/apple/swift-algorithms\n\nhttps://swift.org/blog/swift-algorithms/\n\nhttps://forums.swift.org/c/related-projects/algorithms/70\n\nhttps://medium.com/swift-algorithms-data-structures\n\nhttps://www.udacity.com/course/data-structures-and-algorithms-in-swift--ud1011\n\n\n\n## 工具\n\n### 数据结构和算法动态可视化\n\nhttps://visualgo.net/zh\n\n\n\n### 函数图像绘制工具\n\nhttps://zh.numberempire.com/graphingcalculator.php\n\n\n\n### 二叉树动态可视化\n\nhttp://520it.com/binarytrees/\n\n\n\n### 二叉树动态可视化（二）\n\nhttp://btv.melezinek.cz/binary-search-tree.html\n\n\n\n### 二叉树动态可视化（三）\n\nhttps://yangez.github.io/btree-js/","slug":"LeetCode 资料","published":1,"updated":"2022-07-01T06:22:31.273Z","_id":"ckqsw2n79000t51dx6lybe1ht","comments":1,"layout":"post","photos":[],"link":"","content":"<p>[TOC]</p>\n<h2 id=\"视频讲解\"><a href=\"#视频讲解\" class=\"headerlink\" title=\"视频讲解\"></a>视频讲解</h2><h3 id=\"JS-版-老毕\"><a href=\"#JS-版-老毕\" class=\"headerlink\" title=\"JS 版 老毕\"></a>JS 版 老毕</h3><p><a href=\"https://space.bilibili.com/455848380/\">https://space.bilibili.com/455848380/</a></p>\n<h3 id=\"C-版-花花酱\"><a href=\"#C-版-花花酱\" class=\"headerlink\" title=\"C++ 版 花花酱\"></a>C++ 版 花花酱</h3><p><a href=\"https://space.bilibili.com/9880352/\">https://space.bilibili.com/9880352/</a></p>\n<p><a href=\"https://www.youtube.com/channel/UC5xDNEcvb1vgw3lE21Ack2Q\">https://www.youtube.com/channel/UC5xDNEcvb1vgw3lE21Ack2Q</a></p>\n<h3 id=\"Java-版\"><a href=\"#Java-版\" class=\"headerlink\" title=\"Java 版\"></a>Java 版</h3><p><a href=\"https://space.bilibili.com/59546029/\">https://space.bilibili.com/59546029/</a></p>\n<h3 id=\"Python-版\"><a href=\"#Python-版\" class=\"headerlink\" title=\"Python 版\"></a>Python 版</h3><p><a href=\"https://www.youtube.com/channel/UCRCqgMdsAHK3yfvW4en6JpA\">https://www.youtube.com/channel/UCRCqgMdsAHK3yfvW4en6JpA</a></p>\n<h3 id=\"C-版\"><a href=\"#C-版\" class=\"headerlink\" title=\"C++ 版\"></a>C++ 版</h3><p><a href=\"https://www.youtube.com/channel/UCE35PnPX7EZi8nHSegjMn6Q/videos\">https://www.youtube.com/channel/UCE35PnPX7EZi8nHSegjMn6Q/videos</a></p>\n<h2 id=\"GitHub-仓库代码\"><a href=\"#GitHub-仓库代码\" class=\"headerlink\" title=\"GitHub 仓库代码\"></a>GitHub 仓库代码</h2><h3 id=\"Swift-版-故胤道长\"><a href=\"#Swift-版-故胤道长\" class=\"headerlink\" title=\"Swift 版 故胤道长\"></a>Swift 版 故胤道长</h3><p><a href=\"https://github.com/soapyigu/LeetCode-Swift\">https://github.com/soapyigu/LeetCode-Swift</a></p>\n<h3 id=\"C-Python\"><a href=\"#C-Python\" class=\"headerlink\" title=\"C++ Python\"></a>C++ Python</h3><p><a href=\"https://github.com/pezy/LeetCode\">https://github.com/pezy/LeetCode</a></p>\n<h3 id=\"JS\"><a href=\"#JS\" class=\"headerlink\" title=\"JS\"></a>JS</h3><p><a href=\"https://github.com/MisterBooo/LeetCodeAnimation\">https://github.com/MisterBooo/LeetCodeAnimation</a></p>\n<h3 id=\"C-Python-左耳朵耗子\"><a href=\"#C-Python-左耳朵耗子\" class=\"headerlink\" title=\"C++ Python 左耳朵耗子\"></a>C++ Python 左耳朵耗子</h3><p><a href=\"https://github.com/haoel/leetcode\">https://github.com/haoel/leetcode</a></p>\n<h3 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h3><p><a href=\"https://github.com/Blankj/awesome-java-leetcode\">https://github.com/Blankj/awesome-java-leetcode</a></p>\n<h3 id=\"Go\"><a href=\"#Go\" class=\"headerlink\" title=\"Go\"></a>Go</h3><p><a href=\"https://github.com/halfrost/LeetCode-Go\">https://github.com/halfrost/LeetCode-Go</a></p>\n<p><a href=\"https://github.com/aQuaYi/LeetCode-in-Go\">https://github.com/aQuaYi/LeetCode-in-Go</a></p>\n<h3 id=\"其他版本\"><a href=\"#其他版本\" class=\"headerlink\" title=\"其他版本\"></a>其他版本</h3><p><a href=\"https://github.com/azl397985856/leetcode\">https://github.com/azl397985856/leetcode</a></p>\n<p><a href=\"https://github.com/apachecn/Interview\">https://github.com/apachecn/Interview</a></p>\n<p><a href=\"https://github.com/soulmachine/leetcode\">https://github.com/soulmachine/leetcode</a></p>\n<h2 id=\"数据结构与算法\"><a href=\"#数据结构与算法\" class=\"headerlink\" title=\"数据结构与算法\"></a>数据结构与算法</h2><h3 id=\"Swift\"><a href=\"#Swift\" class=\"headerlink\" title=\"Swift\"></a>Swift</h3><p><a href=\"https://www.jianshu.com/p/ee16bcf50a59\">https://www.jianshu.com/p/ee16bcf50a59</a></p>\n<p><a href=\"https://github.com/raywenderlich/swift-algorithm-club\">https://github.com/raywenderlich/swift-algorithm-club</a></p>\n<p><a href=\"https://github.com/apple/swift-algorithms\">https://github.com/apple/swift-algorithms</a></p>\n<p><a href=\"https://swift.org/blog/swift-algorithms/\">https://swift.org/blog/swift-algorithms/</a></p>\n<p><a href=\"https://forums.swift.org/c/related-projects/algorithms/70\">https://forums.swift.org/c/related-projects/algorithms/70</a></p>\n<p><a href=\"https://medium.com/swift-algorithms-data-structures\">https://medium.com/swift-algorithms-data-structures</a></p>\n<p><a href=\"https://www.udacity.com/course/data-structures-and-algorithms-in-swift--ud1011\">https://www.udacity.com/course/data-structures-and-algorithms-in-swift--ud1011</a></p>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><h3 id=\"数据结构和算法动态可视化\"><a href=\"#数据结构和算法动态可视化\" class=\"headerlink\" title=\"数据结构和算法动态可视化\"></a>数据结构和算法动态可视化</h3><p><a href=\"https://visualgo.net/zh\">https://visualgo.net/zh</a></p>\n<h3 id=\"函数图像绘制工具\"><a href=\"#函数图像绘制工具\" class=\"headerlink\" title=\"函数图像绘制工具\"></a>函数图像绘制工具</h3><p><a href=\"https://zh.numberempire.com/graphingcalculator.php\">https://zh.numberempire.com/graphingcalculator.php</a></p>\n<h3 id=\"二叉树动态可视化\"><a href=\"#二叉树动态可视化\" class=\"headerlink\" title=\"二叉树动态可视化\"></a>二叉树动态可视化</h3><p><a href=\"http://520it.com/binarytrees/\">http://520it.com/binarytrees/</a></p>\n<h3 id=\"二叉树动态可视化（二）\"><a href=\"#二叉树动态可视化（二）\" class=\"headerlink\" title=\"二叉树动态可视化（二）\"></a>二叉树动态可视化（二）</h3><p><a href=\"http://btv.melezinek.cz/binary-search-tree.html\">http://btv.melezinek.cz/binary-search-tree.html</a></p>\n<h3 id=\"二叉树动态可视化（三）\"><a href=\"#二叉树动态可视化（三）\" class=\"headerlink\" title=\"二叉树动态可视化（三）\"></a>二叉树动态可视化（三）</h3><p><a href=\"https://yangez.github.io/btree-js/\">https://yangez.github.io/btree-js/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>[TOC]</p>\n<h2 id=\"视频讲解\"><a href=\"#视频讲解\" class=\"headerlink\" title=\"视频讲解\"></a>视频讲解</h2><h3 id=\"JS-版-老毕\"><a href=\"#JS-版-老毕\" class=\"headerlink\" title=\"JS 版 老毕\"></a>JS 版 老毕</h3><p><a href=\"https://space.bilibili.com/455848380/\">https://space.bilibili.com/455848380/</a></p>\n<h3 id=\"C-版-花花酱\"><a href=\"#C-版-花花酱\" class=\"headerlink\" title=\"C++ 版 花花酱\"></a>C++ 版 花花酱</h3><p><a href=\"https://space.bilibili.com/9880352/\">https://space.bilibili.com/9880352/</a></p>\n<p><a href=\"https://www.youtube.com/channel/UC5xDNEcvb1vgw3lE21Ack2Q\">https://www.youtube.com/channel/UC5xDNEcvb1vgw3lE21Ack2Q</a></p>\n<h3 id=\"Java-版\"><a href=\"#Java-版\" class=\"headerlink\" title=\"Java 版\"></a>Java 版</h3><p><a href=\"https://space.bilibili.com/59546029/\">https://space.bilibili.com/59546029/</a></p>\n<h3 id=\"Python-版\"><a href=\"#Python-版\" class=\"headerlink\" title=\"Python 版\"></a>Python 版</h3><p><a href=\"https://www.youtube.com/channel/UCRCqgMdsAHK3yfvW4en6JpA\">https://www.youtube.com/channel/UCRCqgMdsAHK3yfvW4en6JpA</a></p>\n<h3 id=\"C-版\"><a href=\"#C-版\" class=\"headerlink\" title=\"C++ 版\"></a>C++ 版</h3><p><a href=\"https://www.youtube.com/channel/UCE35PnPX7EZi8nHSegjMn6Q/videos\">https://www.youtube.com/channel/UCE35PnPX7EZi8nHSegjMn6Q/videos</a></p>\n<h2 id=\"GitHub-仓库代码\"><a href=\"#GitHub-仓库代码\" class=\"headerlink\" title=\"GitHub 仓库代码\"></a>GitHub 仓库代码</h2><h3 id=\"Swift-版-故胤道长\"><a href=\"#Swift-版-故胤道长\" class=\"headerlink\" title=\"Swift 版 故胤道长\"></a>Swift 版 故胤道长</h3><p><a href=\"https://github.com/soapyigu/LeetCode-Swift\">https://github.com/soapyigu/LeetCode-Swift</a></p>\n<h3 id=\"C-Python\"><a href=\"#C-Python\" class=\"headerlink\" title=\"C++ Python\"></a>C++ Python</h3><p><a href=\"https://github.com/pezy/LeetCode\">https://github.com/pezy/LeetCode</a></p>\n<h3 id=\"JS\"><a href=\"#JS\" class=\"headerlink\" title=\"JS\"></a>JS</h3><p><a href=\"https://github.com/MisterBooo/LeetCodeAnimation\">https://github.com/MisterBooo/LeetCodeAnimation</a></p>\n<h3 id=\"C-Python-左耳朵耗子\"><a href=\"#C-Python-左耳朵耗子\" class=\"headerlink\" title=\"C++ Python 左耳朵耗子\"></a>C++ Python 左耳朵耗子</h3><p><a href=\"https://github.com/haoel/leetcode\">https://github.com/haoel/leetcode</a></p>\n<h3 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h3><p><a href=\"https://github.com/Blankj/awesome-java-leetcode\">https://github.com/Blankj/awesome-java-leetcode</a></p>\n<h3 id=\"Go\"><a href=\"#Go\" class=\"headerlink\" title=\"Go\"></a>Go</h3><p><a href=\"https://github.com/halfrost/LeetCode-Go\">https://github.com/halfrost/LeetCode-Go</a></p>\n<p><a href=\"https://github.com/aQuaYi/LeetCode-in-Go\">https://github.com/aQuaYi/LeetCode-in-Go</a></p>\n<h3 id=\"其他版本\"><a href=\"#其他版本\" class=\"headerlink\" title=\"其他版本\"></a>其他版本</h3><p><a href=\"https://github.com/azl397985856/leetcode\">https://github.com/azl397985856/leetcode</a></p>\n<p><a href=\"https://github.com/apachecn/Interview\">https://github.com/apachecn/Interview</a></p>\n<p><a href=\"https://github.com/soulmachine/leetcode\">https://github.com/soulmachine/leetcode</a></p>\n<h2 id=\"数据结构与算法\"><a href=\"#数据结构与算法\" class=\"headerlink\" title=\"数据结构与算法\"></a>数据结构与算法</h2><h3 id=\"Swift\"><a href=\"#Swift\" class=\"headerlink\" title=\"Swift\"></a>Swift</h3><p><a href=\"https://www.jianshu.com/p/ee16bcf50a59\">https://www.jianshu.com/p/ee16bcf50a59</a></p>\n<p><a href=\"https://github.com/raywenderlich/swift-algorithm-club\">https://github.com/raywenderlich/swift-algorithm-club</a></p>\n<p><a href=\"https://github.com/apple/swift-algorithms\">https://github.com/apple/swift-algorithms</a></p>\n<p><a href=\"https://swift.org/blog/swift-algorithms/\">https://swift.org/blog/swift-algorithms/</a></p>\n<p><a href=\"https://forums.swift.org/c/related-projects/algorithms/70\">https://forums.swift.org/c/related-projects/algorithms/70</a></p>\n<p><a href=\"https://medium.com/swift-algorithms-data-structures\">https://medium.com/swift-algorithms-data-structures</a></p>\n<p><a href=\"https://www.udacity.com/course/data-structures-and-algorithms-in-swift--ud1011\">https://www.udacity.com/course/data-structures-and-algorithms-in-swift--ud1011</a></p>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><h3 id=\"数据结构和算法动态可视化\"><a href=\"#数据结构和算法动态可视化\" class=\"headerlink\" title=\"数据结构和算法动态可视化\"></a>数据结构和算法动态可视化</h3><p><a href=\"https://visualgo.net/zh\">https://visualgo.net/zh</a></p>\n<h3 id=\"函数图像绘制工具\"><a href=\"#函数图像绘制工具\" class=\"headerlink\" title=\"函数图像绘制工具\"></a>函数图像绘制工具</h3><p><a href=\"https://zh.numberempire.com/graphingcalculator.php\">https://zh.numberempire.com/graphingcalculator.php</a></p>\n<h3 id=\"二叉树动态可视化\"><a href=\"#二叉树动态可视化\" class=\"headerlink\" title=\"二叉树动态可视化\"></a>二叉树动态可视化</h3><p><a href=\"http://520it.com/binarytrees/\">http://520it.com/binarytrees/</a></p>\n<h3 id=\"二叉树动态可视化（二）\"><a href=\"#二叉树动态可视化（二）\" class=\"headerlink\" title=\"二叉树动态可视化（二）\"></a>二叉树动态可视化（二）</h3><p><a href=\"http://btv.melezinek.cz/binary-search-tree.html\">http://btv.melezinek.cz/binary-search-tree.html</a></p>\n<h3 id=\"二叉树动态可视化（三）\"><a href=\"#二叉树动态可视化（三）\" class=\"headerlink\" title=\"二叉树动态可视化（三）\"></a>二叉树动态可视化（三）</h3><p><a href=\"https://yangez.github.io/btree-js/\">https://yangez.github.io/btree-js/</a></p>\n"},{"title":"OC Swift 混编问题","date":"2021-01-04T09:19:21.000Z","_content":"\n\n\n最近要使用一个支付的 SDK，纯 Swift 写的，用 CocoaPods 引入之后，怎么都找不到 `Adyen-Swift.h`文件，新建一个工程之后，在 `Podfile`中添加`use_frameworks!`就能找到。\n\n最后通过`@import Adyen`解决的。\n\n并不知道为什么！","source":"_posts/OC Swift 混编问题.md","raw":"---\ntitle: OC Swift 混编问题\ndate: 2021-01-04 17:19:21\ntags:\n- iOS\n- 问题\ncategories:\n- iOS 开发笔记\n\n---\n\n\n\n最近要使用一个支付的 SDK，纯 Swift 写的，用 CocoaPods 引入之后，怎么都找不到 `Adyen-Swift.h`文件，新建一个工程之后，在 `Podfile`中添加`use_frameworks!`就能找到。\n\n最后通过`@import Adyen`解决的。\n\n并不知道为什么！","slug":"OC Swift 混编问题","published":1,"updated":"2021-06-04T08:08:07.243Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqsw2n7a000u51dxgks05ptp","content":"<p>最近要使用一个支付的 SDK，纯 Swift 写的，用 CocoaPods 引入之后，怎么都找不到 <code>Adyen-Swift.h</code>文件，新建一个工程之后，在 <code>Podfile</code>中添加<code>use_frameworks!</code>就能找到。</p>\n<p>最后通过<code>@import Adyen</code>解决的。</p>\n<p>并不知道为什么！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近要使用一个支付的 SDK，纯 Swift 写的，用 CocoaPods 引入之后，怎么都找不到 <code>Adyen-Swift.h</code>文件，新建一个工程之后，在 <code>Podfile</code>中添加<code>use_frameworks!</code>就能找到。</p>\n<p>最后通过<code>@import Adyen</code>解决的。</p>\n<p>并不知道为什么！</p>\n"},{"title":"React Native Flexbox 布局","date":"2020-12-23T09:19:21.000Z","_content":"\n\n\n[TOC]\n\n## flex\n\n数值，子元素的主轴填充，一个区域根据每个元素 flex 值的和进行划分。\n\n## flexDirection\n\n主轴方向。\n\n#### column(默认)\n\n竖直方向上对齐。\n\n#### column-reverse\n\n竖直方向下对齐。\n\n#### row\n\n水平方向左对齐。\n\n#### row-reverse\n\n水平方向右对齐。\n\n## justifyContent\n\n子元素在主轴上的排列方式。\n\n主轴没有 `stretch`、`baseline`属性。\n\n#### flex-start(默认)\n\n左对齐或上对齐。\n\n#### flex-end\n\n右对齐或下对齐。\n\n#### center\n\n居中对齐。\n\n#### space-between\n\n无边距的平均分布。\n\n#### space-around\n\n有边距的平均分布。\n\n#### space-evenly\n\n完全平均分布。\n\n## alignItems\n\n子元素在次轴上的排列方式，只作用于当前行或当前列(可换行时)。\n\n次轴没有`space-between`、`space-around`、`space-evenly`属性。\n\n#### streach(默认)\n\n主轴方向上完全拉伸，如果设置了宽度 or 高度则失效。\n\n![stretch](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144509.png)\n\n#### flex-start\n\n左对齐或上对齐。\n\n![flex-start](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144536.png)\n\n#### flex-end\n\n右对齐或下对齐。\n\n#### center\n\n居中对齐。\n\n#### baseline\n\n左对齐或上对齐，基线为所有元素的最高点。\n\n![baseline](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144557.png)\n\n## flexWrap\n\n#### nowrap\n\n不换行。\n\n#### wrap\n\n换行。\n\n![wrap](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144616.png)\n\n#### wrap-reverse\n\n逆序换行。\n\n## alignContent\n\n子元素在次轴上的排列方式，全局而非当前行或当前列，只在可换行时有效。\n\n## flexBasis\n\n数值，主轴的默认宽度 or 高度，如果同时设置了宽度 or 高度，会覆盖宽度 or 高度。\n\n## flexGrow\n\n数值，填充剩余可用空间，`0`为默认值，相当于没有设置该属性，可为`>=0`的浮点数，小于`1`的值代表占据宽度或高度的比例。\n\n![flexGrow](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144636.png)\n\n## flexShrink\n\n数值，没有设置换行时，部分元素会被挤出屏幕，设置该属性为`1`后可为当前元素分配剩余可用空间。\n\n![flexShrink-1](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144657.png)\n\n![flexShrink-2](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144805.png)\n\n![flexShrink-3](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144834.png)\n\n## top bottom left right position\n\n后布局的元素会覆盖先布局的元素。\n\n### position\n\n#### relative\n\n相对位置，默认值。\n\n#### absolute\n\n绝对位置，会影响其他子元素。\n\n![top-1](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144858.png)\n\n![top-2](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144909.png)\n\n![bottom](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144923.png)\n\n![left](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144935.png)\n\n![right](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112145018.png)\n\n![absolute](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112145041.png)\n\n![relative](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112145118.png)","source":"_posts/React Native Flexbox 布局.md","raw":"---\ntitle: React Native Flexbox 布局\ndate: 2020-12-23 17:19:21\ntags:\n- 编程语言\n- UI\ncategories:\n- React Native\n---\n\n\n\n[TOC]\n\n## flex\n\n数值，子元素的主轴填充，一个区域根据每个元素 flex 值的和进行划分。\n\n## flexDirection\n\n主轴方向。\n\n#### column(默认)\n\n竖直方向上对齐。\n\n#### column-reverse\n\n竖直方向下对齐。\n\n#### row\n\n水平方向左对齐。\n\n#### row-reverse\n\n水平方向右对齐。\n\n## justifyContent\n\n子元素在主轴上的排列方式。\n\n主轴没有 `stretch`、`baseline`属性。\n\n#### flex-start(默认)\n\n左对齐或上对齐。\n\n#### flex-end\n\n右对齐或下对齐。\n\n#### center\n\n居中对齐。\n\n#### space-between\n\n无边距的平均分布。\n\n#### space-around\n\n有边距的平均分布。\n\n#### space-evenly\n\n完全平均分布。\n\n## alignItems\n\n子元素在次轴上的排列方式，只作用于当前行或当前列(可换行时)。\n\n次轴没有`space-between`、`space-around`、`space-evenly`属性。\n\n#### streach(默认)\n\n主轴方向上完全拉伸，如果设置了宽度 or 高度则失效。\n\n![stretch](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144509.png)\n\n#### flex-start\n\n左对齐或上对齐。\n\n![flex-start](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144536.png)\n\n#### flex-end\n\n右对齐或下对齐。\n\n#### center\n\n居中对齐。\n\n#### baseline\n\n左对齐或上对齐，基线为所有元素的最高点。\n\n![baseline](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144557.png)\n\n## flexWrap\n\n#### nowrap\n\n不换行。\n\n#### wrap\n\n换行。\n\n![wrap](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144616.png)\n\n#### wrap-reverse\n\n逆序换行。\n\n## alignContent\n\n子元素在次轴上的排列方式，全局而非当前行或当前列，只在可换行时有效。\n\n## flexBasis\n\n数值，主轴的默认宽度 or 高度，如果同时设置了宽度 or 高度，会覆盖宽度 or 高度。\n\n## flexGrow\n\n数值，填充剩余可用空间，`0`为默认值，相当于没有设置该属性，可为`>=0`的浮点数，小于`1`的值代表占据宽度或高度的比例。\n\n![flexGrow](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144636.png)\n\n## flexShrink\n\n数值，没有设置换行时，部分元素会被挤出屏幕，设置该属性为`1`后可为当前元素分配剩余可用空间。\n\n![flexShrink-1](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144657.png)\n\n![flexShrink-2](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144805.png)\n\n![flexShrink-3](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144834.png)\n\n## top bottom left right position\n\n后布局的元素会覆盖先布局的元素。\n\n### position\n\n#### relative\n\n相对位置，默认值。\n\n#### absolute\n\n绝对位置，会影响其他子元素。\n\n![top-1](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144858.png)\n\n![top-2](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144909.png)\n\n![bottom](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144923.png)\n\n![left](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144935.png)\n\n![right](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112145018.png)\n\n![absolute](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112145041.png)\n\n![relative](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112145118.png)","slug":"React Native Flexbox 布局","published":1,"updated":"2021-06-04T08:08:07.243Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqsw2n7b000x51dx3r1iewiv","content":"<p>[TOC]</p>\n<h2 id=\"flex\"><a href=\"#flex\" class=\"headerlink\" title=\"flex\"></a>flex</h2><p>数值，子元素的主轴填充，一个区域根据每个元素 flex 值的和进行划分。</p>\n<h2 id=\"flexDirection\"><a href=\"#flexDirection\" class=\"headerlink\" title=\"flexDirection\"></a>flexDirection</h2><p>主轴方向。</p>\n<h4 id=\"column-默认\"><a href=\"#column-默认\" class=\"headerlink\" title=\"column(默认)\"></a>column(默认)</h4><p>竖直方向上对齐。</p>\n<h4 id=\"column-reverse\"><a href=\"#column-reverse\" class=\"headerlink\" title=\"column-reverse\"></a>column-reverse</h4><p>竖直方向下对齐。</p>\n<h4 id=\"row\"><a href=\"#row\" class=\"headerlink\" title=\"row\"></a>row</h4><p>水平方向左对齐。</p>\n<h4 id=\"row-reverse\"><a href=\"#row-reverse\" class=\"headerlink\" title=\"row-reverse\"></a>row-reverse</h4><p>水平方向右对齐。</p>\n<h2 id=\"justifyContent\"><a href=\"#justifyContent\" class=\"headerlink\" title=\"justifyContent\"></a>justifyContent</h2><p>子元素在主轴上的排列方式。</p>\n<p>主轴没有 <code>stretch</code>、<code>baseline</code>属性。</p>\n<h4 id=\"flex-start-默认\"><a href=\"#flex-start-默认\" class=\"headerlink\" title=\"flex-start(默认)\"></a>flex-start(默认)</h4><p>左对齐或上对齐。</p>\n<h4 id=\"flex-end\"><a href=\"#flex-end\" class=\"headerlink\" title=\"flex-end\"></a>flex-end</h4><p>右对齐或下对齐。</p>\n<h4 id=\"center\"><a href=\"#center\" class=\"headerlink\" title=\"center\"></a>center</h4><p>居中对齐。</p>\n<h4 id=\"space-between\"><a href=\"#space-between\" class=\"headerlink\" title=\"space-between\"></a>space-between</h4><p>无边距的平均分布。</p>\n<h4 id=\"space-around\"><a href=\"#space-around\" class=\"headerlink\" title=\"space-around\"></a>space-around</h4><p>有边距的平均分布。</p>\n<h4 id=\"space-evenly\"><a href=\"#space-evenly\" class=\"headerlink\" title=\"space-evenly\"></a>space-evenly</h4><p>完全平均分布。</p>\n<h2 id=\"alignItems\"><a href=\"#alignItems\" class=\"headerlink\" title=\"alignItems\"></a>alignItems</h2><p>子元素在次轴上的排列方式，只作用于当前行或当前列(可换行时)。</p>\n<p>次轴没有<code>space-between</code>、<code>space-around</code>、<code>space-evenly</code>属性。</p>\n<h4 id=\"streach-默认\"><a href=\"#streach-默认\" class=\"headerlink\" title=\"streach(默认)\"></a>streach(默认)</h4><p>主轴方向上完全拉伸，如果设置了宽度 or 高度则失效。</p>\n<p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144509.png\" alt=\"stretch\"></p>\n<h4 id=\"flex-start\"><a href=\"#flex-start\" class=\"headerlink\" title=\"flex-start\"></a>flex-start</h4><p>左对齐或上对齐。</p>\n<p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144536.png\" alt=\"flex-start\"></p>\n<h4 id=\"flex-end-1\"><a href=\"#flex-end-1\" class=\"headerlink\" title=\"flex-end\"></a>flex-end</h4><p>右对齐或下对齐。</p>\n<h4 id=\"center-1\"><a href=\"#center-1\" class=\"headerlink\" title=\"center\"></a>center</h4><p>居中对齐。</p>\n<h4 id=\"baseline\"><a href=\"#baseline\" class=\"headerlink\" title=\"baseline\"></a>baseline</h4><p>左对齐或上对齐，基线为所有元素的最高点。</p>\n<p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144557.png\" alt=\"baseline\"></p>\n<h2 id=\"flexWrap\"><a href=\"#flexWrap\" class=\"headerlink\" title=\"flexWrap\"></a>flexWrap</h2><h4 id=\"nowrap\"><a href=\"#nowrap\" class=\"headerlink\" title=\"nowrap\"></a>nowrap</h4><p>不换行。</p>\n<h4 id=\"wrap\"><a href=\"#wrap\" class=\"headerlink\" title=\"wrap\"></a>wrap</h4><p>换行。</p>\n<p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144616.png\" alt=\"wrap\"></p>\n<h4 id=\"wrap-reverse\"><a href=\"#wrap-reverse\" class=\"headerlink\" title=\"wrap-reverse\"></a>wrap-reverse</h4><p>逆序换行。</p>\n<h2 id=\"alignContent\"><a href=\"#alignContent\" class=\"headerlink\" title=\"alignContent\"></a>alignContent</h2><p>子元素在次轴上的排列方式，全局而非当前行或当前列，只在可换行时有效。</p>\n<h2 id=\"flexBasis\"><a href=\"#flexBasis\" class=\"headerlink\" title=\"flexBasis\"></a>flexBasis</h2><p>数值，主轴的默认宽度 or 高度，如果同时设置了宽度 or 高度，会覆盖宽度 or 高度。</p>\n<h2 id=\"flexGrow\"><a href=\"#flexGrow\" class=\"headerlink\" title=\"flexGrow\"></a>flexGrow</h2><p>数值，填充剩余可用空间，<code>0</code>为默认值，相当于没有设置该属性，可为<code>&gt;=0</code>的浮点数，小于<code>1</code>的值代表占据宽度或高度的比例。</p>\n<p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144636.png\" alt=\"flexGrow\"></p>\n<h2 id=\"flexShrink\"><a href=\"#flexShrink\" class=\"headerlink\" title=\"flexShrink\"></a>flexShrink</h2><p>数值，没有设置换行时，部分元素会被挤出屏幕，设置该属性为<code>1</code>后可为当前元素分配剩余可用空间。</p>\n<p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144657.png\" alt=\"flexShrink-1\"></p>\n<p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144805.png\" alt=\"flexShrink-2\"></p>\n<p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144834.png\" alt=\"flexShrink-3\"></p>\n<h2 id=\"top-bottom-left-right-position\"><a href=\"#top-bottom-left-right-position\" class=\"headerlink\" title=\"top bottom left right position\"></a>top bottom left right position</h2><p>后布局的元素会覆盖先布局的元素。</p>\n<h3 id=\"position\"><a href=\"#position\" class=\"headerlink\" title=\"position\"></a>position</h3><h4 id=\"relative\"><a href=\"#relative\" class=\"headerlink\" title=\"relative\"></a>relative</h4><p>相对位置，默认值。</p>\n<h4 id=\"absolute\"><a href=\"#absolute\" class=\"headerlink\" title=\"absolute\"></a>absolute</h4><p>绝对位置，会影响其他子元素。</p>\n<p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144858.png\" alt=\"top-1\"></p>\n<p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144909.png\" alt=\"top-2\"></p>\n<p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144923.png\" alt=\"bottom\"></p>\n<p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144935.png\" alt=\"left\"></p>\n<p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112145018.png\" alt=\"right\"></p>\n<p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112145041.png\" alt=\"absolute\"></p>\n<p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112145118.png\" alt=\"relative\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>[TOC]</p>\n<h2 id=\"flex\"><a href=\"#flex\" class=\"headerlink\" title=\"flex\"></a>flex</h2><p>数值，子元素的主轴填充，一个区域根据每个元素 flex 值的和进行划分。</p>\n<h2 id=\"flexDirection\"><a href=\"#flexDirection\" class=\"headerlink\" title=\"flexDirection\"></a>flexDirection</h2><p>主轴方向。</p>\n<h4 id=\"column-默认\"><a href=\"#column-默认\" class=\"headerlink\" title=\"column(默认)\"></a>column(默认)</h4><p>竖直方向上对齐。</p>\n<h4 id=\"column-reverse\"><a href=\"#column-reverse\" class=\"headerlink\" title=\"column-reverse\"></a>column-reverse</h4><p>竖直方向下对齐。</p>\n<h4 id=\"row\"><a href=\"#row\" class=\"headerlink\" title=\"row\"></a>row</h4><p>水平方向左对齐。</p>\n<h4 id=\"row-reverse\"><a href=\"#row-reverse\" class=\"headerlink\" title=\"row-reverse\"></a>row-reverse</h4><p>水平方向右对齐。</p>\n<h2 id=\"justifyContent\"><a href=\"#justifyContent\" class=\"headerlink\" title=\"justifyContent\"></a>justifyContent</h2><p>子元素在主轴上的排列方式。</p>\n<p>主轴没有 <code>stretch</code>、<code>baseline</code>属性。</p>\n<h4 id=\"flex-start-默认\"><a href=\"#flex-start-默认\" class=\"headerlink\" title=\"flex-start(默认)\"></a>flex-start(默认)</h4><p>左对齐或上对齐。</p>\n<h4 id=\"flex-end\"><a href=\"#flex-end\" class=\"headerlink\" title=\"flex-end\"></a>flex-end</h4><p>右对齐或下对齐。</p>\n<h4 id=\"center\"><a href=\"#center\" class=\"headerlink\" title=\"center\"></a>center</h4><p>居中对齐。</p>\n<h4 id=\"space-between\"><a href=\"#space-between\" class=\"headerlink\" title=\"space-between\"></a>space-between</h4><p>无边距的平均分布。</p>\n<h4 id=\"space-around\"><a href=\"#space-around\" class=\"headerlink\" title=\"space-around\"></a>space-around</h4><p>有边距的平均分布。</p>\n<h4 id=\"space-evenly\"><a href=\"#space-evenly\" class=\"headerlink\" title=\"space-evenly\"></a>space-evenly</h4><p>完全平均分布。</p>\n<h2 id=\"alignItems\"><a href=\"#alignItems\" class=\"headerlink\" title=\"alignItems\"></a>alignItems</h2><p>子元素在次轴上的排列方式，只作用于当前行或当前列(可换行时)。</p>\n<p>次轴没有<code>space-between</code>、<code>space-around</code>、<code>space-evenly</code>属性。</p>\n<h4 id=\"streach-默认\"><a href=\"#streach-默认\" class=\"headerlink\" title=\"streach(默认)\"></a>streach(默认)</h4><p>主轴方向上完全拉伸，如果设置了宽度 or 高度则失效。</p>\n<p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144509.png\" alt=\"stretch\"></p>\n<h4 id=\"flex-start\"><a href=\"#flex-start\" class=\"headerlink\" title=\"flex-start\"></a>flex-start</h4><p>左对齐或上对齐。</p>\n<p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144536.png\" alt=\"flex-start\"></p>\n<h4 id=\"flex-end-1\"><a href=\"#flex-end-1\" class=\"headerlink\" title=\"flex-end\"></a>flex-end</h4><p>右对齐或下对齐。</p>\n<h4 id=\"center-1\"><a href=\"#center-1\" class=\"headerlink\" title=\"center\"></a>center</h4><p>居中对齐。</p>\n<h4 id=\"baseline\"><a href=\"#baseline\" class=\"headerlink\" title=\"baseline\"></a>baseline</h4><p>左对齐或上对齐，基线为所有元素的最高点。</p>\n<p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144557.png\" alt=\"baseline\"></p>\n<h2 id=\"flexWrap\"><a href=\"#flexWrap\" class=\"headerlink\" title=\"flexWrap\"></a>flexWrap</h2><h4 id=\"nowrap\"><a href=\"#nowrap\" class=\"headerlink\" title=\"nowrap\"></a>nowrap</h4><p>不换行。</p>\n<h4 id=\"wrap\"><a href=\"#wrap\" class=\"headerlink\" title=\"wrap\"></a>wrap</h4><p>换行。</p>\n<p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144616.png\" alt=\"wrap\"></p>\n<h4 id=\"wrap-reverse\"><a href=\"#wrap-reverse\" class=\"headerlink\" title=\"wrap-reverse\"></a>wrap-reverse</h4><p>逆序换行。</p>\n<h2 id=\"alignContent\"><a href=\"#alignContent\" class=\"headerlink\" title=\"alignContent\"></a>alignContent</h2><p>子元素在次轴上的排列方式，全局而非当前行或当前列，只在可换行时有效。</p>\n<h2 id=\"flexBasis\"><a href=\"#flexBasis\" class=\"headerlink\" title=\"flexBasis\"></a>flexBasis</h2><p>数值，主轴的默认宽度 or 高度，如果同时设置了宽度 or 高度，会覆盖宽度 or 高度。</p>\n<h2 id=\"flexGrow\"><a href=\"#flexGrow\" class=\"headerlink\" title=\"flexGrow\"></a>flexGrow</h2><p>数值，填充剩余可用空间，<code>0</code>为默认值，相当于没有设置该属性，可为<code>&gt;=0</code>的浮点数，小于<code>1</code>的值代表占据宽度或高度的比例。</p>\n<p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144636.png\" alt=\"flexGrow\"></p>\n<h2 id=\"flexShrink\"><a href=\"#flexShrink\" class=\"headerlink\" title=\"flexShrink\"></a>flexShrink</h2><p>数值，没有设置换行时，部分元素会被挤出屏幕，设置该属性为<code>1</code>后可为当前元素分配剩余可用空间。</p>\n<p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144657.png\" alt=\"flexShrink-1\"></p>\n<p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144805.png\" alt=\"flexShrink-2\"></p>\n<p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144834.png\" alt=\"flexShrink-3\"></p>\n<h2 id=\"top-bottom-left-right-position\"><a href=\"#top-bottom-left-right-position\" class=\"headerlink\" title=\"top bottom left right position\"></a>top bottom left right position</h2><p>后布局的元素会覆盖先布局的元素。</p>\n<h3 id=\"position\"><a href=\"#position\" class=\"headerlink\" title=\"position\"></a>position</h3><h4 id=\"relative\"><a href=\"#relative\" class=\"headerlink\" title=\"relative\"></a>relative</h4><p>相对位置，默认值。</p>\n<h4 id=\"absolute\"><a href=\"#absolute\" class=\"headerlink\" title=\"absolute\"></a>absolute</h4><p>绝对位置，会影响其他子元素。</p>\n<p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144858.png\" alt=\"top-1\"></p>\n<p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144909.png\" alt=\"top-2\"></p>\n<p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144923.png\" alt=\"bottom\"></p>\n<p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112144935.png\" alt=\"left\"></p>\n<p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112145018.png\" alt=\"right\"></p>\n<p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112145041.png\" alt=\"absolute\"></p>\n<p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112145118.png\" alt=\"relative\"></p>\n"},{"title":"React Native 学习资料","date":"2020-12-23T09:19:21.000Z","_content":"\n\n\n[TOC]\n\n## 1 小时入门教程(购物清单 常用组件)\n\nhttps://www.youtube.com/watch?v=Hf4MJH0jDb4\n\n### iOS 模拟器快捷键失效\n\n```\nI/O -> Input -> Send Keyboard Input to Device\n```\n\n### Web 调试快捷键\n\n```\n⌥ + ⌘ + I\n```\n\n## 2 小时入门教程(VS Code 插件、Web 调试、VS Code 调试)\n\nhttps://www.youtube.com/watch?v=0-S5a0eXPoc\n\n### VS Code 插件\n\n```\nReact Native Tools\nReact-Native/React/Redux\nPrettier\nMaterial Icon Theme\n```\n\n#### Redux Snippets\n\n##### rsf\n\n引入模块 & 创建函数\n\n##### rnss\n\n创建 StyleSheet\n\n### VS Code 快捷键\n\n#### ⌘ + D\n\n选中文本，点击 `⌘ + D` 可多选相同的文本\n\n#### ⌥ + ↑ / ⌥ + ↓\n\n选中文本，点击 `⌥ + ↑` 或 `⌥ + ↓` 移动位置\n\n#### ⇧ + ⌥ + ↑ / ⇧ + ⌥ + ↓\n\n选中文本，点击 `⇧ + ⌥ + ↑`或`⇧ + ⌥ + ↓`拷贝一份相同内容\n\n### 为什么要使用 StyleSheet\n\n> 1. 运行时会检查拼写\n> 2. Facebook 做了优化","source":"_posts/React Native 学习资料.md","raw":"---\ntitle: React Native 学习资料\ndate: 2020-12-23 17:19:21\ntags:\n- 学习资料\ncategories:\n- React Native\n---\n\n\n\n[TOC]\n\n## 1 小时入门教程(购物清单 常用组件)\n\nhttps://www.youtube.com/watch?v=Hf4MJH0jDb4\n\n### iOS 模拟器快捷键失效\n\n```\nI/O -> Input -> Send Keyboard Input to Device\n```\n\n### Web 调试快捷键\n\n```\n⌥ + ⌘ + I\n```\n\n## 2 小时入门教程(VS Code 插件、Web 调试、VS Code 调试)\n\nhttps://www.youtube.com/watch?v=0-S5a0eXPoc\n\n### VS Code 插件\n\n```\nReact Native Tools\nReact-Native/React/Redux\nPrettier\nMaterial Icon Theme\n```\n\n#### Redux Snippets\n\n##### rsf\n\n引入模块 & 创建函数\n\n##### rnss\n\n创建 StyleSheet\n\n### VS Code 快捷键\n\n#### ⌘ + D\n\n选中文本，点击 `⌘ + D` 可多选相同的文本\n\n#### ⌥ + ↑ / ⌥ + ↓\n\n选中文本，点击 `⌥ + ↑` 或 `⌥ + ↓` 移动位置\n\n#### ⇧ + ⌥ + ↑ / ⇧ + ⌥ + ↓\n\n选中文本，点击 `⇧ + ⌥ + ↑`或`⇧ + ⌥ + ↓`拷贝一份相同内容\n\n### 为什么要使用 StyleSheet\n\n> 1. 运行时会检查拼写\n> 2. Facebook 做了优化","slug":"React Native 学习资料","published":1,"updated":"2021-06-04T08:08:07.243Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqsw2n7c001051dx8i2r8j9m","content":"<p>[TOC]</p>\n<h2 id=\"1-小时入门教程-购物清单-常用组件\"><a href=\"#1-小时入门教程-购物清单-常用组件\" class=\"headerlink\" title=\"1 小时入门教程(购物清单 常用组件)\"></a>1 小时入门教程(购物清单 常用组件)</h2><p><a href=\"https://www.youtube.com/watch?v=Hf4MJH0jDb4\">https://www.youtube.com/watch?v=Hf4MJH0jDb4</a></p>\n<h3 id=\"iOS-模拟器快捷键失效\"><a href=\"#iOS-模拟器快捷键失效\" class=\"headerlink\" title=\"iOS 模拟器快捷键失效\"></a>iOS 模拟器快捷键失效</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">I&#x2F;O -&gt; Input -&gt; Send Keyboard Input to Device</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Web-调试快捷键\"><a href=\"#Web-调试快捷键\" class=\"headerlink\" title=\"Web 调试快捷键\"></a>Web 调试快捷键</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">⌥ + ⌘ + I</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-小时入门教程-VS-Code-插件、Web-调试、VS-Code-调试\"><a href=\"#2-小时入门教程-VS-Code-插件、Web-调试、VS-Code-调试\" class=\"headerlink\" title=\"2 小时入门教程(VS Code 插件、Web 调试、VS Code 调试)\"></a>2 小时入门教程(VS Code 插件、Web 调试、VS Code 调试)</h2><p><a href=\"https://www.youtube.com/watch?v=0-S5a0eXPoc\">https://www.youtube.com/watch?v=0-S5a0eXPoc</a></p>\n<h3 id=\"VS-Code-插件\"><a href=\"#VS-Code-插件\" class=\"headerlink\" title=\"VS Code 插件\"></a>VS Code 插件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">React Native Tools</span><br><span class=\"line\">React-Native&#x2F;React&#x2F;Redux</span><br><span class=\"line\">Prettier</span><br><span class=\"line\">Material Icon Theme</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Redux-Snippets\"><a href=\"#Redux-Snippets\" class=\"headerlink\" title=\"Redux Snippets\"></a>Redux Snippets</h4><h5 id=\"rsf\"><a href=\"#rsf\" class=\"headerlink\" title=\"rsf\"></a>rsf</h5><p>引入模块 &amp; 创建函数</p>\n<h5 id=\"rnss\"><a href=\"#rnss\" class=\"headerlink\" title=\"rnss\"></a>rnss</h5><p>创建 StyleSheet</p>\n<h3 id=\"VS-Code-快捷键\"><a href=\"#VS-Code-快捷键\" class=\"headerlink\" title=\"VS Code 快捷键\"></a>VS Code 快捷键</h3><h4 id=\"⌘-D\"><a href=\"#⌘-D\" class=\"headerlink\" title=\"⌘ + D\"></a>⌘ + D</h4><p>选中文本，点击 <code>⌘ + D</code> 可多选相同的文本</p>\n<h4 id=\"⌥-↑-⌥-↓\"><a href=\"#⌥-↑-⌥-↓\" class=\"headerlink\" title=\"⌥ + ↑ / ⌥ + ↓\"></a>⌥ + ↑ / ⌥ + ↓</h4><p>选中文本，点击 <code>⌥ + ↑</code> 或 <code>⌥ + ↓</code> 移动位置</p>\n<h4 id=\"⇧-⌥-↑-⇧-⌥-↓\"><a href=\"#⇧-⌥-↑-⇧-⌥-↓\" class=\"headerlink\" title=\"⇧ + ⌥ + ↑ / ⇧ + ⌥ + ↓\"></a>⇧ + ⌥ + ↑ / ⇧ + ⌥ + ↓</h4><p>选中文本，点击 <code>⇧ + ⌥ + ↑</code>或<code>⇧ + ⌥ + ↓</code>拷贝一份相同内容</p>\n<h3 id=\"为什么要使用-StyleSheet\"><a href=\"#为什么要使用-StyleSheet\" class=\"headerlink\" title=\"为什么要使用 StyleSheet\"></a>为什么要使用 StyleSheet</h3><blockquote>\n<ol>\n<li>运行时会检查拼写</li>\n<li>Facebook 做了优化</li>\n</ol>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>[TOC]</p>\n<h2 id=\"1-小时入门教程-购物清单-常用组件\"><a href=\"#1-小时入门教程-购物清单-常用组件\" class=\"headerlink\" title=\"1 小时入门教程(购物清单 常用组件)\"></a>1 小时入门教程(购物清单 常用组件)</h2><p><a href=\"https://www.youtube.com/watch?v=Hf4MJH0jDb4\">https://www.youtube.com/watch?v=Hf4MJH0jDb4</a></p>\n<h3 id=\"iOS-模拟器快捷键失效\"><a href=\"#iOS-模拟器快捷键失效\" class=\"headerlink\" title=\"iOS 模拟器快捷键失效\"></a>iOS 模拟器快捷键失效</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">I&#x2F;O -&gt; Input -&gt; Send Keyboard Input to Device</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Web-调试快捷键\"><a href=\"#Web-调试快捷键\" class=\"headerlink\" title=\"Web 调试快捷键\"></a>Web 调试快捷键</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">⌥ + ⌘ + I</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-小时入门教程-VS-Code-插件、Web-调试、VS-Code-调试\"><a href=\"#2-小时入门教程-VS-Code-插件、Web-调试、VS-Code-调试\" class=\"headerlink\" title=\"2 小时入门教程(VS Code 插件、Web 调试、VS Code 调试)\"></a>2 小时入门教程(VS Code 插件、Web 调试、VS Code 调试)</h2><p><a href=\"https://www.youtube.com/watch?v=0-S5a0eXPoc\">https://www.youtube.com/watch?v=0-S5a0eXPoc</a></p>\n<h3 id=\"VS-Code-插件\"><a href=\"#VS-Code-插件\" class=\"headerlink\" title=\"VS Code 插件\"></a>VS Code 插件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">React Native Tools</span><br><span class=\"line\">React-Native&#x2F;React&#x2F;Redux</span><br><span class=\"line\">Prettier</span><br><span class=\"line\">Material Icon Theme</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Redux-Snippets\"><a href=\"#Redux-Snippets\" class=\"headerlink\" title=\"Redux Snippets\"></a>Redux Snippets</h4><h5 id=\"rsf\"><a href=\"#rsf\" class=\"headerlink\" title=\"rsf\"></a>rsf</h5><p>引入模块 &amp; 创建函数</p>\n<h5 id=\"rnss\"><a href=\"#rnss\" class=\"headerlink\" title=\"rnss\"></a>rnss</h5><p>创建 StyleSheet</p>\n<h3 id=\"VS-Code-快捷键\"><a href=\"#VS-Code-快捷键\" class=\"headerlink\" title=\"VS Code 快捷键\"></a>VS Code 快捷键</h3><h4 id=\"⌘-D\"><a href=\"#⌘-D\" class=\"headerlink\" title=\"⌘ + D\"></a>⌘ + D</h4><p>选中文本，点击 <code>⌘ + D</code> 可多选相同的文本</p>\n<h4 id=\"⌥-↑-⌥-↓\"><a href=\"#⌥-↑-⌥-↓\" class=\"headerlink\" title=\"⌥ + ↑ / ⌥ + ↓\"></a>⌥ + ↑ / ⌥ + ↓</h4><p>选中文本，点击 <code>⌥ + ↑</code> 或 <code>⌥ + ↓</code> 移动位置</p>\n<h4 id=\"⇧-⌥-↑-⇧-⌥-↓\"><a href=\"#⇧-⌥-↑-⇧-⌥-↓\" class=\"headerlink\" title=\"⇧ + ⌥ + ↑ / ⇧ + ⌥ + ↓\"></a>⇧ + ⌥ + ↑ / ⇧ + ⌥ + ↓</h4><p>选中文本，点击 <code>⇧ + ⌥ + ↑</code>或<code>⇧ + ⌥ + ↓</code>拷贝一份相同内容</p>\n<h3 id=\"为什么要使用-StyleSheet\"><a href=\"#为什么要使用-StyleSheet\" class=\"headerlink\" title=\"为什么要使用 StyleSheet\"></a>为什么要使用 StyleSheet</h3><blockquote>\n<ol>\n<li>运行时会检查拼写</li>\n<li>Facebook 做了优化</li>\n</ol>\n</blockquote>\n"},{"title":"React 语法","date":"2021-01-08T09:19:21.000Z","_content":"","source":"_posts/React 语法.md","raw":"---\ntitle: React 语法\ndate: 2021-01-08 17:19:21\ntags:\n- 编程语言\n- 语法基础\ncategories:\n- React\n---\n","slug":"React 语法","published":1,"updated":"2021-06-04T08:08:07.243Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqsw2n7d001351dxargmb36d","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Swift 语法","date":"2021-01-07T09:19:21.000Z","_content":"\n","source":"_posts/Swift 语法.md","raw":"---\ntitle: Swift 语法\ndate: 2021-01-07 17:19:21\ntags:\n- 编程语言\n- 语法基础\ncategories:\n- Swift\n---\n\n","slug":"Swift 语法","published":1,"updated":"2021-06-04T08:08:07.243Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqsw2n7f001751dxape851wi","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"TypeScript","date":"2020-12-29T09:19:21.000Z","_content":"\n\n\n是 JavaScript 的超集，有类型系统、接口、泛型、Decorators、丰富的配置选项。\n\n![TypeScript](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112172910.png)","source":"_posts/TypeScript.md","raw":"---\ntitle: TypeScript\ndate: 2020-12-29 17:19:21\ntags:\n- 编程语言\ncategories:\n- TypeScript\n---\n\n\n\n是 JavaScript 的超集，有类型系统、接口、泛型、Decorators、丰富的配置选项。\n\n![TypeScript](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112172910.png)","slug":"TypeScript","published":1,"updated":"2021-06-04T08:08:07.244Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqsw2n7g001b51dx773dgix2","content":"<p>是 JavaScript 的超集，有类型系统、接口、泛型、Decorators、丰富的配置选项。</p>\n<p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112172910.png\" alt=\"TypeScript\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>是 JavaScript 的超集，有类型系统、接口、泛型、Decorators、丰富的配置选项。</p>\n<p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210112172910.png\" alt=\"TypeScript\"></p>\n"},{"title":"iOS 启动时间优化","date":"2021-01-18T06:23:24.000Z","_content":"\n\n\n[TOC]\n\n## 文档相关\n\n### Reducing Your App's Launch Time\n\nhttps://developer.apple.com/documentation/xcode/improving_your_app_s_performance/reducing_your_app_s_launch_time?language=objc\n\n\n\n## WWDC 相关视频\n\n### 2012-235 iOS App 性能\n\n统计 main 函数到 didFinishLaunching 的时间\n\niOS App Performance: Responsiveness\n\nhttps://developer.apple.com/videos/play/wwdc2012/235/\n\n\n\n### 2016-406 优化启动时间\n\n启动各个阶段所做的事情 主要为 main 函数前\n\nOptimizing App Startup Time\n\nhttps://developer.apple.com/videos/play/wwdc2016/406/\n\nhttp://yulingtianxia.com/blog/2016/10/30/Optimizing-App-Startup-Time/\n\nhttps://www.jianshu.com/p/3b0256192e4e\n\n\n\n### 2016-418 Time Profile 的使用\n\nUsing Time Profiler in Instruments\n\nhttps://developer.apple.com/videos/play/wwdc2016/418/\n\n\n\n### 2017-413 App 启动时间：过去、现在与未来\n\nApp Startup Time: Past, Present, and Future\n\nhttps://developer.apple.com/videos/play/wwdc2017/413/\n\nhttps://www.jianshu.com/p/96f66b0c943c\n\n\n\n### 2017-706 GCD 的使用\n\nModernizing Grand Central Dispatch Usage\n\nhttps://developer.apple.com/videos/play/wwdc2017/706/\n\n\n\n### 2018-220 高性能自动布局\n\nHigh Performance Auto Layout\n\nhttps://developer.apple.com/videos/play/wwdc2018/220/\n\n\n\n### 2018-405 通过日志记录衡量性能\n\nMeasuring Performance Using Logging\n\nhttps://developer.apple.com/videos/play/wwdc2018/405/\n\n\n\n### 2018-407 实现出色 App 性能的实用方法\n\nPractical Approaches to Great App Performance\n\nhttps://developer.apple.com/videos/play/wwdc2018/407/\n\n\n\n### 2019-411 Instruments 的使用\n\nGetting Started with Instruments\n\nhttps://developer.apple.com/videos/play/wwdc2019/411/\n\n\n\n### 2019-423 优化 App 启动\n\n启动各个阶段可以做的优化以及 App Launch 的使用示例\n\nOptimizing App Launch\n\nhttps://developer.apple.com/videos/play/wwdc2019/423/\n\nhttps://xiaozhuanlan.com/topic/4690823715\n\n\n\n## 博客文章\n\n### iOS应用启动性能优化资料（汇总）\n\nhttps://everettjf.github.io/2018/08/06/ios-launch-performance-collection/\n\n\n\n### iOS 如何优化 App 的启动耗时\n\nhttps://gsl201600.github.io/2020/04/01/iOS%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96App%E7%9A%84%E5%90%AF%E5%8A%A8%E8%80%97%E6%97%B6/\n\n\n\n### APP 启动速度优化\n\n描述了启动各个阶段所做的事情\n\nhttps://medium.com/@EdisonFan/%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96-872cbff15859\n\n\n\n### 深入探索 iOS 启动速度优化\n\nhttps://juejin.cn/post/6844904127068110862\n\n\n\n### 高德 APP 启动耗时剖析与优化实践（iOS 篇）\n\nhttps://www.infoq.cn/article/xjb3cysclphv5sh5923q\n\n\n\n### 抖音品质建设 - iOS启动优化《原理篇》\n\nhttps://mp.weixin.qq.com/s/3-Sbqe9gxdV6eI1f435BDg\n\n\n\n### 抖音品质建设 - iOS启动优化《实战篇》\n\nhttps://mp.weixin.qq.com/s/ekXfFu4-rmZpHwzFuKiLXw\n\n\n\n### iOS 优化篇 - 启动优化之Clang插桩实现二进制重排\n\nhttps://mp.weixin.qq.com/s/UlMAvuLuTcWgd3qkEAHYMA\n\n\n\n### 今日头条 iOS 客户端启动速度优化\n\nhttps://juejin.cn/post/6844903649416577037\n\n\n\n### 马蜂窝 iOS App 启动治理：回归用户体验\n\nhttps://juejin.cn/post/6844903841410842638\n\n\n\n### 美团外卖 iOS App 冷启动治理\n\nhttps://tech.meituan.com/2018/12/06/waimai-ios-optimizing-startup.html","source":"_posts/iOS 启动时间优化.md","raw":"---\ntitle: iOS 启动时间优化\ndate: 2021-01-18 14:23:24\ntags:\n- iOS\n- 优化\n- 学习资料\ncategories:\n- iOS 开发笔记\n---\n\n\n\n[TOC]\n\n## 文档相关\n\n### Reducing Your App's Launch Time\n\nhttps://developer.apple.com/documentation/xcode/improving_your_app_s_performance/reducing_your_app_s_launch_time?language=objc\n\n\n\n## WWDC 相关视频\n\n### 2012-235 iOS App 性能\n\n统计 main 函数到 didFinishLaunching 的时间\n\niOS App Performance: Responsiveness\n\nhttps://developer.apple.com/videos/play/wwdc2012/235/\n\n\n\n### 2016-406 优化启动时间\n\n启动各个阶段所做的事情 主要为 main 函数前\n\nOptimizing App Startup Time\n\nhttps://developer.apple.com/videos/play/wwdc2016/406/\n\nhttp://yulingtianxia.com/blog/2016/10/30/Optimizing-App-Startup-Time/\n\nhttps://www.jianshu.com/p/3b0256192e4e\n\n\n\n### 2016-418 Time Profile 的使用\n\nUsing Time Profiler in Instruments\n\nhttps://developer.apple.com/videos/play/wwdc2016/418/\n\n\n\n### 2017-413 App 启动时间：过去、现在与未来\n\nApp Startup Time: Past, Present, and Future\n\nhttps://developer.apple.com/videos/play/wwdc2017/413/\n\nhttps://www.jianshu.com/p/96f66b0c943c\n\n\n\n### 2017-706 GCD 的使用\n\nModernizing Grand Central Dispatch Usage\n\nhttps://developer.apple.com/videos/play/wwdc2017/706/\n\n\n\n### 2018-220 高性能自动布局\n\nHigh Performance Auto Layout\n\nhttps://developer.apple.com/videos/play/wwdc2018/220/\n\n\n\n### 2018-405 通过日志记录衡量性能\n\nMeasuring Performance Using Logging\n\nhttps://developer.apple.com/videos/play/wwdc2018/405/\n\n\n\n### 2018-407 实现出色 App 性能的实用方法\n\nPractical Approaches to Great App Performance\n\nhttps://developer.apple.com/videos/play/wwdc2018/407/\n\n\n\n### 2019-411 Instruments 的使用\n\nGetting Started with Instruments\n\nhttps://developer.apple.com/videos/play/wwdc2019/411/\n\n\n\n### 2019-423 优化 App 启动\n\n启动各个阶段可以做的优化以及 App Launch 的使用示例\n\nOptimizing App Launch\n\nhttps://developer.apple.com/videos/play/wwdc2019/423/\n\nhttps://xiaozhuanlan.com/topic/4690823715\n\n\n\n## 博客文章\n\n### iOS应用启动性能优化资料（汇总）\n\nhttps://everettjf.github.io/2018/08/06/ios-launch-performance-collection/\n\n\n\n### iOS 如何优化 App 的启动耗时\n\nhttps://gsl201600.github.io/2020/04/01/iOS%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96App%E7%9A%84%E5%90%AF%E5%8A%A8%E8%80%97%E6%97%B6/\n\n\n\n### APP 启动速度优化\n\n描述了启动各个阶段所做的事情\n\nhttps://medium.com/@EdisonFan/%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96-872cbff15859\n\n\n\n### 深入探索 iOS 启动速度优化\n\nhttps://juejin.cn/post/6844904127068110862\n\n\n\n### 高德 APP 启动耗时剖析与优化实践（iOS 篇）\n\nhttps://www.infoq.cn/article/xjb3cysclphv5sh5923q\n\n\n\n### 抖音品质建设 - iOS启动优化《原理篇》\n\nhttps://mp.weixin.qq.com/s/3-Sbqe9gxdV6eI1f435BDg\n\n\n\n### 抖音品质建设 - iOS启动优化《实战篇》\n\nhttps://mp.weixin.qq.com/s/ekXfFu4-rmZpHwzFuKiLXw\n\n\n\n### iOS 优化篇 - 启动优化之Clang插桩实现二进制重排\n\nhttps://mp.weixin.qq.com/s/UlMAvuLuTcWgd3qkEAHYMA\n\n\n\n### 今日头条 iOS 客户端启动速度优化\n\nhttps://juejin.cn/post/6844903649416577037\n\n\n\n### 马蜂窝 iOS App 启动治理：回归用户体验\n\nhttps://juejin.cn/post/6844903841410842638\n\n\n\n### 美团外卖 iOS App 冷启动治理\n\nhttps://tech.meituan.com/2018/12/06/waimai-ios-optimizing-startup.html","slug":"iOS 启动时间优化","published":1,"updated":"2021-06-04T08:08:07.244Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqsw2n7i001f51dx9alfd6fw","content":"<p>[TOC]</p>\n<h2 id=\"文档相关\"><a href=\"#文档相关\" class=\"headerlink\" title=\"文档相关\"></a>文档相关</h2><h3 id=\"Reducing-Your-App’s-Launch-Time\"><a href=\"#Reducing-Your-App’s-Launch-Time\" class=\"headerlink\" title=\"Reducing Your App’s Launch Time\"></a>Reducing Your App’s Launch Time</h3><p><a href=\"https://developer.apple.com/documentation/xcode/improving_your_app_s_performance/reducing_your_app_s_launch_time?language=objc\">https://developer.apple.com/documentation/xcode/improving_your_app_s_performance/reducing_your_app_s_launch_time?language=objc</a></p>\n<h2 id=\"WWDC-相关视频\"><a href=\"#WWDC-相关视频\" class=\"headerlink\" title=\"WWDC 相关视频\"></a>WWDC 相关视频</h2><h3 id=\"2012-235-iOS-App-性能\"><a href=\"#2012-235-iOS-App-性能\" class=\"headerlink\" title=\"2012-235 iOS App 性能\"></a>2012-235 iOS App 性能</h3><p>统计 main 函数到 didFinishLaunching 的时间</p>\n<p>iOS App Performance: Responsiveness</p>\n<p><a href=\"https://developer.apple.com/videos/play/wwdc2012/235/\">https://developer.apple.com/videos/play/wwdc2012/235/</a></p>\n<h3 id=\"2016-406-优化启动时间\"><a href=\"#2016-406-优化启动时间\" class=\"headerlink\" title=\"2016-406 优化启动时间\"></a>2016-406 优化启动时间</h3><p>启动各个阶段所做的事情 主要为 main 函数前</p>\n<p>Optimizing App Startup Time</p>\n<p><a href=\"https://developer.apple.com/videos/play/wwdc2016/406/\">https://developer.apple.com/videos/play/wwdc2016/406/</a></p>\n<p><a href=\"http://yulingtianxia.com/blog/2016/10/30/Optimizing-App-Startup-Time/\">http://yulingtianxia.com/blog/2016/10/30/Optimizing-App-Startup-Time/</a></p>\n<p><a href=\"https://www.jianshu.com/p/3b0256192e4e\">https://www.jianshu.com/p/3b0256192e4e</a></p>\n<h3 id=\"2016-418-Time-Profile-的使用\"><a href=\"#2016-418-Time-Profile-的使用\" class=\"headerlink\" title=\"2016-418 Time Profile 的使用\"></a>2016-418 Time Profile 的使用</h3><p>Using Time Profiler in Instruments</p>\n<p><a href=\"https://developer.apple.com/videos/play/wwdc2016/418/\">https://developer.apple.com/videos/play/wwdc2016/418/</a></p>\n<h3 id=\"2017-413-App-启动时间：过去、现在与未来\"><a href=\"#2017-413-App-启动时间：过去、现在与未来\" class=\"headerlink\" title=\"2017-413 App 启动时间：过去、现在与未来\"></a>2017-413 App 启动时间：过去、现在与未来</h3><p>App Startup Time: Past, Present, and Future</p>\n<p><a href=\"https://developer.apple.com/videos/play/wwdc2017/413/\">https://developer.apple.com/videos/play/wwdc2017/413/</a></p>\n<p><a href=\"https://www.jianshu.com/p/96f66b0c943c\">https://www.jianshu.com/p/96f66b0c943c</a></p>\n<h3 id=\"2017-706-GCD-的使用\"><a href=\"#2017-706-GCD-的使用\" class=\"headerlink\" title=\"2017-706 GCD 的使用\"></a>2017-706 GCD 的使用</h3><p>Modernizing Grand Central Dispatch Usage</p>\n<p><a href=\"https://developer.apple.com/videos/play/wwdc2017/706/\">https://developer.apple.com/videos/play/wwdc2017/706/</a></p>\n<h3 id=\"2018-220-高性能自动布局\"><a href=\"#2018-220-高性能自动布局\" class=\"headerlink\" title=\"2018-220 高性能自动布局\"></a>2018-220 高性能自动布局</h3><p>High Performance Auto Layout</p>\n<p><a href=\"https://developer.apple.com/videos/play/wwdc2018/220/\">https://developer.apple.com/videos/play/wwdc2018/220/</a></p>\n<h3 id=\"2018-405-通过日志记录衡量性能\"><a href=\"#2018-405-通过日志记录衡量性能\" class=\"headerlink\" title=\"2018-405 通过日志记录衡量性能\"></a>2018-405 通过日志记录衡量性能</h3><p>Measuring Performance Using Logging</p>\n<p><a href=\"https://developer.apple.com/videos/play/wwdc2018/405/\">https://developer.apple.com/videos/play/wwdc2018/405/</a></p>\n<h3 id=\"2018-407-实现出色-App-性能的实用方法\"><a href=\"#2018-407-实现出色-App-性能的实用方法\" class=\"headerlink\" title=\"2018-407 实现出色 App 性能的实用方法\"></a>2018-407 实现出色 App 性能的实用方法</h3><p>Practical Approaches to Great App Performance</p>\n<p><a href=\"https://developer.apple.com/videos/play/wwdc2018/407/\">https://developer.apple.com/videos/play/wwdc2018/407/</a></p>\n<h3 id=\"2019-411-Instruments-的使用\"><a href=\"#2019-411-Instruments-的使用\" class=\"headerlink\" title=\"2019-411 Instruments 的使用\"></a>2019-411 Instruments 的使用</h3><p>Getting Started with Instruments</p>\n<p><a href=\"https://developer.apple.com/videos/play/wwdc2019/411/\">https://developer.apple.com/videos/play/wwdc2019/411/</a></p>\n<h3 id=\"2019-423-优化-App-启动\"><a href=\"#2019-423-优化-App-启动\" class=\"headerlink\" title=\"2019-423 优化 App 启动\"></a>2019-423 优化 App 启动</h3><p>启动各个阶段可以做的优化以及 App Launch 的使用示例</p>\n<p>Optimizing App Launch</p>\n<p><a href=\"https://developer.apple.com/videos/play/wwdc2019/423/\">https://developer.apple.com/videos/play/wwdc2019/423/</a></p>\n<p><a href=\"https://xiaozhuanlan.com/topic/4690823715\">https://xiaozhuanlan.com/topic/4690823715</a></p>\n<h2 id=\"博客文章\"><a href=\"#博客文章\" class=\"headerlink\" title=\"博客文章\"></a>博客文章</h2><h3 id=\"iOS应用启动性能优化资料（汇总）\"><a href=\"#iOS应用启动性能优化资料（汇总）\" class=\"headerlink\" title=\"iOS应用启动性能优化资料（汇总）\"></a>iOS应用启动性能优化资料（汇总）</h3><p><a href=\"https://everettjf.github.io/2018/08/06/ios-launch-performance-collection/\">https://everettjf.github.io/2018/08/06/ios-launch-performance-collection/</a></p>\n<h3 id=\"iOS-如何优化-App-的启动耗时\"><a href=\"#iOS-如何优化-App-的启动耗时\" class=\"headerlink\" title=\"iOS 如何优化 App 的启动耗时\"></a>iOS 如何优化 App 的启动耗时</h3><p><a href=\"https://gsl201600.github.io/2020/04/01/iOS%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96App%E7%9A%84%E5%90%AF%E5%8A%A8%E8%80%97%E6%97%B6/\">https://gsl201600.github.io/2020/04/01/iOS%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96App%E7%9A%84%E5%90%AF%E5%8A%A8%E8%80%97%E6%97%B6/</a></p>\n<h3 id=\"APP-启动速度优化\"><a href=\"#APP-启动速度优化\" class=\"headerlink\" title=\"APP 启动速度优化\"></a>APP 启动速度优化</h3><p>描述了启动各个阶段所做的事情</p>\n<p><a href=\"https://medium.com/@EdisonFan/%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96-872cbff15859\">https://medium.com/@EdisonFan/%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96-872cbff15859</a></p>\n<h3 id=\"深入探索-iOS-启动速度优化\"><a href=\"#深入探索-iOS-启动速度优化\" class=\"headerlink\" title=\"深入探索 iOS 启动速度优化\"></a>深入探索 iOS 启动速度优化</h3><p><a href=\"https://juejin.cn/post/6844904127068110862\">https://juejin.cn/post/6844904127068110862</a></p>\n<h3 id=\"高德-APP-启动耗时剖析与优化实践（iOS-篇）\"><a href=\"#高德-APP-启动耗时剖析与优化实践（iOS-篇）\" class=\"headerlink\" title=\"高德 APP 启动耗时剖析与优化实践（iOS 篇）\"></a>高德 APP 启动耗时剖析与优化实践（iOS 篇）</h3><p><a href=\"https://www.infoq.cn/article/xjb3cysclphv5sh5923q\">https://www.infoq.cn/article/xjb3cysclphv5sh5923q</a></p>\n<h3 id=\"抖音品质建设-iOS启动优化《原理篇》\"><a href=\"#抖音品质建设-iOS启动优化《原理篇》\" class=\"headerlink\" title=\"抖音品质建设 - iOS启动优化《原理篇》\"></a>抖音品质建设 - iOS启动优化《原理篇》</h3><p><a href=\"https://mp.weixin.qq.com/s/3-Sbqe9gxdV6eI1f435BDg\">https://mp.weixin.qq.com/s/3-Sbqe9gxdV6eI1f435BDg</a></p>\n<h3 id=\"抖音品质建设-iOS启动优化《实战篇》\"><a href=\"#抖音品质建设-iOS启动优化《实战篇》\" class=\"headerlink\" title=\"抖音品质建设 - iOS启动优化《实战篇》\"></a>抖音品质建设 - iOS启动优化《实战篇》</h3><p><a href=\"https://mp.weixin.qq.com/s/ekXfFu4-rmZpHwzFuKiLXw\">https://mp.weixin.qq.com/s/ekXfFu4-rmZpHwzFuKiLXw</a></p>\n<h3 id=\"iOS-优化篇-启动优化之Clang插桩实现二进制重排\"><a href=\"#iOS-优化篇-启动优化之Clang插桩实现二进制重排\" class=\"headerlink\" title=\"iOS 优化篇 - 启动优化之Clang插桩实现二进制重排\"></a>iOS 优化篇 - 启动优化之Clang插桩实现二进制重排</h3><p><a href=\"https://mp.weixin.qq.com/s/UlMAvuLuTcWgd3qkEAHYMA\">https://mp.weixin.qq.com/s/UlMAvuLuTcWgd3qkEAHYMA</a></p>\n<h3 id=\"今日头条-iOS-客户端启动速度优化\"><a href=\"#今日头条-iOS-客户端启动速度优化\" class=\"headerlink\" title=\"今日头条 iOS 客户端启动速度优化\"></a>今日头条 iOS 客户端启动速度优化</h3><p><a href=\"https://juejin.cn/post/6844903649416577037\">https://juejin.cn/post/6844903649416577037</a></p>\n<h3 id=\"马蜂窝-iOS-App-启动治理：回归用户体验\"><a href=\"#马蜂窝-iOS-App-启动治理：回归用户体验\" class=\"headerlink\" title=\"马蜂窝 iOS App 启动治理：回归用户体验\"></a>马蜂窝 iOS App 启动治理：回归用户体验</h3><p><a href=\"https://juejin.cn/post/6844903841410842638\">https://juejin.cn/post/6844903841410842638</a></p>\n<h3 id=\"美团外卖-iOS-App-冷启动治理\"><a href=\"#美团外卖-iOS-App-冷启动治理\" class=\"headerlink\" title=\"美团外卖 iOS App 冷启动治理\"></a>美团外卖 iOS App 冷启动治理</h3><p><a href=\"https://tech.meituan.com/2018/12/06/waimai-ios-optimizing-startup.html\">https://tech.meituan.com/2018/12/06/waimai-ios-optimizing-startup.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>[TOC]</p>\n<h2 id=\"文档相关\"><a href=\"#文档相关\" class=\"headerlink\" title=\"文档相关\"></a>文档相关</h2><h3 id=\"Reducing-Your-App’s-Launch-Time\"><a href=\"#Reducing-Your-App’s-Launch-Time\" class=\"headerlink\" title=\"Reducing Your App’s Launch Time\"></a>Reducing Your App’s Launch Time</h3><p><a href=\"https://developer.apple.com/documentation/xcode/improving_your_app_s_performance/reducing_your_app_s_launch_time?language=objc\">https://developer.apple.com/documentation/xcode/improving_your_app_s_performance/reducing_your_app_s_launch_time?language=objc</a></p>\n<h2 id=\"WWDC-相关视频\"><a href=\"#WWDC-相关视频\" class=\"headerlink\" title=\"WWDC 相关视频\"></a>WWDC 相关视频</h2><h3 id=\"2012-235-iOS-App-性能\"><a href=\"#2012-235-iOS-App-性能\" class=\"headerlink\" title=\"2012-235 iOS App 性能\"></a>2012-235 iOS App 性能</h3><p>统计 main 函数到 didFinishLaunching 的时间</p>\n<p>iOS App Performance: Responsiveness</p>\n<p><a href=\"https://developer.apple.com/videos/play/wwdc2012/235/\">https://developer.apple.com/videos/play/wwdc2012/235/</a></p>\n<h3 id=\"2016-406-优化启动时间\"><a href=\"#2016-406-优化启动时间\" class=\"headerlink\" title=\"2016-406 优化启动时间\"></a>2016-406 优化启动时间</h3><p>启动各个阶段所做的事情 主要为 main 函数前</p>\n<p>Optimizing App Startup Time</p>\n<p><a href=\"https://developer.apple.com/videos/play/wwdc2016/406/\">https://developer.apple.com/videos/play/wwdc2016/406/</a></p>\n<p><a href=\"http://yulingtianxia.com/blog/2016/10/30/Optimizing-App-Startup-Time/\">http://yulingtianxia.com/blog/2016/10/30/Optimizing-App-Startup-Time/</a></p>\n<p><a href=\"https://www.jianshu.com/p/3b0256192e4e\">https://www.jianshu.com/p/3b0256192e4e</a></p>\n<h3 id=\"2016-418-Time-Profile-的使用\"><a href=\"#2016-418-Time-Profile-的使用\" class=\"headerlink\" title=\"2016-418 Time Profile 的使用\"></a>2016-418 Time Profile 的使用</h3><p>Using Time Profiler in Instruments</p>\n<p><a href=\"https://developer.apple.com/videos/play/wwdc2016/418/\">https://developer.apple.com/videos/play/wwdc2016/418/</a></p>\n<h3 id=\"2017-413-App-启动时间：过去、现在与未来\"><a href=\"#2017-413-App-启动时间：过去、现在与未来\" class=\"headerlink\" title=\"2017-413 App 启动时间：过去、现在与未来\"></a>2017-413 App 启动时间：过去、现在与未来</h3><p>App Startup Time: Past, Present, and Future</p>\n<p><a href=\"https://developer.apple.com/videos/play/wwdc2017/413/\">https://developer.apple.com/videos/play/wwdc2017/413/</a></p>\n<p><a href=\"https://www.jianshu.com/p/96f66b0c943c\">https://www.jianshu.com/p/96f66b0c943c</a></p>\n<h3 id=\"2017-706-GCD-的使用\"><a href=\"#2017-706-GCD-的使用\" class=\"headerlink\" title=\"2017-706 GCD 的使用\"></a>2017-706 GCD 的使用</h3><p>Modernizing Grand Central Dispatch Usage</p>\n<p><a href=\"https://developer.apple.com/videos/play/wwdc2017/706/\">https://developer.apple.com/videos/play/wwdc2017/706/</a></p>\n<h3 id=\"2018-220-高性能自动布局\"><a href=\"#2018-220-高性能自动布局\" class=\"headerlink\" title=\"2018-220 高性能自动布局\"></a>2018-220 高性能自动布局</h3><p>High Performance Auto Layout</p>\n<p><a href=\"https://developer.apple.com/videos/play/wwdc2018/220/\">https://developer.apple.com/videos/play/wwdc2018/220/</a></p>\n<h3 id=\"2018-405-通过日志记录衡量性能\"><a href=\"#2018-405-通过日志记录衡量性能\" class=\"headerlink\" title=\"2018-405 通过日志记录衡量性能\"></a>2018-405 通过日志记录衡量性能</h3><p>Measuring Performance Using Logging</p>\n<p><a href=\"https://developer.apple.com/videos/play/wwdc2018/405/\">https://developer.apple.com/videos/play/wwdc2018/405/</a></p>\n<h3 id=\"2018-407-实现出色-App-性能的实用方法\"><a href=\"#2018-407-实现出色-App-性能的实用方法\" class=\"headerlink\" title=\"2018-407 实现出色 App 性能的实用方法\"></a>2018-407 实现出色 App 性能的实用方法</h3><p>Practical Approaches to Great App Performance</p>\n<p><a href=\"https://developer.apple.com/videos/play/wwdc2018/407/\">https://developer.apple.com/videos/play/wwdc2018/407/</a></p>\n<h3 id=\"2019-411-Instruments-的使用\"><a href=\"#2019-411-Instruments-的使用\" class=\"headerlink\" title=\"2019-411 Instruments 的使用\"></a>2019-411 Instruments 的使用</h3><p>Getting Started with Instruments</p>\n<p><a href=\"https://developer.apple.com/videos/play/wwdc2019/411/\">https://developer.apple.com/videos/play/wwdc2019/411/</a></p>\n<h3 id=\"2019-423-优化-App-启动\"><a href=\"#2019-423-优化-App-启动\" class=\"headerlink\" title=\"2019-423 优化 App 启动\"></a>2019-423 优化 App 启动</h3><p>启动各个阶段可以做的优化以及 App Launch 的使用示例</p>\n<p>Optimizing App Launch</p>\n<p><a href=\"https://developer.apple.com/videos/play/wwdc2019/423/\">https://developer.apple.com/videos/play/wwdc2019/423/</a></p>\n<p><a href=\"https://xiaozhuanlan.com/topic/4690823715\">https://xiaozhuanlan.com/topic/4690823715</a></p>\n<h2 id=\"博客文章\"><a href=\"#博客文章\" class=\"headerlink\" title=\"博客文章\"></a>博客文章</h2><h3 id=\"iOS应用启动性能优化资料（汇总）\"><a href=\"#iOS应用启动性能优化资料（汇总）\" class=\"headerlink\" title=\"iOS应用启动性能优化资料（汇总）\"></a>iOS应用启动性能优化资料（汇总）</h3><p><a href=\"https://everettjf.github.io/2018/08/06/ios-launch-performance-collection/\">https://everettjf.github.io/2018/08/06/ios-launch-performance-collection/</a></p>\n<h3 id=\"iOS-如何优化-App-的启动耗时\"><a href=\"#iOS-如何优化-App-的启动耗时\" class=\"headerlink\" title=\"iOS 如何优化 App 的启动耗时\"></a>iOS 如何优化 App 的启动耗时</h3><p><a href=\"https://gsl201600.github.io/2020/04/01/iOS%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96App%E7%9A%84%E5%90%AF%E5%8A%A8%E8%80%97%E6%97%B6/\">https://gsl201600.github.io/2020/04/01/iOS%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96App%E7%9A%84%E5%90%AF%E5%8A%A8%E8%80%97%E6%97%B6/</a></p>\n<h3 id=\"APP-启动速度优化\"><a href=\"#APP-启动速度优化\" class=\"headerlink\" title=\"APP 启动速度优化\"></a>APP 启动速度优化</h3><p>描述了启动各个阶段所做的事情</p>\n<p><a href=\"https://medium.com/@EdisonFan/%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96-872cbff15859\">https://medium.com/@EdisonFan/%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96-872cbff15859</a></p>\n<h3 id=\"深入探索-iOS-启动速度优化\"><a href=\"#深入探索-iOS-启动速度优化\" class=\"headerlink\" title=\"深入探索 iOS 启动速度优化\"></a>深入探索 iOS 启动速度优化</h3><p><a href=\"https://juejin.cn/post/6844904127068110862\">https://juejin.cn/post/6844904127068110862</a></p>\n<h3 id=\"高德-APP-启动耗时剖析与优化实践（iOS-篇）\"><a href=\"#高德-APP-启动耗时剖析与优化实践（iOS-篇）\" class=\"headerlink\" title=\"高德 APP 启动耗时剖析与优化实践（iOS 篇）\"></a>高德 APP 启动耗时剖析与优化实践（iOS 篇）</h3><p><a href=\"https://www.infoq.cn/article/xjb3cysclphv5sh5923q\">https://www.infoq.cn/article/xjb3cysclphv5sh5923q</a></p>\n<h3 id=\"抖音品质建设-iOS启动优化《原理篇》\"><a href=\"#抖音品质建设-iOS启动优化《原理篇》\" class=\"headerlink\" title=\"抖音品质建设 - iOS启动优化《原理篇》\"></a>抖音品质建设 - iOS启动优化《原理篇》</h3><p><a href=\"https://mp.weixin.qq.com/s/3-Sbqe9gxdV6eI1f435BDg\">https://mp.weixin.qq.com/s/3-Sbqe9gxdV6eI1f435BDg</a></p>\n<h3 id=\"抖音品质建设-iOS启动优化《实战篇》\"><a href=\"#抖音品质建设-iOS启动优化《实战篇》\" class=\"headerlink\" title=\"抖音品质建设 - iOS启动优化《实战篇》\"></a>抖音品质建设 - iOS启动优化《实战篇》</h3><p><a href=\"https://mp.weixin.qq.com/s/ekXfFu4-rmZpHwzFuKiLXw\">https://mp.weixin.qq.com/s/ekXfFu4-rmZpHwzFuKiLXw</a></p>\n<h3 id=\"iOS-优化篇-启动优化之Clang插桩实现二进制重排\"><a href=\"#iOS-优化篇-启动优化之Clang插桩实现二进制重排\" class=\"headerlink\" title=\"iOS 优化篇 - 启动优化之Clang插桩实现二进制重排\"></a>iOS 优化篇 - 启动优化之Clang插桩实现二进制重排</h3><p><a href=\"https://mp.weixin.qq.com/s/UlMAvuLuTcWgd3qkEAHYMA\">https://mp.weixin.qq.com/s/UlMAvuLuTcWgd3qkEAHYMA</a></p>\n<h3 id=\"今日头条-iOS-客户端启动速度优化\"><a href=\"#今日头条-iOS-客户端启动速度优化\" class=\"headerlink\" title=\"今日头条 iOS 客户端启动速度优化\"></a>今日头条 iOS 客户端启动速度优化</h3><p><a href=\"https://juejin.cn/post/6844903649416577037\">https://juejin.cn/post/6844903649416577037</a></p>\n<h3 id=\"马蜂窝-iOS-App-启动治理：回归用户体验\"><a href=\"#马蜂窝-iOS-App-启动治理：回归用户体验\" class=\"headerlink\" title=\"马蜂窝 iOS App 启动治理：回归用户体验\"></a>马蜂窝 iOS App 启动治理：回归用户体验</h3><p><a href=\"https://juejin.cn/post/6844903841410842638\">https://juejin.cn/post/6844903841410842638</a></p>\n<h3 id=\"美团外卖-iOS-App-冷启动治理\"><a href=\"#美团外卖-iOS-App-冷启动治理\" class=\"headerlink\" title=\"美团外卖 iOS App 冷启动治理\"></a>美团外卖 iOS App 冷启动治理</h3><p><a href=\"https://tech.meituan.com/2018/12/06/waimai-ios-optimizing-startup.html\">https://tech.meituan.com/2018/12/06/waimai-ios-optimizing-startup.html</a></p>\n"},{"title":"iPhone 屏幕尺寸","date":"2020-11-23T09:19:21.000Z","_content":"\n\n\n| 手机型号                     | 屏幕尺寸 | 逻辑分辨率(pt) | 物理分辨率(px) | 倍图 |\n| ---------------------------- | -------- | -------------- | -------------- | ---- |\n| 4/4s                         | 3.5 inch | 320*480pt      | 640*960px      | @2x  |\n| 5/5c/5s/SE                   | 4.0 inch | 320*568pt      | 640*1136px     | @2x  |\n| 6/6s/7/8/SE2                 | 4.7 inch | 375*667pt      | 750*1334px     | @2x  |\n| 6 Plus/6s Plus/7 Plus/8 Plus | 5.5 inch | 414*736pt      | 1242 * 2208px  | @3x  |\n| X/XS/11 Pro                  | 5.8 inch | 375*812pt      | 1125* 2436px   | @3x  |\n| XR/11                        | 6.1 inch | 414*896pt      | 828* 1792px    | @2x  |\n| XS Max/11 Pro Max            | 6.5 inch | 414*896pt      | 1242* 2688px   | @3x  |\n| 12 mini                      | 5.4 inch | 360*780pt      | 1080* 2340px   | @3x  |\n| 12/12 Pro                    | 6.1 inch | 390*844pt      | 1170* 2532px   | @3x  |\n| 12 Pro Max                   | 6.7 inch | 428*926pt      | 1284* 2778px   | @3x  |\n|                              |          |                |                |      |\n|                              |          |                |                |      |\n\n\n\nhttps://www.jianshu.com/p/507c89d456e1\n\n[少数派](https://sspai.com/post/63214)\n\nhttps://steppark.net/15978209110755.html\n\n![9e12c3bbf1674051a52734ab93f2c72d](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210204201631.png)\n\n![img](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210223190349.png)\n","source":"_posts/iPhone 屏幕尺寸.md","raw":"---\ntitle: iPhone 屏幕尺寸\ndate: 2020-11-23 17:19:21\ntags:\n- iOS\n- UI\n- 总结\ncategories:\n- iOS 开发笔记\n---\n\n\n\n| 手机型号                     | 屏幕尺寸 | 逻辑分辨率(pt) | 物理分辨率(px) | 倍图 |\n| ---------------------------- | -------- | -------------- | -------------- | ---- |\n| 4/4s                         | 3.5 inch | 320*480pt      | 640*960px      | @2x  |\n| 5/5c/5s/SE                   | 4.0 inch | 320*568pt      | 640*1136px     | @2x  |\n| 6/6s/7/8/SE2                 | 4.7 inch | 375*667pt      | 750*1334px     | @2x  |\n| 6 Plus/6s Plus/7 Plus/8 Plus | 5.5 inch | 414*736pt      | 1242 * 2208px  | @3x  |\n| X/XS/11 Pro                  | 5.8 inch | 375*812pt      | 1125* 2436px   | @3x  |\n| XR/11                        | 6.1 inch | 414*896pt      | 828* 1792px    | @2x  |\n| XS Max/11 Pro Max            | 6.5 inch | 414*896pt      | 1242* 2688px   | @3x  |\n| 12 mini                      | 5.4 inch | 360*780pt      | 1080* 2340px   | @3x  |\n| 12/12 Pro                    | 6.1 inch | 390*844pt      | 1170* 2532px   | @3x  |\n| 12 Pro Max                   | 6.7 inch | 428*926pt      | 1284* 2778px   | @3x  |\n|                              |          |                |                |      |\n|                              |          |                |                |      |\n\n\n\nhttps://www.jianshu.com/p/507c89d456e1\n\n[少数派](https://sspai.com/post/63214)\n\nhttps://steppark.net/15978209110755.html\n\n![9e12c3bbf1674051a52734ab93f2c72d](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210204201631.png)\n\n![img](https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210223190349.png)\n","slug":"iPhone 屏幕尺寸","published":1,"updated":"2022-07-01T06:22:31.290Z","_id":"ckqsw2n7k001i51dxa6lgh356","comments":1,"layout":"post","photos":[],"link":"","content":"<table>\n<thead>\n<tr>\n<th>手机型号</th>\n<th>屏幕尺寸</th>\n<th>逻辑分辨率(pt)</th>\n<th>物理分辨率(px)</th>\n<th>倍图</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>4/4s</td>\n<td>3.5 inch</td>\n<td>320*480pt</td>\n<td>640*960px</td>\n<td>@2x</td>\n</tr>\n<tr>\n<td>5/5c/5s/SE</td>\n<td>4.0 inch</td>\n<td>320*568pt</td>\n<td>640*1136px</td>\n<td>@2x</td>\n</tr>\n<tr>\n<td>6/6s/7/8/SE2</td>\n<td>4.7 inch</td>\n<td>375*667pt</td>\n<td>750*1334px</td>\n<td>@2x</td>\n</tr>\n<tr>\n<td>6 Plus/6s Plus/7 Plus/8 Plus</td>\n<td>5.5 inch</td>\n<td>414*736pt</td>\n<td>1242 * 2208px</td>\n<td>@3x</td>\n</tr>\n<tr>\n<td>X/XS/11 Pro</td>\n<td>5.8 inch</td>\n<td>375*812pt</td>\n<td>1125* 2436px</td>\n<td>@3x</td>\n</tr>\n<tr>\n<td>XR/11</td>\n<td>6.1 inch</td>\n<td>414*896pt</td>\n<td>828* 1792px</td>\n<td>@2x</td>\n</tr>\n<tr>\n<td>XS Max/11 Pro Max</td>\n<td>6.5 inch</td>\n<td>414*896pt</td>\n<td>1242* 2688px</td>\n<td>@3x</td>\n</tr>\n<tr>\n<td>12 mini</td>\n<td>5.4 inch</td>\n<td>360*780pt</td>\n<td>1080* 2340px</td>\n<td>@3x</td>\n</tr>\n<tr>\n<td>12/12 Pro</td>\n<td>6.1 inch</td>\n<td>390*844pt</td>\n<td>1170* 2532px</td>\n<td>@3x</td>\n</tr>\n<tr>\n<td>12 Pro Max</td>\n<td>6.7 inch</td>\n<td>428*926pt</td>\n<td>1284* 2778px</td>\n<td>@3x</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p><a href=\"https://www.jianshu.com/p/507c89d456e1\">https://www.jianshu.com/p/507c89d456e1</a></p>\n<p><a href=\"https://sspai.com/post/63214\">少数派</a></p>\n<p><a href=\"https://steppark.net/15978209110755.html\">https://steppark.net/15978209110755.html</a></p>\n<p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210204201631.png\" alt=\"9e12c3bbf1674051a52734ab93f2c72d\"></p>\n<p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210223190349.png\" alt=\"img\"></p>\n","site":{"data":{}},"excerpt":"","more":"<table>\n<thead>\n<tr>\n<th>手机型号</th>\n<th>屏幕尺寸</th>\n<th>逻辑分辨率(pt)</th>\n<th>物理分辨率(px)</th>\n<th>倍图</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>4/4s</td>\n<td>3.5 inch</td>\n<td>320*480pt</td>\n<td>640*960px</td>\n<td>@2x</td>\n</tr>\n<tr>\n<td>5/5c/5s/SE</td>\n<td>4.0 inch</td>\n<td>320*568pt</td>\n<td>640*1136px</td>\n<td>@2x</td>\n</tr>\n<tr>\n<td>6/6s/7/8/SE2</td>\n<td>4.7 inch</td>\n<td>375*667pt</td>\n<td>750*1334px</td>\n<td>@2x</td>\n</tr>\n<tr>\n<td>6 Plus/6s Plus/7 Plus/8 Plus</td>\n<td>5.5 inch</td>\n<td>414*736pt</td>\n<td>1242 * 2208px</td>\n<td>@3x</td>\n</tr>\n<tr>\n<td>X/XS/11 Pro</td>\n<td>5.8 inch</td>\n<td>375*812pt</td>\n<td>1125* 2436px</td>\n<td>@3x</td>\n</tr>\n<tr>\n<td>XR/11</td>\n<td>6.1 inch</td>\n<td>414*896pt</td>\n<td>828* 1792px</td>\n<td>@2x</td>\n</tr>\n<tr>\n<td>XS Max/11 Pro Max</td>\n<td>6.5 inch</td>\n<td>414*896pt</td>\n<td>1242* 2688px</td>\n<td>@3x</td>\n</tr>\n<tr>\n<td>12 mini</td>\n<td>5.4 inch</td>\n<td>360*780pt</td>\n<td>1080* 2340px</td>\n<td>@3x</td>\n</tr>\n<tr>\n<td>12/12 Pro</td>\n<td>6.1 inch</td>\n<td>390*844pt</td>\n<td>1170* 2532px</td>\n<td>@3x</td>\n</tr>\n<tr>\n<td>12 Pro Max</td>\n<td>6.7 inch</td>\n<td>428*926pt</td>\n<td>1284* 2778px</td>\n<td>@3x</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p><a href=\"https://www.jianshu.com/p/507c89d456e1\">https://www.jianshu.com/p/507c89d456e1</a></p>\n<p><a href=\"https://sspai.com/post/63214\">少数派</a></p>\n<p><a href=\"https://steppark.net/15978209110755.html\">https://steppark.net/15978209110755.html</a></p>\n<p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210204201631.png\" alt=\"9e12c3bbf1674051a52734ab93f2c72d\"></p>\n<p><img src=\"https://raw.githubusercontent.com/yanqizhao/picture/main/img/20210223190349.png\" alt=\"img\"></p>\n"},{"title":"常用工具 & 网站 & 命令","date":"2021-01-11T02:32:13.000Z","_content":"\n[TOC]\n\n## Mac 常见安全与隐私问题\n\n#### 文件已损坏\n\nsudo spctl --master-disable\n\nsudo xattr -d com.apple.quarantine /Applications/xxx.app\n","source":"_posts/常用工具 & 网站 & 命令.md","raw":"---\ntitle: 常用工具 & 网站 & 命令\ndate: 2021-01-11 10:32:13\ntags:\n  - Tools\n  - 总结\ncategories:\n  - Others\n---\n\n[TOC]\n\n## Mac 常见安全与隐私问题\n\n#### 文件已损坏\n\nsudo spctl --master-disable\n\nsudo xattr -d com.apple.quarantine /Applications/xxx.app\n","slug":"常用工具 & 网站 & 命令","published":1,"updated":"2021-06-04T08:08:07.244Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqsw2n7m001l51dxhgv7bjs5","content":"<p>[TOC]</p>\n<h2 id=\"Mac-常见安全与隐私问题\"><a href=\"#Mac-常见安全与隐私问题\" class=\"headerlink\" title=\"Mac 常见安全与隐私问题\"></a>Mac 常见安全与隐私问题</h2><h4 id=\"文件已损坏\"><a href=\"#文件已损坏\" class=\"headerlink\" title=\"文件已损坏\"></a>文件已损坏</h4><p>sudo spctl –master-disable</p>\n<p>sudo xattr -d com.apple.quarantine /Applications/xxx.app</p>\n","site":{"data":{}},"excerpt":"","more":"<p>[TOC]</p>\n<h2 id=\"Mac-常见安全与隐私问题\"><a href=\"#Mac-常见安全与隐私问题\" class=\"headerlink\" title=\"Mac 常见安全与隐私问题\"></a>Mac 常见安全与隐私问题</h2><h4 id=\"文件已损坏\"><a href=\"#文件已损坏\" class=\"headerlink\" title=\"文件已损坏\"></a>文件已损坏</h4><p>sudo spctl –master-disable</p>\n<p>sudo xattr -d com.apple.quarantine /Applications/xxx.app</p>\n"},{"title":"热修复","date":"2021-01-21T03:38:25.000Z","_content":"\n\n\n[TOC]\n\n\n\n### 苹果“热修复门”事件复盘、分析和展望\n\nhttps://www.zybuluo.com/pockry/note/682139\n\n\n\n### 闲谈 iOS 的动态化\n\nhttps://zhuanlan.zhihu.com/p/25647026\n\n","source":"_posts/热修复.md","raw":"---\ntitle: 热修复\ndate: 2021-01-21 11:38:25\ntags:\n- 学习资料\n- 热修复\ncategories:\n- iOS 开发笔记\n---\n\n\n\n[TOC]\n\n\n\n### 苹果“热修复门”事件复盘、分析和展望\n\nhttps://www.zybuluo.com/pockry/note/682139\n\n\n\n### 闲谈 iOS 的动态化\n\nhttps://zhuanlan.zhihu.com/p/25647026\n\n","slug":"热修复","published":1,"updated":"2021-06-04T08:08:07.245Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqsw2n7o001o51dx37xqa8b3","content":"<p>[TOC]</p>\n<h3 id=\"苹果“热修复门”事件复盘、分析和展望\"><a href=\"#苹果“热修复门”事件复盘、分析和展望\" class=\"headerlink\" title=\"苹果“热修复门”事件复盘、分析和展望\"></a>苹果“热修复门”事件复盘、分析和展望</h3><p><a href=\"https://www.zybuluo.com/pockry/note/682139\">https://www.zybuluo.com/pockry/note/682139</a></p>\n<h3 id=\"闲谈-iOS-的动态化\"><a href=\"#闲谈-iOS-的动态化\" class=\"headerlink\" title=\"闲谈 iOS 的动态化\"></a>闲谈 iOS 的动态化</h3><p><a href=\"https://zhuanlan.zhihu.com/p/25647026\">https://zhuanlan.zhihu.com/p/25647026</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>[TOC]</p>\n<h3 id=\"苹果“热修复门”事件复盘、分析和展望\"><a href=\"#苹果“热修复门”事件复盘、分析和展望\" class=\"headerlink\" title=\"苹果“热修复门”事件复盘、分析和展望\"></a>苹果“热修复门”事件复盘、分析和展望</h3><p><a href=\"https://www.zybuluo.com/pockry/note/682139\">https://www.zybuluo.com/pockry/note/682139</a></p>\n<h3 id=\"闲谈-iOS-的动态化\"><a href=\"#闲谈-iOS-的动态化\" class=\"headerlink\" title=\"闲谈 iOS 的动态化\"></a>闲谈 iOS 的动态化</h3><p><a href=\"https://zhuanlan.zhihu.com/p/25647026\">https://zhuanlan.zhihu.com/p/25647026</a></p>\n"},{"title":"iOS 动态化","date":"2022-01-17T07:44:53.000Z","_content":"\n\n\n## 动态化目标\n\n\n\n## 动态化技术方案选型\n\n\n\n## 动态化应用\n\n\n\n### 首页 UI 动态化\n\n\n\n### 无痕埋点\n\n\n\n","source":"_posts/iOS 动态化.md","raw":"---\ntitle: iOS 动态化\ndate: 2022-01-17 15:44:53\ntags:\n- iOS\n- 动态化\ncategories:\n- iOS 开发笔记\n\n---\n\n\n\n## 动态化目标\n\n\n\n## 动态化技术方案选型\n\n\n\n## 动态化应用\n\n\n\n### 首页 UI 动态化\n\n\n\n### 无痕埋点\n\n\n\n","slug":"iOS 动态化","published":1,"updated":"2022-01-17T08:36:43.703Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4ve2euy0000y2dx7721c01k","content":"<h2 id=\"动态化目标\"><a href=\"#动态化目标\" class=\"headerlink\" title=\"动态化目标\"></a>动态化目标</h2><h2 id=\"动态化技术方案选型\"><a href=\"#动态化技术方案选型\" class=\"headerlink\" title=\"动态化技术方案选型\"></a>动态化技术方案选型</h2><h2 id=\"动态化应用\"><a href=\"#动态化应用\" class=\"headerlink\" title=\"动态化应用\"></a>动态化应用</h2><h3 id=\"首页-UI-动态化\"><a href=\"#首页-UI-动态化\" class=\"headerlink\" title=\"首页 UI 动态化\"></a>首页 UI 动态化</h3><h3 id=\"无痕埋点\"><a href=\"#无痕埋点\" class=\"headerlink\" title=\"无痕埋点\"></a>无痕埋点</h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"动态化目标\"><a href=\"#动态化目标\" class=\"headerlink\" title=\"动态化目标\"></a>动态化目标</h2><h2 id=\"动态化技术方案选型\"><a href=\"#动态化技术方案选型\" class=\"headerlink\" title=\"动态化技术方案选型\"></a>动态化技术方案选型</h2><h2 id=\"动态化应用\"><a href=\"#动态化应用\" class=\"headerlink\" title=\"动态化应用\"></a>动态化应用</h2><h3 id=\"首页-UI-动态化\"><a href=\"#首页-UI-动态化\" class=\"headerlink\" title=\"首页 UI 动态化\"></a>首页 UI 动态化</h3><h3 id=\"无痕埋点\"><a href=\"#无痕埋点\" class=\"headerlink\" title=\"无痕埋点\"></a>无痕埋点</h3>"},{"_content":"# WWDC 22 - 110352 拥抱 Swift 泛型 直译\n\n大家好，我是 holly，来自 Swift 编译组，欢迎来到拥抱 Swift 泛型。\n\n泛型是一个书写 Swift 抽象代码的基本工具，随着代码的演化发展，泛型是起到管理复杂性的关键。\n\n抽象概念可以将思想从特定的细节中分离出来，在代码中，有很多种方式(途径)可以使用泛型(泛型都起到了作用)。\n\n你可能经常使用到的一种抽象概念的形式就是将代码抽出来到一个函数或是一个本地的变量，如果你想要多次使用同一功能或同一个值时，这是非常有用的。\n\n![image-20220626130647985](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626130647985.png)\n\n当你把一个功能提取到一个函数里时，函数的细节就被抽出去(抽象化)了，而使用(调用)个抽象函数的代码，就可以表达所发生的事情，而不需要重复细节了。\n\n![image-20220626135431108](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626135431108.png)\n\n\n\n在 Swift 中，你也可以将实体类型抽象出来，如果你有一系列的类型，它们使用了相同的思想，和不同的实现细节，你就可以写抽象的代码来实现所有这些实体类型。\n\n![image-20220626135903984](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626135903984.png)\n\n今天，我们将通过模型化实体类型、确定一系列实体类型的通用能力、构建一个接口来表达(呈现)这些能力、深入了解如何使用这些接口来实现泛型的书写的步骤来向你展示泛型的具体使用场景。\n\n![image-20220626140259410](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626140259410.png)\n\n\n\n我们将通过构建一些代码来模拟一个农场的形式，一起探索 Swift 抽象工具的使用。\n\n![image-20220626140636740](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626140636740.png)\n\n\n\n让我们先来写几个实体类型吧。\n\n首先创建一个叫做 Cow 的结构体，它有一个方法叫做 eat(food:)，接收一个 Hay 类型的参数。\n\nHay 是另一个结构体，它有一个静态方法叫做 grow() -> Alfalfa，可以种植一些能够长出 Hay 的庄稼 Alfalfa。\n\nAlfalfa 结构体有一个方法 harvest() -> Hay 通过 Alfalfa 实例来收获 Hay。\n\n最后，我们抽象出一个农场 Farm，它有一个方法 feed(animal:) 可以喂养奶牛。\n\nfeed(animal:) 方法可以通过首先种一些苜蓿 Alfalfa 来生产干草 Hay，然后收获干草 Hay ，最后用干草 Hay 来喂养奶牛 Cow 的方式实现。\n\n这时，我就能在我的农场来饲养奶牛了。\n\n![image-20220626141648138](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626141648138.png)\n\n\n\n但是我想饲养更多的动物。\n\n![image-20220626141850288](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626141850288.png)\n\n我可以添加更多的结构体来代表其他的动物，就像 Horse 马和 Chicken 鸡。\n\n![image-20220626141938986](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626141938986.png)\n\n我想在农场上饲养奶牛，马，鸡。\n\n![image-20220626142052720](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626142052720.png)\n\n我可以重载这个 feed(animal:) 方法分别来接收不同类型的参数，但是每个重载函数都会有一个相当类似的实现。\n\n![image-20220626142240499](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626142240499.png)\n\n![image-20220626142527042](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626142527042.png)\n\n当我添加更多的动物类型时，这将造成类似代码的堆积，基本上到处都是重复的代码。\n\n当你发现自己写的重载代码有重复的实现时，就是概括归纳(抽象、重构)的预兆了。\n\n基本上说，这些实现都很类似，因为(饲养)不同类型的动物在功能(喂养)上是相似的。\n\n\n\n第二步，就是来确定动物类型的通用能力了。\n\n我们已经构建了一系列动物类型了，它们都有一个能力，吃某一种食物。\n\n每种类型的动物都有不同的进食方式，所以每个动物的 eat(food:) 方法都有不同的行为表现。\n\n![image-20220626143435094](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626143435094.png)\n\n我们要做的就是允许抽象代码调用 eat(food:) 方法的同时，让这些抽象代码在 eat(food:) 方法中的行为表现不同，这取决于抽象代码所执行在的实体的具体类型。\n\n抽象代码在不同的实体类型上可以表现不同能力的功能叫做多态，多态允许一份代码拥有多种行为表现，取决于代码是被如何使用的。\n\n更恰当地说的话，多态本身就是不同形式的。\n\n首先是函数的重载，根据传入参数类型的不同，同样的函数调用可以意味着不同的事物。重载被称为 ad-hoc(临时安排的、特别的、专门的) 多态，因为它并不是一个通用的解决方案。我们只能看到重载是如何一步步走向重复代码的。\n\n下一步，是子类多态。代码在一个超类上去执行调用，实际上却会在运行时基于特定的子类而产生不同的表现。\n\n最后是使用泛型来实现的确定(指定)参数的多态。\n\n![image-20220628195408677](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220628195408677.png)\n\n\n\n泛型代码使用类型参数，来允许书写一份代码与不同类型一起奏效(工作、运行)。而实体类型呢，则将作为实参进行传递。\n\n我们早就已经把重载排除出局了，所以让我们尝试使用子类多态吧。\n\n代表子类关系的一种方式是使用类型层级。我们可以引入一个类型叫做 Animal 动物。\n\n![image-20220626145345481](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626145345481.png)\n\n然后，我们将每种动物类型从结构体更改为类。\n\n![image-20220626145445564](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626145445564.png)\n\n每个具体的动物类都继承自 Animal 动物这个超类并且重写 eat(food:) 方法。\n\n![image-20220626145552753](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626145552753.png)\n\n现在，我们有一个抽象的基类 Animal 动物，可以代表我们每一个具体的动物类型。调用 Animal 动物的 eat(food:) 方法将会使用子类多态而调用到子类的具体实现，但这样还没完。\n\n我们仍然没有补全 Animal 动物 eat(:food) 方法的参数类型，这份代码还有一些报错。\n\n首先，使用类将强制我们使用引用类型，即使我们并不需要分享不同实例间的任何状态。这个策略也需要子类去重写基类中的方法。但是忘记重写基类方法只有在运行时才会被捕获。\n\n但是对这个模型抽象的过程中更大的问题是每种子类动物都会食用不同类型的食物，这种依赖用类型层级相当难以表达。\n\n一种方式是让 eat(food:) 方法中食物的参数接收一个不具体(明确)的类型， 例如 Any。\n\n![image-20220626150733935](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626150733935.png)\n\n但是这种策略在子类实现中，仍然需要在运行时确定好准确的类型并传入，在每个重写的方法中又一次出现了代码堆积。\n\n![image-20220626150958877](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626150958877.png)\n\n但是更重要的是，这份代码允许你不小心传入一个错误的食物类型，造成另一个只能在运行时才捕获的 bug。我们再试试别的方法吧。\n\n\n\n我们可以通过在超类 Animal 动物类上引入一种类型安全的参数类型的方式，来替代表达喂养动物所用食物的类型。\n\n![image-20220626151650552](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626151650552.png)\n\n这种类型参数对每一个子类的食物喂养类型使用一个占位符，通过这种方式，Food 参数的类型必须被提升到 Animal 类的声明中才行。\n\n![image-20220626152712935](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626152712935.png)\n\n这看起来有点诡异，因为尽管动物需要食物来填饱肚子，但是进食并不是动物的主要目标，很多与动物相关的代码也许根本不关心它们吃什么食物。尽管如此，所有对 Animal 类的引用都需要指明 Food 的类型。\n\n举个例子，每个 Animal 的子类都需要在继承的代码中用尖括号内明确指出它的食物类型，如果我们添加更多需要明确指定的类型给 Animal，这种代码模板在每个使用 Animal 类的地方都将变得非常繁琐。\n\n![image-20220626153746315](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626153746315.png)\n\n所以我们上述的两种方式既低效，又不能正确地表达语义。\n\n根本问题是，类是一种数据类型，我们却想要尝试复杂化一个超类，然后让它代表实体类型的抽象思想。\n\n取而代之的是，我们想要构建一个能够代表类型的能力，但不需要这个能力实现的细节。\n\n动物有两个常见的能力，每种动物都有一种具体的食物类型，和一种进食方式。\n\n我们可以构建一种接口来代表这两种能力。\n\n在 Swift 中，使用协议来实现这种功能。\n\n协议是一种抽象工具，描述了遵循它协议的类型的功能。使用协议，你可以把一个类所做的事情的构思与其具体的实现区分开来。一个类所做的事情的构思用接口来表达。\n\n让我们将动物的能力使用协议接口来翻译一下。\n\n协议的名称代表我们所描述的这种类型的分类，所以我管这个协议叫“Animal 动物”。\n\n每个能力都将映射到一个协议的必备条件上。\n\n食物的具体类型将会映射为一个关联类型，就像类型参数一样，关联类型也是作为实体类型的占位符。\n\n![image-20220626160017654](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626160017654.png)\n\n关联类型的特别之处在于，它取决于遵循协议的那个类的具体类型，这层关系是有保障的。所以具体动物类的每个实例都有相同的食物类型。\n\n接下来，进食的行为将会映射为一个方法。这个方法叫做 eat(food:)，它接收一个参数，喂养动物的类型。\n\n![image-20220626160729154](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626160729154.png)\n\n协议中并没有这个方法的实现，实体动物类型被要求去实现它。\n\n现在，我们有一个动物协议，我们可以让每个实体类都遵循它。\n\n你可以对一个实体类进行标记，在它的声明或者扩展中，代表它遵循了一个协议。\n\n![image-20220626162949349](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626162949349.png)\n\n协议并不仅限于类去遵循，我们也可以对结构体、枚举和 actors 使用协议。\n\n当你写下这个协议遵循的标注，编译器将会检查实体类是否实现了协议中要求的必要条件。\n\n每个动物类都必须实现 eat(food:) 这个方法，编译器可以推断出喂养所需食物的类型，因为它在参数列表中已经被使用(描述)过了。\n\nFeed 也可以通过类型别名明确的写出。\n\n\n\n我们成功地确定了动物的通用能力，并且使用协议表达了这些能力。现在，我们可以开始书写泛型代码了。\n\n我们可以使用动物协议来实现农场的 feed(animal:) 方法，我们想写一种实现，可以对所有的动物实体类型都通用。\n\n我们使用确定参数的多态，并且引入一个类型参数将会在方法被调用的时候替换为实体类型。\n\n类型参数是用尖括号包裹写在函数名称后面的，就像通常的变量和函数参数那样，你可以随意给参数类型命名。\n\n并且就像任何其他的类型那样，你可以在函数体内使用类型参数的名称引用这个类型参数。\n\n这里我声明了一个类型参数 A，并且使用 A 作为函数参数动物的类型。\n\n![image-20220626164416814](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626164416814.png)\n\n我们总是希望实体动物类型遵循动物协议，所以在 A 之后声明其遵循 Animal 协议。\n\n![image-20220626165033294](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626165033294.png)\n\n协议遵循可以写在尖括号里，也可以在最后使用 where 语句声明，在这里你还可以指明不同参数类型之间的关系。\n\n![image-20220626165151422](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626165151422.png)\n\n命名类型参数和在结尾写 wehre 语句是非常有力量的，因为它允许你写出复杂的必要条件与类型关系。但是大多数的泛型函数不需要这样的通用性。\n\n让我们把焦点放在 feed(animal:) 方法上。\n\n类型参数 A 在参数列表中出现过一次，而 where 语句罗列出了类型参数必要条件的遵循情况。\n\n在这种情况下，命名类型参数和使用 where 语句让这个方法看起来过于复杂。\n\n![image-20220626165501956](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626165501956.png)\n\n这种泛型样式是相当常见的，所以有更简单的方式表达它。\n\n不再明确写出类型参数，我们可以就协议的遵循情况通过写成 some Animal 来表达这个抽象类型，这种声明方式跟前面的是等价的，但是那些不必要的参数列表和 where 语句都消失了，因为我们并不需要它们所提供的这种表达形式，使用 some Animal 更加直接。因为它减少了语法干扰，还在参数声明的右边包含了关于动物参数的语义信息。\n\n![image-20220626170002361](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626170002361.png)\n\n让我们看看 some Animal 的语法。\n\nsome 暗示这里有一个具体的类型，some 之后总是会跟着一个要遵循的协议。\n\n在这个场景里，具体的类型必须遵循 Animal 协议，这允许我们在参数值上使用 Animal 协议中的必要条件(这允许我们对这个参数调用 Animal 协议中声明的方法)。\n\nsome 关键字可以在参数和返回值的类型中使用，如果你之前写过 SwiftUI 代码，你早就用过 some 在返回值的位置使用 some View。\n\n返回值的类型 some View 跟这里恰恰是完全相同的概念。在 SwiftUI 的视图中，body 属性返回某个具体类型的视图，但是使用 body 属性的代码并不需要知道这个具体的类型是什么。\n\n![image-20220626170932734](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626170932734.png)\n\n让我们返回回去更好的理解一下一个具体抽象类型的概念。\n\n一个抽象类型代表一个具体的实体类型的占位符叫做“不透明类型”。\n\n被替换的具体的实体类型类型叫做(underlying)基本类型，对于不透明类型的值，在值的使用范围内，基本类型是固定的。\n\n这样，泛型代码使用的值就被保证了值每次被访问的时候，都会获取到相同的基本类型。\n\n使用 some 关键字的类型，和一个用尖括号命名的类型参数，都声明了一个不透明类型。\n\n![image-20220626173329398](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626173329398.png)\n\n不透明类型在输入输出中都可以使用，所以它们可以声明在参数的位置，或是返回值的位置。\n\n![image-20220626173435799](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626173435799.png)\n\n函数的箭头将这两个位置分为两部分。\n\n![image-20220626173940091](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626173940091.png)\n\n不透明类型的位置决定了程序的哪个部分可以看到抽象类型，以及程序的哪个部分决定实体类型。\n\n命名类型参数总是声明在输入侧，所以调用者决定了基本类型，而实现使用了抽象类型。\n\n![image-20220626174210668](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626174210668.png)\n\n通常情况下，提供不透明类型参数或返回值类型的那部分程序，决定了基本类型；而使用这个值的那部分程序可以看到抽象类型。\n\n\n\n让我们深入了解一下这是怎么运转起来的。跟着我们对参数和返回值的直觉走。\n\n因为基本类型是通过一个值推断出来的，基本类型总是跟值一起出现在相同的位置。\n\n对于一个本地变量来说，基本类型是通过右边的赋值操作推断出来的，这意味着有着不透明类型的本地变量总是需要一个初始值。\n\n![image-20220626174951554](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626174951554.png)\n\n如果你不给提供初始值，编译器将会报错。\n\n![image-20220626175035323](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175035323.png)\n\n基本类型必须在变量的使用范围内被固定，所以对基本类型进行修改的尝试也会得出一个错误的结果。\n\n![image-20220626175134539](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175134539.png)\n\n对于使用不透明类型的参数来说，基本类型是在被调用的位置传入的实参值推断出来的。\n\n![image-20220626175314696](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175314696.png)\n\n在参数位置使用 some 是 Swift 5.7 新增的功能。\n\n![image-20220626175447382](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175447382.png)\n\n基本类型只需要在参数的使用范围内被固定，所以每次调用都可以提供一个类型不同的参数。\n\n![image-20220626175640411](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175640411.png)\n\n对不透明类型的返回值来说，基本类型是在函数实现中的返回值的位置进行推断的。\n\n![image-20220626180718256](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626180718256.png)\n\n有不透明类型返回值的方法或者计算属性，可以在程序的任何位置被调用，所以这个值的可用范围是全局的。这意味着，返回值的基本类型需要在所有的返回语句中保持一致。如果没有保持一致，编译器将会报错，基本类型返回值的类型不匹配。\n\n![image-20220626181045890](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626181045890.png)\n\n对于不透明类型的 SwiftUI View，ViewBuilder DSL 可以将控制流语句的每个分支都转换成拥有相同基本类型的返回值。\n\n所以在这个场景下，我们可以使用 ViewBuilder DSL 来解决这个问题。在方法前写一个修饰符 @ViewBuilder，并且移除掉 return 语句，将会允许通过 ViewBuilder 的类型来为我们构建返回值类型。\n\n![image-20220626181303429](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626181303429.png)\n\n让我们回到 feedAnimal 方法吧。\n\n我将会使用 some 在参数列表中，因为我并不需要在其他位置引用这个参数类型。当你需要多次引用这个不透明类型时，也就是说类型参数在手边。\n\n![image-20220626181701328](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626181701328.png)\n\n举个例子，当我们给 Animal 协议添加另外一个关联值，Habitat。\n\n![image-20220626181844443](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626181844443.png)\n\n我们也许想要在农场上为某个指定的动物构建一个栖息地，这个场景下，返回值类型就依赖于这个具体的动物的类型了，所以我们需要用类型参数 A 作为参数的类型，和返回值类型。\n\n![image-20220626183735613](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626183735613.png)\n\n另一个常你需要多次使用不透明类型的见的地方，是在泛型中。代码通常在泛型类型上声明一个类型参数，给一个存储属性使用类型参数，或者给一个成员构造器传递参数。\n\n![image-20220626184243060](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626184243060.png)\n\n在不同的上下文中引用泛型类型，也需要你用尖括号明确指出类型参数。在声明中的尖括号里的泛型可以帮助阐明如何使用一个泛型类型，所以不透明类型必须总是被命名为泛型类型。\n\n![image-20220626190535609](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626190535609.png)\n\n现在，让我们一起构造出 feed 方法的实现吧。\n\n\n\n我们可以使用动物参数的类型来访问种植的庄稼类型，通过 Feed 的关联类型。我们调用 Feed.grow() 来获取庄稼实例，这个庄稼可以产出要用来喂动物进食的类型的食物。\n\n![image-20220626190910250](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626190910250.png)\n\n接下来，我们需要收割庄稼的产出，可以通过调用庄稼的一个方法 harvest()\n\n![image-20220626191404371](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626191404371.png)\n\n最后我们可以把产出的食物喂给动物吃，因为基本的动物类型是固定的，编译器知道植物类型与产出食物类型，以及在多个方法之间调用的动物类型之间的关系。\n\n![image-20220626191534121](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626191534121.png)\n\n这些静态的关系阻止我们给动物喂错食物。\n\n如果我们尝试使用没有被保证可以为这个动物喂养的食物类型，编译器就会告诉我们。\n\n![image-20220626191900776](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626191900776.png)\n\n想要学习其他的农场协议是如何定义，并用来表达喂养动物的类型和它的植物之间关系的，请参考 110353\n\n![image-20220626193714763](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626193714763.png)\n\n最后，让我们添加一个 feedAll(animals:) 方法，接收一个数组作为参数，我知道元素类型需要遵循 Animal 协议，但是我希望这个数组可以存储不同类型的动物。\n\n![image-20220626202924050](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626202924050.png)\n\n让我们看看这里用不透明类型 some Animal 是否可行。\n\n![image-20220626203030188](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626203030188.png)\n\n使用 some，这里有一个具体的基本类型不能发生改变，因为基本类型是固定的，数组中所有的元素都必须是相同的类型，所以，用 some Animal 描述数组元素的类型并不能准确表达我们的意图。因为我想要一个可以存储不同类型元素的数组。\n\n![image-20220626203102314](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626203102314.png)\n\n这里，我们需要一个可以代表任何动物的超类，我们可以使用 any Animal 来表示任意类型的动物。\n\n![image-20220626203544327](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626203544327.png)\n\nany 关键字表明这个类型可以存储任意类型的动物，基本类型在运行时也可以改变。\n\n就像 some 关键字那样，any 关键字后也跟随着一个要遵循的协议，任何动物都是一个单一的静态类型，拥有动态存储任意动物实体类型的能力。这个能力允许我们对值类型使用子类多态。为了允许这个灵活的存储，any Animal 在内存中有一个特殊的表达。\n\n你可以把这种表达形式想成一个盒子，有时候，值能够直接装进盒子。\n\n![image-20220626204305609](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626204305609.png)\n\n另外一些值太大了盒子装不下，\n\n![image-20220626204414695](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626204414695.png)\n\n所以值需要在其他位置分配内存空间，盒子只是用一个指针指向这个空间。\n\n![image-20220626204442868](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626204442868.png)\n\nany Animal 这个静态类型可以动态存储任何实体类型这种行为被正式的成为存在主义类型。\n\n![image-20220626204819602](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626204819602.png)\n\n对不同实体类型使用相同表达的策略叫做类型擦除。\n\n在编译时，实体类型的类型被擦除，直到运行时才被体现出来。\n\n存在类型 any Animal 的这两个实例，有相同的静态类型，但是不同的动态类型。\n\n类型擦除消除了不同动物在类型级别的区别，这允许我们使用静态类型相同但动态类型不同的值。\n\n![image-20220626205158501](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626205158501.png)\n\n我们可以使用类型擦除来书写一个异源值类型数组，这正是我们在 feedAll(animals:) 方法中所需要的。\n\n![image-20220626205642059](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626205642059.png)\n\n所以我们使用一个数组，用 any Animal 作为参数的类型，对协议使用 any 关键字和关联类型是 Swift 5.7 新增的功能。\n\n为了实现 feedAll(animals:) 方法，我们首先遍历这个 animals 数组。\n\n![image-20220626205904465](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626205904465.png)\n\n对于每个动物，我们都想调用 Animal 协议中的 eat(food:) 方法。\n\n![image-20220626210014893](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626210014893.png)\n\n为了调用这个方法，在这次遍历中，我们需要获取到具体的基本类型 Feed 的类型。\n\n![image-20220626210159916](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626210159916.png)\n\n但是一旦我们对 any Animal 调用 eat(food:) 方法，我们将会得到一个编译错误。\n\n![image-20220626210358657](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626210358657.png)\n\n因为我们消除了具体动物类型在编译时类型级别的区别，我们也消除了所有类型之间的关系，这些关系本身是依赖于具体的动物类型的，也包括关联类型。\n\n所以我们不知道这个类型的动物希望被喂什么类型的食物。为了能够依赖这些类型之间的关系，我们需要回到之前动物的具体类型仍然固定的上下文，不再直接对 any Animal 调用 eat(food:) 方法，我们需要调用可以接收 some Animal 的 feed 方法。\n\n![image-20220626211117177](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626211117177.png)\n\nany Animal 跟 some Animal 是不同的，但是编译器可以通过“拆包”基本类型值的方式将 any Animal 的实例转换为 some Animal，并且把它直接传给 some Animal 参数。\n\n这个“拆包”实参的能力是 Swift 5. 7 新增的。\n\n![image-20220626211430157](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626211430157.png)\n\n你可以把拆包看作是编译器打开了盒子并取出了存在其中的值。\n\nsome Animal 参数的使用范围内，这个值都有一个固定的基本类型。所以我们可以访问所有对基本类型的操作，包括访问关联类型。\n\n这真的很酷，因为它允许我们在需要的时候选择灵活存储，同时也可以回到之前的拥有函数体内可使用范围的固定基本类型的静态类型系统完整表达的上下文。\n\n大多数情况下，你并不需要去考虑拆包，因为它就是按照你期待的方式工作的，与对 any Animal 调用协议方法类似，就是对基本类型调用这个方法。\n\n所以我们可以对每个动物都调用 feed(animal:) 方法，在那里，每次遍历我们都可以种植并且收割合适的庄稼来喂养具体的动物。\n\n![image-20220626215127833](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626215127833.png)\n\n在这个过程中，我们看到了 some 和 any 不同的能力。\n\n使用 some，基本类型就是固定的，这允许你在泛型代码中依赖于固定类型之间的关系，所以你有对 API 和协议关联类型的完整的访问权限。\n\n使用 any，当你需要存储任意实体类型时，any 提供了类型擦除，允许你表达异源集合，表达基本类型的缺席，使用可选项，同时抽象实现细节。\n\n![image-20220626215828321](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626215828321.png)\n\n总而言之，默认情况下使用 some，当你想要存储任意类型的值时，将 some 改为 any。\n\n使用这种方式，只在你需要存储灵活性时，付出类型擦除和语义限制的代价即可。\n\n这个工作流程与默认书写 let 表示常量，直到你需要变量时类似。\n\n在这个视频中，我们想要通过这个工作流程随着代码的演进来生成代码并且获得更多的功能。\n\n\n\n我们从实体类型开始，随着代码获得更多的功能，我们发觉在不同的类型中的代码重复。从这里开始，我们确定了通用的能力，并且使用协议生成了这些能力，最后我们用 some 和 any 写了抽象代码，并且讨论了我们倾向于使用 some 来书写更具有表达性的代码。\n\n想要更深入的构建协议和理解类型擦除，可以看 110353。\n\n![image-20220626220750663](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626220750663.png)","source":"_drafts/WWDC 22 - 110352 拥抱 Swift 泛型 直译.md","raw":"# WWDC 22 - 110352 拥抱 Swift 泛型 直译\n\n大家好，我是 holly，来自 Swift 编译组，欢迎来到拥抱 Swift 泛型。\n\n泛型是一个书写 Swift 抽象代码的基本工具，随着代码的演化发展，泛型是起到管理复杂性的关键。\n\n抽象概念可以将思想从特定的细节中分离出来，在代码中，有很多种方式(途径)可以使用泛型(泛型都起到了作用)。\n\n你可能经常使用到的一种抽象概念的形式就是将代码抽出来到一个函数或是一个本地的变量，如果你想要多次使用同一功能或同一个值时，这是非常有用的。\n\n![image-20220626130647985](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626130647985.png)\n\n当你把一个功能提取到一个函数里时，函数的细节就被抽出去(抽象化)了，而使用(调用)个抽象函数的代码，就可以表达所发生的事情，而不需要重复细节了。\n\n![image-20220626135431108](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626135431108.png)\n\n\n\n在 Swift 中，你也可以将实体类型抽象出来，如果你有一系列的类型，它们使用了相同的思想，和不同的实现细节，你就可以写抽象的代码来实现所有这些实体类型。\n\n![image-20220626135903984](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626135903984.png)\n\n今天，我们将通过模型化实体类型、确定一系列实体类型的通用能力、构建一个接口来表达(呈现)这些能力、深入了解如何使用这些接口来实现泛型的书写的步骤来向你展示泛型的具体使用场景。\n\n![image-20220626140259410](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626140259410.png)\n\n\n\n我们将通过构建一些代码来模拟一个农场的形式，一起探索 Swift 抽象工具的使用。\n\n![image-20220626140636740](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626140636740.png)\n\n\n\n让我们先来写几个实体类型吧。\n\n首先创建一个叫做 Cow 的结构体，它有一个方法叫做 eat(food:)，接收一个 Hay 类型的参数。\n\nHay 是另一个结构体，它有一个静态方法叫做 grow() -> Alfalfa，可以种植一些能够长出 Hay 的庄稼 Alfalfa。\n\nAlfalfa 结构体有一个方法 harvest() -> Hay 通过 Alfalfa 实例来收获 Hay。\n\n最后，我们抽象出一个农场 Farm，它有一个方法 feed(animal:) 可以喂养奶牛。\n\nfeed(animal:) 方法可以通过首先种一些苜蓿 Alfalfa 来生产干草 Hay，然后收获干草 Hay ，最后用干草 Hay 来喂养奶牛 Cow 的方式实现。\n\n这时，我就能在我的农场来饲养奶牛了。\n\n![image-20220626141648138](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626141648138.png)\n\n\n\n但是我想饲养更多的动物。\n\n![image-20220626141850288](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626141850288.png)\n\n我可以添加更多的结构体来代表其他的动物，就像 Horse 马和 Chicken 鸡。\n\n![image-20220626141938986](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626141938986.png)\n\n我想在农场上饲养奶牛，马，鸡。\n\n![image-20220626142052720](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626142052720.png)\n\n我可以重载这个 feed(animal:) 方法分别来接收不同类型的参数，但是每个重载函数都会有一个相当类似的实现。\n\n![image-20220626142240499](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626142240499.png)\n\n![image-20220626142527042](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626142527042.png)\n\n当我添加更多的动物类型时，这将造成类似代码的堆积，基本上到处都是重复的代码。\n\n当你发现自己写的重载代码有重复的实现时，就是概括归纳(抽象、重构)的预兆了。\n\n基本上说，这些实现都很类似，因为(饲养)不同类型的动物在功能(喂养)上是相似的。\n\n\n\n第二步，就是来确定动物类型的通用能力了。\n\n我们已经构建了一系列动物类型了，它们都有一个能力，吃某一种食物。\n\n每种类型的动物都有不同的进食方式，所以每个动物的 eat(food:) 方法都有不同的行为表现。\n\n![image-20220626143435094](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626143435094.png)\n\n我们要做的就是允许抽象代码调用 eat(food:) 方法的同时，让这些抽象代码在 eat(food:) 方法中的行为表现不同，这取决于抽象代码所执行在的实体的具体类型。\n\n抽象代码在不同的实体类型上可以表现不同能力的功能叫做多态，多态允许一份代码拥有多种行为表现，取决于代码是被如何使用的。\n\n更恰当地说的话，多态本身就是不同形式的。\n\n首先是函数的重载，根据传入参数类型的不同，同样的函数调用可以意味着不同的事物。重载被称为 ad-hoc(临时安排的、特别的、专门的) 多态，因为它并不是一个通用的解决方案。我们只能看到重载是如何一步步走向重复代码的。\n\n下一步，是子类多态。代码在一个超类上去执行调用，实际上却会在运行时基于特定的子类而产生不同的表现。\n\n最后是使用泛型来实现的确定(指定)参数的多态。\n\n![image-20220628195408677](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220628195408677.png)\n\n\n\n泛型代码使用类型参数，来允许书写一份代码与不同类型一起奏效(工作、运行)。而实体类型呢，则将作为实参进行传递。\n\n我们早就已经把重载排除出局了，所以让我们尝试使用子类多态吧。\n\n代表子类关系的一种方式是使用类型层级。我们可以引入一个类型叫做 Animal 动物。\n\n![image-20220626145345481](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626145345481.png)\n\n然后，我们将每种动物类型从结构体更改为类。\n\n![image-20220626145445564](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626145445564.png)\n\n每个具体的动物类都继承自 Animal 动物这个超类并且重写 eat(food:) 方法。\n\n![image-20220626145552753](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626145552753.png)\n\n现在，我们有一个抽象的基类 Animal 动物，可以代表我们每一个具体的动物类型。调用 Animal 动物的 eat(food:) 方法将会使用子类多态而调用到子类的具体实现，但这样还没完。\n\n我们仍然没有补全 Animal 动物 eat(:food) 方法的参数类型，这份代码还有一些报错。\n\n首先，使用类将强制我们使用引用类型，即使我们并不需要分享不同实例间的任何状态。这个策略也需要子类去重写基类中的方法。但是忘记重写基类方法只有在运行时才会被捕获。\n\n但是对这个模型抽象的过程中更大的问题是每种子类动物都会食用不同类型的食物，这种依赖用类型层级相当难以表达。\n\n一种方式是让 eat(food:) 方法中食物的参数接收一个不具体(明确)的类型， 例如 Any。\n\n![image-20220626150733935](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626150733935.png)\n\n但是这种策略在子类实现中，仍然需要在运行时确定好准确的类型并传入，在每个重写的方法中又一次出现了代码堆积。\n\n![image-20220626150958877](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626150958877.png)\n\n但是更重要的是，这份代码允许你不小心传入一个错误的食物类型，造成另一个只能在运行时才捕获的 bug。我们再试试别的方法吧。\n\n\n\n我们可以通过在超类 Animal 动物类上引入一种类型安全的参数类型的方式，来替代表达喂养动物所用食物的类型。\n\n![image-20220626151650552](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626151650552.png)\n\n这种类型参数对每一个子类的食物喂养类型使用一个占位符，通过这种方式，Food 参数的类型必须被提升到 Animal 类的声明中才行。\n\n![image-20220626152712935](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626152712935.png)\n\n这看起来有点诡异，因为尽管动物需要食物来填饱肚子，但是进食并不是动物的主要目标，很多与动物相关的代码也许根本不关心它们吃什么食物。尽管如此，所有对 Animal 类的引用都需要指明 Food 的类型。\n\n举个例子，每个 Animal 的子类都需要在继承的代码中用尖括号内明确指出它的食物类型，如果我们添加更多需要明确指定的类型给 Animal，这种代码模板在每个使用 Animal 类的地方都将变得非常繁琐。\n\n![image-20220626153746315](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626153746315.png)\n\n所以我们上述的两种方式既低效，又不能正确地表达语义。\n\n根本问题是，类是一种数据类型，我们却想要尝试复杂化一个超类，然后让它代表实体类型的抽象思想。\n\n取而代之的是，我们想要构建一个能够代表类型的能力，但不需要这个能力实现的细节。\n\n动物有两个常见的能力，每种动物都有一种具体的食物类型，和一种进食方式。\n\n我们可以构建一种接口来代表这两种能力。\n\n在 Swift 中，使用协议来实现这种功能。\n\n协议是一种抽象工具，描述了遵循它协议的类型的功能。使用协议，你可以把一个类所做的事情的构思与其具体的实现区分开来。一个类所做的事情的构思用接口来表达。\n\n让我们将动物的能力使用协议接口来翻译一下。\n\n协议的名称代表我们所描述的这种类型的分类，所以我管这个协议叫“Animal 动物”。\n\n每个能力都将映射到一个协议的必备条件上。\n\n食物的具体类型将会映射为一个关联类型，就像类型参数一样，关联类型也是作为实体类型的占位符。\n\n![image-20220626160017654](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626160017654.png)\n\n关联类型的特别之处在于，它取决于遵循协议的那个类的具体类型，这层关系是有保障的。所以具体动物类的每个实例都有相同的食物类型。\n\n接下来，进食的行为将会映射为一个方法。这个方法叫做 eat(food:)，它接收一个参数，喂养动物的类型。\n\n![image-20220626160729154](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626160729154.png)\n\n协议中并没有这个方法的实现，实体动物类型被要求去实现它。\n\n现在，我们有一个动物协议，我们可以让每个实体类都遵循它。\n\n你可以对一个实体类进行标记，在它的声明或者扩展中，代表它遵循了一个协议。\n\n![image-20220626162949349](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626162949349.png)\n\n协议并不仅限于类去遵循，我们也可以对结构体、枚举和 actors 使用协议。\n\n当你写下这个协议遵循的标注，编译器将会检查实体类是否实现了协议中要求的必要条件。\n\n每个动物类都必须实现 eat(food:) 这个方法，编译器可以推断出喂养所需食物的类型，因为它在参数列表中已经被使用(描述)过了。\n\nFeed 也可以通过类型别名明确的写出。\n\n\n\n我们成功地确定了动物的通用能力，并且使用协议表达了这些能力。现在，我们可以开始书写泛型代码了。\n\n我们可以使用动物协议来实现农场的 feed(animal:) 方法，我们想写一种实现，可以对所有的动物实体类型都通用。\n\n我们使用确定参数的多态，并且引入一个类型参数将会在方法被调用的时候替换为实体类型。\n\n类型参数是用尖括号包裹写在函数名称后面的，就像通常的变量和函数参数那样，你可以随意给参数类型命名。\n\n并且就像任何其他的类型那样，你可以在函数体内使用类型参数的名称引用这个类型参数。\n\n这里我声明了一个类型参数 A，并且使用 A 作为函数参数动物的类型。\n\n![image-20220626164416814](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626164416814.png)\n\n我们总是希望实体动物类型遵循动物协议，所以在 A 之后声明其遵循 Animal 协议。\n\n![image-20220626165033294](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626165033294.png)\n\n协议遵循可以写在尖括号里，也可以在最后使用 where 语句声明，在这里你还可以指明不同参数类型之间的关系。\n\n![image-20220626165151422](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626165151422.png)\n\n命名类型参数和在结尾写 wehre 语句是非常有力量的，因为它允许你写出复杂的必要条件与类型关系。但是大多数的泛型函数不需要这样的通用性。\n\n让我们把焦点放在 feed(animal:) 方法上。\n\n类型参数 A 在参数列表中出现过一次，而 where 语句罗列出了类型参数必要条件的遵循情况。\n\n在这种情况下，命名类型参数和使用 where 语句让这个方法看起来过于复杂。\n\n![image-20220626165501956](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626165501956.png)\n\n这种泛型样式是相当常见的，所以有更简单的方式表达它。\n\n不再明确写出类型参数，我们可以就协议的遵循情况通过写成 some Animal 来表达这个抽象类型，这种声明方式跟前面的是等价的，但是那些不必要的参数列表和 where 语句都消失了，因为我们并不需要它们所提供的这种表达形式，使用 some Animal 更加直接。因为它减少了语法干扰，还在参数声明的右边包含了关于动物参数的语义信息。\n\n![image-20220626170002361](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626170002361.png)\n\n让我们看看 some Animal 的语法。\n\nsome 暗示这里有一个具体的类型，some 之后总是会跟着一个要遵循的协议。\n\n在这个场景里，具体的类型必须遵循 Animal 协议，这允许我们在参数值上使用 Animal 协议中的必要条件(这允许我们对这个参数调用 Animal 协议中声明的方法)。\n\nsome 关键字可以在参数和返回值的类型中使用，如果你之前写过 SwiftUI 代码，你早就用过 some 在返回值的位置使用 some View。\n\n返回值的类型 some View 跟这里恰恰是完全相同的概念。在 SwiftUI 的视图中，body 属性返回某个具体类型的视图，但是使用 body 属性的代码并不需要知道这个具体的类型是什么。\n\n![image-20220626170932734](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626170932734.png)\n\n让我们返回回去更好的理解一下一个具体抽象类型的概念。\n\n一个抽象类型代表一个具体的实体类型的占位符叫做“不透明类型”。\n\n被替换的具体的实体类型类型叫做(underlying)基本类型，对于不透明类型的值，在值的使用范围内，基本类型是固定的。\n\n这样，泛型代码使用的值就被保证了值每次被访问的时候，都会获取到相同的基本类型。\n\n使用 some 关键字的类型，和一个用尖括号命名的类型参数，都声明了一个不透明类型。\n\n![image-20220626173329398](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626173329398.png)\n\n不透明类型在输入输出中都可以使用，所以它们可以声明在参数的位置，或是返回值的位置。\n\n![image-20220626173435799](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626173435799.png)\n\n函数的箭头将这两个位置分为两部分。\n\n![image-20220626173940091](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626173940091.png)\n\n不透明类型的位置决定了程序的哪个部分可以看到抽象类型，以及程序的哪个部分决定实体类型。\n\n命名类型参数总是声明在输入侧，所以调用者决定了基本类型，而实现使用了抽象类型。\n\n![image-20220626174210668](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626174210668.png)\n\n通常情况下，提供不透明类型参数或返回值类型的那部分程序，决定了基本类型；而使用这个值的那部分程序可以看到抽象类型。\n\n\n\n让我们深入了解一下这是怎么运转起来的。跟着我们对参数和返回值的直觉走。\n\n因为基本类型是通过一个值推断出来的，基本类型总是跟值一起出现在相同的位置。\n\n对于一个本地变量来说，基本类型是通过右边的赋值操作推断出来的，这意味着有着不透明类型的本地变量总是需要一个初始值。\n\n![image-20220626174951554](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626174951554.png)\n\n如果你不给提供初始值，编译器将会报错。\n\n![image-20220626175035323](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175035323.png)\n\n基本类型必须在变量的使用范围内被固定，所以对基本类型进行修改的尝试也会得出一个错误的结果。\n\n![image-20220626175134539](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175134539.png)\n\n对于使用不透明类型的参数来说，基本类型是在被调用的位置传入的实参值推断出来的。\n\n![image-20220626175314696](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175314696.png)\n\n在参数位置使用 some 是 Swift 5.7 新增的功能。\n\n![image-20220626175447382](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175447382.png)\n\n基本类型只需要在参数的使用范围内被固定，所以每次调用都可以提供一个类型不同的参数。\n\n![image-20220626175640411](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175640411.png)\n\n对不透明类型的返回值来说，基本类型是在函数实现中的返回值的位置进行推断的。\n\n![image-20220626180718256](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626180718256.png)\n\n有不透明类型返回值的方法或者计算属性，可以在程序的任何位置被调用，所以这个值的可用范围是全局的。这意味着，返回值的基本类型需要在所有的返回语句中保持一致。如果没有保持一致，编译器将会报错，基本类型返回值的类型不匹配。\n\n![image-20220626181045890](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626181045890.png)\n\n对于不透明类型的 SwiftUI View，ViewBuilder DSL 可以将控制流语句的每个分支都转换成拥有相同基本类型的返回值。\n\n所以在这个场景下，我们可以使用 ViewBuilder DSL 来解决这个问题。在方法前写一个修饰符 @ViewBuilder，并且移除掉 return 语句，将会允许通过 ViewBuilder 的类型来为我们构建返回值类型。\n\n![image-20220626181303429](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626181303429.png)\n\n让我们回到 feedAnimal 方法吧。\n\n我将会使用 some 在参数列表中，因为我并不需要在其他位置引用这个参数类型。当你需要多次引用这个不透明类型时，也就是说类型参数在手边。\n\n![image-20220626181701328](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626181701328.png)\n\n举个例子，当我们给 Animal 协议添加另外一个关联值，Habitat。\n\n![image-20220626181844443](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626181844443.png)\n\n我们也许想要在农场上为某个指定的动物构建一个栖息地，这个场景下，返回值类型就依赖于这个具体的动物的类型了，所以我们需要用类型参数 A 作为参数的类型，和返回值类型。\n\n![image-20220626183735613](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626183735613.png)\n\n另一个常你需要多次使用不透明类型的见的地方，是在泛型中。代码通常在泛型类型上声明一个类型参数，给一个存储属性使用类型参数，或者给一个成员构造器传递参数。\n\n![image-20220626184243060](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626184243060.png)\n\n在不同的上下文中引用泛型类型，也需要你用尖括号明确指出类型参数。在声明中的尖括号里的泛型可以帮助阐明如何使用一个泛型类型，所以不透明类型必须总是被命名为泛型类型。\n\n![image-20220626190535609](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626190535609.png)\n\n现在，让我们一起构造出 feed 方法的实现吧。\n\n\n\n我们可以使用动物参数的类型来访问种植的庄稼类型，通过 Feed 的关联类型。我们调用 Feed.grow() 来获取庄稼实例，这个庄稼可以产出要用来喂动物进食的类型的食物。\n\n![image-20220626190910250](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626190910250.png)\n\n接下来，我们需要收割庄稼的产出，可以通过调用庄稼的一个方法 harvest()\n\n![image-20220626191404371](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626191404371.png)\n\n最后我们可以把产出的食物喂给动物吃，因为基本的动物类型是固定的，编译器知道植物类型与产出食物类型，以及在多个方法之间调用的动物类型之间的关系。\n\n![image-20220626191534121](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626191534121.png)\n\n这些静态的关系阻止我们给动物喂错食物。\n\n如果我们尝试使用没有被保证可以为这个动物喂养的食物类型，编译器就会告诉我们。\n\n![image-20220626191900776](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626191900776.png)\n\n想要学习其他的农场协议是如何定义，并用来表达喂养动物的类型和它的植物之间关系的，请参考 110353\n\n![image-20220626193714763](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626193714763.png)\n\n最后，让我们添加一个 feedAll(animals:) 方法，接收一个数组作为参数，我知道元素类型需要遵循 Animal 协议，但是我希望这个数组可以存储不同类型的动物。\n\n![image-20220626202924050](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626202924050.png)\n\n让我们看看这里用不透明类型 some Animal 是否可行。\n\n![image-20220626203030188](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626203030188.png)\n\n使用 some，这里有一个具体的基本类型不能发生改变，因为基本类型是固定的，数组中所有的元素都必须是相同的类型，所以，用 some Animal 描述数组元素的类型并不能准确表达我们的意图。因为我想要一个可以存储不同类型元素的数组。\n\n![image-20220626203102314](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626203102314.png)\n\n这里，我们需要一个可以代表任何动物的超类，我们可以使用 any Animal 来表示任意类型的动物。\n\n![image-20220626203544327](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626203544327.png)\n\nany 关键字表明这个类型可以存储任意类型的动物，基本类型在运行时也可以改变。\n\n就像 some 关键字那样，any 关键字后也跟随着一个要遵循的协议，任何动物都是一个单一的静态类型，拥有动态存储任意动物实体类型的能力。这个能力允许我们对值类型使用子类多态。为了允许这个灵活的存储，any Animal 在内存中有一个特殊的表达。\n\n你可以把这种表达形式想成一个盒子，有时候，值能够直接装进盒子。\n\n![image-20220626204305609](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626204305609.png)\n\n另外一些值太大了盒子装不下，\n\n![image-20220626204414695](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626204414695.png)\n\n所以值需要在其他位置分配内存空间，盒子只是用一个指针指向这个空间。\n\n![image-20220626204442868](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626204442868.png)\n\nany Animal 这个静态类型可以动态存储任何实体类型这种行为被正式的成为存在主义类型。\n\n![image-20220626204819602](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626204819602.png)\n\n对不同实体类型使用相同表达的策略叫做类型擦除。\n\n在编译时，实体类型的类型被擦除，直到运行时才被体现出来。\n\n存在类型 any Animal 的这两个实例，有相同的静态类型，但是不同的动态类型。\n\n类型擦除消除了不同动物在类型级别的区别，这允许我们使用静态类型相同但动态类型不同的值。\n\n![image-20220626205158501](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626205158501.png)\n\n我们可以使用类型擦除来书写一个异源值类型数组，这正是我们在 feedAll(animals:) 方法中所需要的。\n\n![image-20220626205642059](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626205642059.png)\n\n所以我们使用一个数组，用 any Animal 作为参数的类型，对协议使用 any 关键字和关联类型是 Swift 5.7 新增的功能。\n\n为了实现 feedAll(animals:) 方法，我们首先遍历这个 animals 数组。\n\n![image-20220626205904465](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626205904465.png)\n\n对于每个动物，我们都想调用 Animal 协议中的 eat(food:) 方法。\n\n![image-20220626210014893](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626210014893.png)\n\n为了调用这个方法，在这次遍历中，我们需要获取到具体的基本类型 Feed 的类型。\n\n![image-20220626210159916](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626210159916.png)\n\n但是一旦我们对 any Animal 调用 eat(food:) 方法，我们将会得到一个编译错误。\n\n![image-20220626210358657](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626210358657.png)\n\n因为我们消除了具体动物类型在编译时类型级别的区别，我们也消除了所有类型之间的关系，这些关系本身是依赖于具体的动物类型的，也包括关联类型。\n\n所以我们不知道这个类型的动物希望被喂什么类型的食物。为了能够依赖这些类型之间的关系，我们需要回到之前动物的具体类型仍然固定的上下文，不再直接对 any Animal 调用 eat(food:) 方法，我们需要调用可以接收 some Animal 的 feed 方法。\n\n![image-20220626211117177](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626211117177.png)\n\nany Animal 跟 some Animal 是不同的，但是编译器可以通过“拆包”基本类型值的方式将 any Animal 的实例转换为 some Animal，并且把它直接传给 some Animal 参数。\n\n这个“拆包”实参的能力是 Swift 5. 7 新增的。\n\n![image-20220626211430157](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626211430157.png)\n\n你可以把拆包看作是编译器打开了盒子并取出了存在其中的值。\n\nsome Animal 参数的使用范围内，这个值都有一个固定的基本类型。所以我们可以访问所有对基本类型的操作，包括访问关联类型。\n\n这真的很酷，因为它允许我们在需要的时候选择灵活存储，同时也可以回到之前的拥有函数体内可使用范围的固定基本类型的静态类型系统完整表达的上下文。\n\n大多数情况下，你并不需要去考虑拆包，因为它就是按照你期待的方式工作的，与对 any Animal 调用协议方法类似，就是对基本类型调用这个方法。\n\n所以我们可以对每个动物都调用 feed(animal:) 方法，在那里，每次遍历我们都可以种植并且收割合适的庄稼来喂养具体的动物。\n\n![image-20220626215127833](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626215127833.png)\n\n在这个过程中，我们看到了 some 和 any 不同的能力。\n\n使用 some，基本类型就是固定的，这允许你在泛型代码中依赖于固定类型之间的关系，所以你有对 API 和协议关联类型的完整的访问权限。\n\n使用 any，当你需要存储任意实体类型时，any 提供了类型擦除，允许你表达异源集合，表达基本类型的缺席，使用可选项，同时抽象实现细节。\n\n![image-20220626215828321](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626215828321.png)\n\n总而言之，默认情况下使用 some，当你想要存储任意类型的值时，将 some 改为 any。\n\n使用这种方式，只在你需要存储灵活性时，付出类型擦除和语义限制的代价即可。\n\n这个工作流程与默认书写 let 表示常量，直到你需要变量时类似。\n\n在这个视频中，我们想要通过这个工作流程随着代码的演进来生成代码并且获得更多的功能。\n\n\n\n我们从实体类型开始，随着代码获得更多的功能，我们发觉在不同的类型中的代码重复。从这里开始，我们确定了通用的能力，并且使用协议生成了这些能力，最后我们用 some 和 any 写了抽象代码，并且讨论了我们倾向于使用 some 来书写更具有表达性的代码。\n\n想要更深入的构建协议和理解类型擦除，可以看 110353。\n\n![image-20220626220750663](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626220750663.png)","slug":"WWDC 22 - 110352 拥抱 Swift 泛型 直译","published":0,"date":"2022-06-26T04:30:34.717Z","updated":"2022-07-02T09:05:08.868Z","_id":"cl4ve2ev40002y2dx8j3l4x1s","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"WWDC-22-110352-拥抱-Swift-泛型-直译\"><a href=\"#WWDC-22-110352-拥抱-Swift-泛型-直译\" class=\"headerlink\" title=\"WWDC 22 - 110352 拥抱 Swift 泛型 直译\"></a>WWDC 22 - 110352 拥抱 Swift 泛型 直译</h1><p>大家好，我是 holly，来自 Swift 编译组，欢迎来到拥抱 Swift 泛型。</p>\n<p>泛型是一个书写 Swift 抽象代码的基本工具，随着代码的演化发展，泛型是起到管理复杂性的关键。</p>\n<p>抽象概念可以将思想从特定的细节中分离出来，在代码中，有很多种方式(途径)可以使用泛型(泛型都起到了作用)。</p>\n<p>你可能经常使用到的一种抽象概念的形式就是将代码抽出来到一个函数或是一个本地的变量，如果你想要多次使用同一功能或同一个值时，这是非常有用的。</p>\n<p>![image-20220626130647985](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626130647985.png)</p>\n<p>当你把一个功能提取到一个函数里时，函数的细节就被抽出去(抽象化)了，而使用(调用)个抽象函数的代码，就可以表达所发生的事情，而不需要重复细节了。</p>\n<p>![image-20220626135431108](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626135431108.png)</p>\n<p>在 Swift 中，你也可以将实体类型抽象出来，如果你有一系列的类型，它们使用了相同的思想，和不同的实现细节，你就可以写抽象的代码来实现所有这些实体类型。</p>\n<p>![image-20220626135903984](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626135903984.png)</p>\n<p>今天，我们将通过模型化实体类型、确定一系列实体类型的通用能力、构建一个接口来表达(呈现)这些能力、深入了解如何使用这些接口来实现泛型的书写的步骤来向你展示泛型的具体使用场景。</p>\n<p>![image-20220626140259410](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626140259410.png)</p>\n<p>我们将通过构建一些代码来模拟一个农场的形式，一起探索 Swift 抽象工具的使用。</p>\n<p>![image-20220626140636740](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626140636740.png)</p>\n<p>让我们先来写几个实体类型吧。</p>\n<p>首先创建一个叫做 Cow 的结构体，它有一个方法叫做 eat(food:)，接收一个 Hay 类型的参数。</p>\n<p>Hay 是另一个结构体，它有一个静态方法叫做 grow() -&gt; Alfalfa，可以种植一些能够长出 Hay 的庄稼 Alfalfa。</p>\n<p>Alfalfa 结构体有一个方法 harvest() -&gt; Hay 通过 Alfalfa 实例来收获 Hay。</p>\n<p>最后，我们抽象出一个农场 Farm，它有一个方法 feed(animal:) 可以喂养奶牛。</p>\n<p>feed(animal:) 方法可以通过首先种一些苜蓿 Alfalfa 来生产干草 Hay，然后收获干草 Hay ，最后用干草 Hay 来喂养奶牛 Cow 的方式实现。</p>\n<p>这时，我就能在我的农场来饲养奶牛了。</p>\n<p>![image-20220626141648138](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626141648138.png)</p>\n<p>但是我想饲养更多的动物。</p>\n<p>![image-20220626141850288](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626141850288.png)</p>\n<p>我可以添加更多的结构体来代表其他的动物，就像 Horse 马和 Chicken 鸡。</p>\n<p>![image-20220626141938986](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626141938986.png)</p>\n<p>我想在农场上饲养奶牛，马，鸡。</p>\n<p>![image-20220626142052720](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626142052720.png)</p>\n<p>我可以重载这个 feed(animal:) 方法分别来接收不同类型的参数，但是每个重载函数都会有一个相当类似的实现。</p>\n<p>![image-20220626142240499](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626142240499.png)</p>\n<p>![image-20220626142527042](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626142527042.png)</p>\n<p>当我添加更多的动物类型时，这将造成类似代码的堆积，基本上到处都是重复的代码。</p>\n<p>当你发现自己写的重载代码有重复的实现时，就是概括归纳(抽象、重构)的预兆了。</p>\n<p>基本上说，这些实现都很类似，因为(饲养)不同类型的动物在功能(喂养)上是相似的。</p>\n<p>第二步，就是来确定动物类型的通用能力了。</p>\n<p>我们已经构建了一系列动物类型了，它们都有一个能力，吃某一种食物。</p>\n<p>每种类型的动物都有不同的进食方式，所以每个动物的 eat(food:) 方法都有不同的行为表现。</p>\n<p>![image-20220626143435094](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626143435094.png)</p>\n<p>我们要做的就是允许抽象代码调用 eat(food:) 方法的同时，让这些抽象代码在 eat(food:) 方法中的行为表现不同，这取决于抽象代码所执行在的实体的具体类型。</p>\n<p>抽象代码在不同的实体类型上可以表现不同能力的功能叫做多态，多态允许一份代码拥有多种行为表现，取决于代码是被如何使用的。</p>\n<p>更恰当地说的话，多态本身就是不同形式的。</p>\n<p>首先是函数的重载，根据传入参数类型的不同，同样的函数调用可以意味着不同的事物。重载被称为 ad-hoc(临时安排的、特别的、专门的) 多态，因为它并不是一个通用的解决方案。我们只能看到重载是如何一步步走向重复代码的。</p>\n<p>下一步，是子类多态。代码在一个超类上去执行调用，实际上却会在运行时基于特定的子类而产生不同的表现。</p>\n<p>最后是使用泛型来实现的确定(指定)参数的多态。</p>\n<p>![image-20220628195408677](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220628195408677.png)</p>\n<p>泛型代码使用类型参数，来允许书写一份代码与不同类型一起奏效(工作、运行)。而实体类型呢，则将作为实参进行传递。</p>\n<p>我们早就已经把重载排除出局了，所以让我们尝试使用子类多态吧。</p>\n<p>代表子类关系的一种方式是使用类型层级。我们可以引入一个类型叫做 Animal 动物。</p>\n<p>![image-20220626145345481](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626145345481.png)</p>\n<p>然后，我们将每种动物类型从结构体更改为类。</p>\n<p>![image-20220626145445564](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626145445564.png)</p>\n<p>每个具体的动物类都继承自 Animal 动物这个超类并且重写 eat(food:) 方法。</p>\n<p>![image-20220626145552753](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626145552753.png)</p>\n<p>现在，我们有一个抽象的基类 Animal 动物，可以代表我们每一个具体的动物类型。调用 Animal 动物的 eat(food:) 方法将会使用子类多态而调用到子类的具体实现，但这样还没完。</p>\n<p>我们仍然没有补全 Animal 动物 eat(:food) 方法的参数类型，这份代码还有一些报错。</p>\n<p>首先，使用类将强制我们使用引用类型，即使我们并不需要分享不同实例间的任何状态。这个策略也需要子类去重写基类中的方法。但是忘记重写基类方法只有在运行时才会被捕获。</p>\n<p>但是对这个模型抽象的过程中更大的问题是每种子类动物都会食用不同类型的食物，这种依赖用类型层级相当难以表达。</p>\n<p>一种方式是让 eat(food:) 方法中食物的参数接收一个不具体(明确)的类型， 例如 Any。</p>\n<p>![image-20220626150733935](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626150733935.png)</p>\n<p>但是这种策略在子类实现中，仍然需要在运行时确定好准确的类型并传入，在每个重写的方法中又一次出现了代码堆积。</p>\n<p>![image-20220626150958877](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626150958877.png)</p>\n<p>但是更重要的是，这份代码允许你不小心传入一个错误的食物类型，造成另一个只能在运行时才捕获的 bug。我们再试试别的方法吧。</p>\n<p>我们可以通过在超类 Animal 动物类上引入一种类型安全的参数类型的方式，来替代表达喂养动物所用食物的类型。</p>\n<p>![image-20220626151650552](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626151650552.png)</p>\n<p>这种类型参数对每一个子类的食物喂养类型使用一个占位符，通过这种方式，Food 参数的类型必须被提升到 Animal 类的声明中才行。</p>\n<p>![image-20220626152712935](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626152712935.png)</p>\n<p>这看起来有点诡异，因为尽管动物需要食物来填饱肚子，但是进食并不是动物的主要目标，很多与动物相关的代码也许根本不关心它们吃什么食物。尽管如此，所有对 Animal 类的引用都需要指明 Food 的类型。</p>\n<p>举个例子，每个 Animal 的子类都需要在继承的代码中用尖括号内明确指出它的食物类型，如果我们添加更多需要明确指定的类型给 Animal，这种代码模板在每个使用 Animal 类的地方都将变得非常繁琐。</p>\n<p>![image-20220626153746315](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626153746315.png)</p>\n<p>所以我们上述的两种方式既低效，又不能正确地表达语义。</p>\n<p>根本问题是，类是一种数据类型，我们却想要尝试复杂化一个超类，然后让它代表实体类型的抽象思想。</p>\n<p>取而代之的是，我们想要构建一个能够代表类型的能力，但不需要这个能力实现的细节。</p>\n<p>动物有两个常见的能力，每种动物都有一种具体的食物类型，和一种进食方式。</p>\n<p>我们可以构建一种接口来代表这两种能力。</p>\n<p>在 Swift 中，使用协议来实现这种功能。</p>\n<p>协议是一种抽象工具，描述了遵循它协议的类型的功能。使用协议，你可以把一个类所做的事情的构思与其具体的实现区分开来。一个类所做的事情的构思用接口来表达。</p>\n<p>让我们将动物的能力使用协议接口来翻译一下。</p>\n<p>协议的名称代表我们所描述的这种类型的分类，所以我管这个协议叫“Animal 动物”。</p>\n<p>每个能力都将映射到一个协议的必备条件上。</p>\n<p>食物的具体类型将会映射为一个关联类型，就像类型参数一样，关联类型也是作为实体类型的占位符。</p>\n<p>![image-20220626160017654](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626160017654.png)</p>\n<p>关联类型的特别之处在于，它取决于遵循协议的那个类的具体类型，这层关系是有保障的。所以具体动物类的每个实例都有相同的食物类型。</p>\n<p>接下来，进食的行为将会映射为一个方法。这个方法叫做 eat(food:)，它接收一个参数，喂养动物的类型。</p>\n<p>![image-20220626160729154](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626160729154.png)</p>\n<p>协议中并没有这个方法的实现，实体动物类型被要求去实现它。</p>\n<p>现在，我们有一个动物协议，我们可以让每个实体类都遵循它。</p>\n<p>你可以对一个实体类进行标记，在它的声明或者扩展中，代表它遵循了一个协议。</p>\n<p>![image-20220626162949349](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626162949349.png)</p>\n<p>协议并不仅限于类去遵循，我们也可以对结构体、枚举和 actors 使用协议。</p>\n<p>当你写下这个协议遵循的标注，编译器将会检查实体类是否实现了协议中要求的必要条件。</p>\n<p>每个动物类都必须实现 eat(food:) 这个方法，编译器可以推断出喂养所需食物的类型，因为它在参数列表中已经被使用(描述)过了。</p>\n<p>Feed 也可以通过类型别名明确的写出。</p>\n<p>我们成功地确定了动物的通用能力，并且使用协议表达了这些能力。现在，我们可以开始书写泛型代码了。</p>\n<p>我们可以使用动物协议来实现农场的 feed(animal:) 方法，我们想写一种实现，可以对所有的动物实体类型都通用。</p>\n<p>我们使用确定参数的多态，并且引入一个类型参数将会在方法被调用的时候替换为实体类型。</p>\n<p>类型参数是用尖括号包裹写在函数名称后面的，就像通常的变量和函数参数那样，你可以随意给参数类型命名。</p>\n<p>并且就像任何其他的类型那样，你可以在函数体内使用类型参数的名称引用这个类型参数。</p>\n<p>这里我声明了一个类型参数 A，并且使用 A 作为函数参数动物的类型。</p>\n<p>![image-20220626164416814](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626164416814.png)</p>\n<p>我们总是希望实体动物类型遵循动物协议，所以在 A 之后声明其遵循 Animal 协议。</p>\n<p>![image-20220626165033294](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626165033294.png)</p>\n<p>协议遵循可以写在尖括号里，也可以在最后使用 where 语句声明，在这里你还可以指明不同参数类型之间的关系。</p>\n<p>![image-20220626165151422](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626165151422.png)</p>\n<p>命名类型参数和在结尾写 wehre 语句是非常有力量的，因为它允许你写出复杂的必要条件与类型关系。但是大多数的泛型函数不需要这样的通用性。</p>\n<p>让我们把焦点放在 feed(animal:) 方法上。</p>\n<p>类型参数 A 在参数列表中出现过一次，而 where 语句罗列出了类型参数必要条件的遵循情况。</p>\n<p>在这种情况下，命名类型参数和使用 where 语句让这个方法看起来过于复杂。</p>\n<p>![image-20220626165501956](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626165501956.png)</p>\n<p>这种泛型样式是相当常见的，所以有更简单的方式表达它。</p>\n<p>不再明确写出类型参数，我们可以就协议的遵循情况通过写成 some Animal 来表达这个抽象类型，这种声明方式跟前面的是等价的，但是那些不必要的参数列表和 where 语句都消失了，因为我们并不需要它们所提供的这种表达形式，使用 some Animal 更加直接。因为它减少了语法干扰，还在参数声明的右边包含了关于动物参数的语义信息。</p>\n<p>![image-20220626170002361](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626170002361.png)</p>\n<p>让我们看看 some Animal 的语法。</p>\n<p>some 暗示这里有一个具体的类型，some 之后总是会跟着一个要遵循的协议。</p>\n<p>在这个场景里，具体的类型必须遵循 Animal 协议，这允许我们在参数值上使用 Animal 协议中的必要条件(这允许我们对这个参数调用 Animal 协议中声明的方法)。</p>\n<p>some 关键字可以在参数和返回值的类型中使用，如果你之前写过 SwiftUI 代码，你早就用过 some 在返回值的位置使用 some View。</p>\n<p>返回值的类型 some View 跟这里恰恰是完全相同的概念。在 SwiftUI 的视图中，body 属性返回某个具体类型的视图，但是使用 body 属性的代码并不需要知道这个具体的类型是什么。</p>\n<p>![image-20220626170932734](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626170932734.png)</p>\n<p>让我们返回回去更好的理解一下一个具体抽象类型的概念。</p>\n<p>一个抽象类型代表一个具体的实体类型的占位符叫做“不透明类型”。</p>\n<p>被替换的具体的实体类型类型叫做(underlying)基本类型，对于不透明类型的值，在值的使用范围内，基本类型是固定的。</p>\n<p>这样，泛型代码使用的值就被保证了值每次被访问的时候，都会获取到相同的基本类型。</p>\n<p>使用 some 关键字的类型，和一个用尖括号命名的类型参数，都声明了一个不透明类型。</p>\n<p>![image-20220626173329398](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626173329398.png)</p>\n<p>不透明类型在输入输出中都可以使用，所以它们可以声明在参数的位置，或是返回值的位置。</p>\n<p>![image-20220626173435799](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626173435799.png)</p>\n<p>函数的箭头将这两个位置分为两部分。</p>\n<p>![image-20220626173940091](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626173940091.png)</p>\n<p>不透明类型的位置决定了程序的哪个部分可以看到抽象类型，以及程序的哪个部分决定实体类型。</p>\n<p>命名类型参数总是声明在输入侧，所以调用者决定了基本类型，而实现使用了抽象类型。</p>\n<p>![image-20220626174210668](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626174210668.png)</p>\n<p>通常情况下，提供不透明类型参数或返回值类型的那部分程序，决定了基本类型；而使用这个值的那部分程序可以看到抽象类型。</p>\n<p>让我们深入了解一下这是怎么运转起来的。跟着我们对参数和返回值的直觉走。</p>\n<p>因为基本类型是通过一个值推断出来的，基本类型总是跟值一起出现在相同的位置。</p>\n<p>对于一个本地变量来说，基本类型是通过右边的赋值操作推断出来的，这意味着有着不透明类型的本地变量总是需要一个初始值。</p>\n<p>![image-20220626174951554](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626174951554.png)</p>\n<p>如果你不给提供初始值，编译器将会报错。</p>\n<p>![image-20220626175035323](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175035323.png)</p>\n<p>基本类型必须在变量的使用范围内被固定，所以对基本类型进行修改的尝试也会得出一个错误的结果。</p>\n<p>![image-20220626175134539](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175134539.png)</p>\n<p>对于使用不透明类型的参数来说，基本类型是在被调用的位置传入的实参值推断出来的。</p>\n<p>![image-20220626175314696](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175314696.png)</p>\n<p>在参数位置使用 some 是 Swift 5.7 新增的功能。</p>\n<p>![image-20220626175447382](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175447382.png)</p>\n<p>基本类型只需要在参数的使用范围内被固定，所以每次调用都可以提供一个类型不同的参数。</p>\n<p>![image-20220626175640411](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175640411.png)</p>\n<p>对不透明类型的返回值来说，基本类型是在函数实现中的返回值的位置进行推断的。</p>\n<p>![image-20220626180718256](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626180718256.png)</p>\n<p>有不透明类型返回值的方法或者计算属性，可以在程序的任何位置被调用，所以这个值的可用范围是全局的。这意味着，返回值的基本类型需要在所有的返回语句中保持一致。如果没有保持一致，编译器将会报错，基本类型返回值的类型不匹配。</p>\n<p>![image-20220626181045890](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626181045890.png)</p>\n<p>对于不透明类型的 SwiftUI View，ViewBuilder DSL 可以将控制流语句的每个分支都转换成拥有相同基本类型的返回值。</p>\n<p>所以在这个场景下，我们可以使用 ViewBuilder DSL 来解决这个问题。在方法前写一个修饰符 @ViewBuilder，并且移除掉 return 语句，将会允许通过 ViewBuilder 的类型来为我们构建返回值类型。</p>\n<p>![image-20220626181303429](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626181303429.png)</p>\n<p>让我们回到 feedAnimal 方法吧。</p>\n<p>我将会使用 some 在参数列表中，因为我并不需要在其他位置引用这个参数类型。当你需要多次引用这个不透明类型时，也就是说类型参数在手边。</p>\n<p>![image-20220626181701328](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626181701328.png)</p>\n<p>举个例子，当我们给 Animal 协议添加另外一个关联值，Habitat。</p>\n<p>![image-20220626181844443](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626181844443.png)</p>\n<p>我们也许想要在农场上为某个指定的动物构建一个栖息地，这个场景下，返回值类型就依赖于这个具体的动物的类型了，所以我们需要用类型参数 A 作为参数的类型，和返回值类型。</p>\n<p>![image-20220626183735613](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626183735613.png)</p>\n<p>另一个常你需要多次使用不透明类型的见的地方，是在泛型中。代码通常在泛型类型上声明一个类型参数，给一个存储属性使用类型参数，或者给一个成员构造器传递参数。</p>\n<p>![image-20220626184243060](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626184243060.png)</p>\n<p>在不同的上下文中引用泛型类型，也需要你用尖括号明确指出类型参数。在声明中的尖括号里的泛型可以帮助阐明如何使用一个泛型类型，所以不透明类型必须总是被命名为泛型类型。</p>\n<p>![image-20220626190535609](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626190535609.png)</p>\n<p>现在，让我们一起构造出 feed 方法的实现吧。</p>\n<p>我们可以使用动物参数的类型来访问种植的庄稼类型，通过 Feed 的关联类型。我们调用 Feed.grow() 来获取庄稼实例，这个庄稼可以产出要用来喂动物进食的类型的食物。</p>\n<p>![image-20220626190910250](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626190910250.png)</p>\n<p>接下来，我们需要收割庄稼的产出，可以通过调用庄稼的一个方法 harvest()</p>\n<p>![image-20220626191404371](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626191404371.png)</p>\n<p>最后我们可以把产出的食物喂给动物吃，因为基本的动物类型是固定的，编译器知道植物类型与产出食物类型，以及在多个方法之间调用的动物类型之间的关系。</p>\n<p>![image-20220626191534121](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626191534121.png)</p>\n<p>这些静态的关系阻止我们给动物喂错食物。</p>\n<p>如果我们尝试使用没有被保证可以为这个动物喂养的食物类型，编译器就会告诉我们。</p>\n<p>![image-20220626191900776](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626191900776.png)</p>\n<p>想要学习其他的农场协议是如何定义，并用来表达喂养动物的类型和它的植物之间关系的，请参考 110353</p>\n<p>![image-20220626193714763](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626193714763.png)</p>\n<p>最后，让我们添加一个 feedAll(animals:) 方法，接收一个数组作为参数，我知道元素类型需要遵循 Animal 协议，但是我希望这个数组可以存储不同类型的动物。</p>\n<p>![image-20220626202924050](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626202924050.png)</p>\n<p>让我们看看这里用不透明类型 some Animal 是否可行。</p>\n<p>![image-20220626203030188](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626203030188.png)</p>\n<p>使用 some，这里有一个具体的基本类型不能发生改变，因为基本类型是固定的，数组中所有的元素都必须是相同的类型，所以，用 some Animal 描述数组元素的类型并不能准确表达我们的意图。因为我想要一个可以存储不同类型元素的数组。</p>\n<p>![image-20220626203102314](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626203102314.png)</p>\n<p>这里，我们需要一个可以代表任何动物的超类，我们可以使用 any Animal 来表示任意类型的动物。</p>\n<p>![image-20220626203544327](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626203544327.png)</p>\n<p>any 关键字表明这个类型可以存储任意类型的动物，基本类型在运行时也可以改变。</p>\n<p>就像 some 关键字那样，any 关键字后也跟随着一个要遵循的协议，任何动物都是一个单一的静态类型，拥有动态存储任意动物实体类型的能力。这个能力允许我们对值类型使用子类多态。为了允许这个灵活的存储，any Animal 在内存中有一个特殊的表达。</p>\n<p>你可以把这种表达形式想成一个盒子，有时候，值能够直接装进盒子。</p>\n<p>![image-20220626204305609](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626204305609.png)</p>\n<p>另外一些值太大了盒子装不下，</p>\n<p>![image-20220626204414695](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626204414695.png)</p>\n<p>所以值需要在其他位置分配内存空间，盒子只是用一个指针指向这个空间。</p>\n<p>![image-20220626204442868](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626204442868.png)</p>\n<p>any Animal 这个静态类型可以动态存储任何实体类型这种行为被正式的成为存在主义类型。</p>\n<p>![image-20220626204819602](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626204819602.png)</p>\n<p>对不同实体类型使用相同表达的策略叫做类型擦除。</p>\n<p>在编译时，实体类型的类型被擦除，直到运行时才被体现出来。</p>\n<p>存在类型 any Animal 的这两个实例，有相同的静态类型，但是不同的动态类型。</p>\n<p>类型擦除消除了不同动物在类型级别的区别，这允许我们使用静态类型相同但动态类型不同的值。</p>\n<p>![image-20220626205158501](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626205158501.png)</p>\n<p>我们可以使用类型擦除来书写一个异源值类型数组，这正是我们在 feedAll(animals:) 方法中所需要的。</p>\n<p>![image-20220626205642059](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626205642059.png)</p>\n<p>所以我们使用一个数组，用 any Animal 作为参数的类型，对协议使用 any 关键字和关联类型是 Swift 5.7 新增的功能。</p>\n<p>为了实现 feedAll(animals:) 方法，我们首先遍历这个 animals 数组。</p>\n<p>![image-20220626205904465](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626205904465.png)</p>\n<p>对于每个动物，我们都想调用 Animal 协议中的 eat(food:) 方法。</p>\n<p>![image-20220626210014893](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626210014893.png)</p>\n<p>为了调用这个方法，在这次遍历中，我们需要获取到具体的基本类型 Feed 的类型。</p>\n<p>![image-20220626210159916](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626210159916.png)</p>\n<p>但是一旦我们对 any Animal 调用 eat(food:) 方法，我们将会得到一个编译错误。</p>\n<p>![image-20220626210358657](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626210358657.png)</p>\n<p>因为我们消除了具体动物类型在编译时类型级别的区别，我们也消除了所有类型之间的关系，这些关系本身是依赖于具体的动物类型的，也包括关联类型。</p>\n<p>所以我们不知道这个类型的动物希望被喂什么类型的食物。为了能够依赖这些类型之间的关系，我们需要回到之前动物的具体类型仍然固定的上下文，不再直接对 any Animal 调用 eat(food:) 方法，我们需要调用可以接收 some Animal 的 feed 方法。</p>\n<p>![image-20220626211117177](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626211117177.png)</p>\n<p>any Animal 跟 some Animal 是不同的，但是编译器可以通过“拆包”基本类型值的方式将 any Animal 的实例转换为 some Animal，并且把它直接传给 some Animal 参数。</p>\n<p>这个“拆包”实参的能力是 Swift 5. 7 新增的。</p>\n<p>![image-20220626211430157](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626211430157.png)</p>\n<p>你可以把拆包看作是编译器打开了盒子并取出了存在其中的值。</p>\n<p>some Animal 参数的使用范围内，这个值都有一个固定的基本类型。所以我们可以访问所有对基本类型的操作，包括访问关联类型。</p>\n<p>这真的很酷，因为它允许我们在需要的时候选择灵活存储，同时也可以回到之前的拥有函数体内可使用范围的固定基本类型的静态类型系统完整表达的上下文。</p>\n<p>大多数情况下，你并不需要去考虑拆包，因为它就是按照你期待的方式工作的，与对 any Animal 调用协议方法类似，就是对基本类型调用这个方法。</p>\n<p>所以我们可以对每个动物都调用 feed(animal:) 方法，在那里，每次遍历我们都可以种植并且收割合适的庄稼来喂养具体的动物。</p>\n<p>![image-20220626215127833](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626215127833.png)</p>\n<p>在这个过程中，我们看到了 some 和 any 不同的能力。</p>\n<p>使用 some，基本类型就是固定的，这允许你在泛型代码中依赖于固定类型之间的关系，所以你有对 API 和协议关联类型的完整的访问权限。</p>\n<p>使用 any，当你需要存储任意实体类型时，any 提供了类型擦除，允许你表达异源集合，表达基本类型的缺席，使用可选项，同时抽象实现细节。</p>\n<p>![image-20220626215828321](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626215828321.png)</p>\n<p>总而言之，默认情况下使用 some，当你想要存储任意类型的值时，将 some 改为 any。</p>\n<p>使用这种方式，只在你需要存储灵活性时，付出类型擦除和语义限制的代价即可。</p>\n<p>这个工作流程与默认书写 let 表示常量，直到你需要变量时类似。</p>\n<p>在这个视频中，我们想要通过这个工作流程随着代码的演进来生成代码并且获得更多的功能。</p>\n<p>我们从实体类型开始，随着代码获得更多的功能，我们发觉在不同的类型中的代码重复。从这里开始，我们确定了通用的能力，并且使用协议生成了这些能力，最后我们用 some 和 any 写了抽象代码，并且讨论了我们倾向于使用 some 来书写更具有表达性的代码。</p>\n<p>想要更深入的构建协议和理解类型擦除，可以看 110353。</p>\n<p>![image-20220626220750663](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626220750663.png)</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"WWDC-22-110352-拥抱-Swift-泛型-直译\"><a href=\"#WWDC-22-110352-拥抱-Swift-泛型-直译\" class=\"headerlink\" title=\"WWDC 22 - 110352 拥抱 Swift 泛型 直译\"></a>WWDC 22 - 110352 拥抱 Swift 泛型 直译</h1><p>大家好，我是 holly，来自 Swift 编译组，欢迎来到拥抱 Swift 泛型。</p>\n<p>泛型是一个书写 Swift 抽象代码的基本工具，随着代码的演化发展，泛型是起到管理复杂性的关键。</p>\n<p>抽象概念可以将思想从特定的细节中分离出来，在代码中，有很多种方式(途径)可以使用泛型(泛型都起到了作用)。</p>\n<p>你可能经常使用到的一种抽象概念的形式就是将代码抽出来到一个函数或是一个本地的变量，如果你想要多次使用同一功能或同一个值时，这是非常有用的。</p>\n<p>![image-20220626130647985](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626130647985.png)</p>\n<p>当你把一个功能提取到一个函数里时，函数的细节就被抽出去(抽象化)了，而使用(调用)个抽象函数的代码，就可以表达所发生的事情，而不需要重复细节了。</p>\n<p>![image-20220626135431108](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626135431108.png)</p>\n<p>在 Swift 中，你也可以将实体类型抽象出来，如果你有一系列的类型，它们使用了相同的思想，和不同的实现细节，你就可以写抽象的代码来实现所有这些实体类型。</p>\n<p>![image-20220626135903984](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626135903984.png)</p>\n<p>今天，我们将通过模型化实体类型、确定一系列实体类型的通用能力、构建一个接口来表达(呈现)这些能力、深入了解如何使用这些接口来实现泛型的书写的步骤来向你展示泛型的具体使用场景。</p>\n<p>![image-20220626140259410](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626140259410.png)</p>\n<p>我们将通过构建一些代码来模拟一个农场的形式，一起探索 Swift 抽象工具的使用。</p>\n<p>![image-20220626140636740](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626140636740.png)</p>\n<p>让我们先来写几个实体类型吧。</p>\n<p>首先创建一个叫做 Cow 的结构体，它有一个方法叫做 eat(food:)，接收一个 Hay 类型的参数。</p>\n<p>Hay 是另一个结构体，它有一个静态方法叫做 grow() -&gt; Alfalfa，可以种植一些能够长出 Hay 的庄稼 Alfalfa。</p>\n<p>Alfalfa 结构体有一个方法 harvest() -&gt; Hay 通过 Alfalfa 实例来收获 Hay。</p>\n<p>最后，我们抽象出一个农场 Farm，它有一个方法 feed(animal:) 可以喂养奶牛。</p>\n<p>feed(animal:) 方法可以通过首先种一些苜蓿 Alfalfa 来生产干草 Hay，然后收获干草 Hay ，最后用干草 Hay 来喂养奶牛 Cow 的方式实现。</p>\n<p>这时，我就能在我的农场来饲养奶牛了。</p>\n<p>![image-20220626141648138](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626141648138.png)</p>\n<p>但是我想饲养更多的动物。</p>\n<p>![image-20220626141850288](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626141850288.png)</p>\n<p>我可以添加更多的结构体来代表其他的动物，就像 Horse 马和 Chicken 鸡。</p>\n<p>![image-20220626141938986](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626141938986.png)</p>\n<p>我想在农场上饲养奶牛，马，鸡。</p>\n<p>![image-20220626142052720](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626142052720.png)</p>\n<p>我可以重载这个 feed(animal:) 方法分别来接收不同类型的参数，但是每个重载函数都会有一个相当类似的实现。</p>\n<p>![image-20220626142240499](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626142240499.png)</p>\n<p>![image-20220626142527042](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626142527042.png)</p>\n<p>当我添加更多的动物类型时，这将造成类似代码的堆积，基本上到处都是重复的代码。</p>\n<p>当你发现自己写的重载代码有重复的实现时，就是概括归纳(抽象、重构)的预兆了。</p>\n<p>基本上说，这些实现都很类似，因为(饲养)不同类型的动物在功能(喂养)上是相似的。</p>\n<p>第二步，就是来确定动物类型的通用能力了。</p>\n<p>我们已经构建了一系列动物类型了，它们都有一个能力，吃某一种食物。</p>\n<p>每种类型的动物都有不同的进食方式，所以每个动物的 eat(food:) 方法都有不同的行为表现。</p>\n<p>![image-20220626143435094](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626143435094.png)</p>\n<p>我们要做的就是允许抽象代码调用 eat(food:) 方法的同时，让这些抽象代码在 eat(food:) 方法中的行为表现不同，这取决于抽象代码所执行在的实体的具体类型。</p>\n<p>抽象代码在不同的实体类型上可以表现不同能力的功能叫做多态，多态允许一份代码拥有多种行为表现，取决于代码是被如何使用的。</p>\n<p>更恰当地说的话，多态本身就是不同形式的。</p>\n<p>首先是函数的重载，根据传入参数类型的不同，同样的函数调用可以意味着不同的事物。重载被称为 ad-hoc(临时安排的、特别的、专门的) 多态，因为它并不是一个通用的解决方案。我们只能看到重载是如何一步步走向重复代码的。</p>\n<p>下一步，是子类多态。代码在一个超类上去执行调用，实际上却会在运行时基于特定的子类而产生不同的表现。</p>\n<p>最后是使用泛型来实现的确定(指定)参数的多态。</p>\n<p>![image-20220628195408677](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220628195408677.png)</p>\n<p>泛型代码使用类型参数，来允许书写一份代码与不同类型一起奏效(工作、运行)。而实体类型呢，则将作为实参进行传递。</p>\n<p>我们早就已经把重载排除出局了，所以让我们尝试使用子类多态吧。</p>\n<p>代表子类关系的一种方式是使用类型层级。我们可以引入一个类型叫做 Animal 动物。</p>\n<p>![image-20220626145345481](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626145345481.png)</p>\n<p>然后，我们将每种动物类型从结构体更改为类。</p>\n<p>![image-20220626145445564](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626145445564.png)</p>\n<p>每个具体的动物类都继承自 Animal 动物这个超类并且重写 eat(food:) 方法。</p>\n<p>![image-20220626145552753](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626145552753.png)</p>\n<p>现在，我们有一个抽象的基类 Animal 动物，可以代表我们每一个具体的动物类型。调用 Animal 动物的 eat(food:) 方法将会使用子类多态而调用到子类的具体实现，但这样还没完。</p>\n<p>我们仍然没有补全 Animal 动物 eat(:food) 方法的参数类型，这份代码还有一些报错。</p>\n<p>首先，使用类将强制我们使用引用类型，即使我们并不需要分享不同实例间的任何状态。这个策略也需要子类去重写基类中的方法。但是忘记重写基类方法只有在运行时才会被捕获。</p>\n<p>但是对这个模型抽象的过程中更大的问题是每种子类动物都会食用不同类型的食物，这种依赖用类型层级相当难以表达。</p>\n<p>一种方式是让 eat(food:) 方法中食物的参数接收一个不具体(明确)的类型， 例如 Any。</p>\n<p>![image-20220626150733935](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626150733935.png)</p>\n<p>但是这种策略在子类实现中，仍然需要在运行时确定好准确的类型并传入，在每个重写的方法中又一次出现了代码堆积。</p>\n<p>![image-20220626150958877](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626150958877.png)</p>\n<p>但是更重要的是，这份代码允许你不小心传入一个错误的食物类型，造成另一个只能在运行时才捕获的 bug。我们再试试别的方法吧。</p>\n<p>我们可以通过在超类 Animal 动物类上引入一种类型安全的参数类型的方式，来替代表达喂养动物所用食物的类型。</p>\n<p>![image-20220626151650552](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626151650552.png)</p>\n<p>这种类型参数对每一个子类的食物喂养类型使用一个占位符，通过这种方式，Food 参数的类型必须被提升到 Animal 类的声明中才行。</p>\n<p>![image-20220626152712935](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626152712935.png)</p>\n<p>这看起来有点诡异，因为尽管动物需要食物来填饱肚子，但是进食并不是动物的主要目标，很多与动物相关的代码也许根本不关心它们吃什么食物。尽管如此，所有对 Animal 类的引用都需要指明 Food 的类型。</p>\n<p>举个例子，每个 Animal 的子类都需要在继承的代码中用尖括号内明确指出它的食物类型，如果我们添加更多需要明确指定的类型给 Animal，这种代码模板在每个使用 Animal 类的地方都将变得非常繁琐。</p>\n<p>![image-20220626153746315](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626153746315.png)</p>\n<p>所以我们上述的两种方式既低效，又不能正确地表达语义。</p>\n<p>根本问题是，类是一种数据类型，我们却想要尝试复杂化一个超类，然后让它代表实体类型的抽象思想。</p>\n<p>取而代之的是，我们想要构建一个能够代表类型的能力，但不需要这个能力实现的细节。</p>\n<p>动物有两个常见的能力，每种动物都有一种具体的食物类型，和一种进食方式。</p>\n<p>我们可以构建一种接口来代表这两种能力。</p>\n<p>在 Swift 中，使用协议来实现这种功能。</p>\n<p>协议是一种抽象工具，描述了遵循它协议的类型的功能。使用协议，你可以把一个类所做的事情的构思与其具体的实现区分开来。一个类所做的事情的构思用接口来表达。</p>\n<p>让我们将动物的能力使用协议接口来翻译一下。</p>\n<p>协议的名称代表我们所描述的这种类型的分类，所以我管这个协议叫“Animal 动物”。</p>\n<p>每个能力都将映射到一个协议的必备条件上。</p>\n<p>食物的具体类型将会映射为一个关联类型，就像类型参数一样，关联类型也是作为实体类型的占位符。</p>\n<p>![image-20220626160017654](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626160017654.png)</p>\n<p>关联类型的特别之处在于，它取决于遵循协议的那个类的具体类型，这层关系是有保障的。所以具体动物类的每个实例都有相同的食物类型。</p>\n<p>接下来，进食的行为将会映射为一个方法。这个方法叫做 eat(food:)，它接收一个参数，喂养动物的类型。</p>\n<p>![image-20220626160729154](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626160729154.png)</p>\n<p>协议中并没有这个方法的实现，实体动物类型被要求去实现它。</p>\n<p>现在，我们有一个动物协议，我们可以让每个实体类都遵循它。</p>\n<p>你可以对一个实体类进行标记，在它的声明或者扩展中，代表它遵循了一个协议。</p>\n<p>![image-20220626162949349](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626162949349.png)</p>\n<p>协议并不仅限于类去遵循，我们也可以对结构体、枚举和 actors 使用协议。</p>\n<p>当你写下这个协议遵循的标注，编译器将会检查实体类是否实现了协议中要求的必要条件。</p>\n<p>每个动物类都必须实现 eat(food:) 这个方法，编译器可以推断出喂养所需食物的类型，因为它在参数列表中已经被使用(描述)过了。</p>\n<p>Feed 也可以通过类型别名明确的写出。</p>\n<p>我们成功地确定了动物的通用能力，并且使用协议表达了这些能力。现在，我们可以开始书写泛型代码了。</p>\n<p>我们可以使用动物协议来实现农场的 feed(animal:) 方法，我们想写一种实现，可以对所有的动物实体类型都通用。</p>\n<p>我们使用确定参数的多态，并且引入一个类型参数将会在方法被调用的时候替换为实体类型。</p>\n<p>类型参数是用尖括号包裹写在函数名称后面的，就像通常的变量和函数参数那样，你可以随意给参数类型命名。</p>\n<p>并且就像任何其他的类型那样，你可以在函数体内使用类型参数的名称引用这个类型参数。</p>\n<p>这里我声明了一个类型参数 A，并且使用 A 作为函数参数动物的类型。</p>\n<p>![image-20220626164416814](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626164416814.png)</p>\n<p>我们总是希望实体动物类型遵循动物协议，所以在 A 之后声明其遵循 Animal 协议。</p>\n<p>![image-20220626165033294](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626165033294.png)</p>\n<p>协议遵循可以写在尖括号里，也可以在最后使用 where 语句声明，在这里你还可以指明不同参数类型之间的关系。</p>\n<p>![image-20220626165151422](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626165151422.png)</p>\n<p>命名类型参数和在结尾写 wehre 语句是非常有力量的，因为它允许你写出复杂的必要条件与类型关系。但是大多数的泛型函数不需要这样的通用性。</p>\n<p>让我们把焦点放在 feed(animal:) 方法上。</p>\n<p>类型参数 A 在参数列表中出现过一次，而 where 语句罗列出了类型参数必要条件的遵循情况。</p>\n<p>在这种情况下，命名类型参数和使用 where 语句让这个方法看起来过于复杂。</p>\n<p>![image-20220626165501956](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626165501956.png)</p>\n<p>这种泛型样式是相当常见的，所以有更简单的方式表达它。</p>\n<p>不再明确写出类型参数，我们可以就协议的遵循情况通过写成 some Animal 来表达这个抽象类型，这种声明方式跟前面的是等价的，但是那些不必要的参数列表和 where 语句都消失了，因为我们并不需要它们所提供的这种表达形式，使用 some Animal 更加直接。因为它减少了语法干扰，还在参数声明的右边包含了关于动物参数的语义信息。</p>\n<p>![image-20220626170002361](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626170002361.png)</p>\n<p>让我们看看 some Animal 的语法。</p>\n<p>some 暗示这里有一个具体的类型，some 之后总是会跟着一个要遵循的协议。</p>\n<p>在这个场景里，具体的类型必须遵循 Animal 协议，这允许我们在参数值上使用 Animal 协议中的必要条件(这允许我们对这个参数调用 Animal 协议中声明的方法)。</p>\n<p>some 关键字可以在参数和返回值的类型中使用，如果你之前写过 SwiftUI 代码，你早就用过 some 在返回值的位置使用 some View。</p>\n<p>返回值的类型 some View 跟这里恰恰是完全相同的概念。在 SwiftUI 的视图中，body 属性返回某个具体类型的视图，但是使用 body 属性的代码并不需要知道这个具体的类型是什么。</p>\n<p>![image-20220626170932734](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626170932734.png)</p>\n<p>让我们返回回去更好的理解一下一个具体抽象类型的概念。</p>\n<p>一个抽象类型代表一个具体的实体类型的占位符叫做“不透明类型”。</p>\n<p>被替换的具体的实体类型类型叫做(underlying)基本类型，对于不透明类型的值，在值的使用范围内，基本类型是固定的。</p>\n<p>这样，泛型代码使用的值就被保证了值每次被访问的时候，都会获取到相同的基本类型。</p>\n<p>使用 some 关键字的类型，和一个用尖括号命名的类型参数，都声明了一个不透明类型。</p>\n<p>![image-20220626173329398](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626173329398.png)</p>\n<p>不透明类型在输入输出中都可以使用，所以它们可以声明在参数的位置，或是返回值的位置。</p>\n<p>![image-20220626173435799](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626173435799.png)</p>\n<p>函数的箭头将这两个位置分为两部分。</p>\n<p>![image-20220626173940091](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626173940091.png)</p>\n<p>不透明类型的位置决定了程序的哪个部分可以看到抽象类型，以及程序的哪个部分决定实体类型。</p>\n<p>命名类型参数总是声明在输入侧，所以调用者决定了基本类型，而实现使用了抽象类型。</p>\n<p>![image-20220626174210668](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626174210668.png)</p>\n<p>通常情况下，提供不透明类型参数或返回值类型的那部分程序，决定了基本类型；而使用这个值的那部分程序可以看到抽象类型。</p>\n<p>让我们深入了解一下这是怎么运转起来的。跟着我们对参数和返回值的直觉走。</p>\n<p>因为基本类型是通过一个值推断出来的，基本类型总是跟值一起出现在相同的位置。</p>\n<p>对于一个本地变量来说，基本类型是通过右边的赋值操作推断出来的，这意味着有着不透明类型的本地变量总是需要一个初始值。</p>\n<p>![image-20220626174951554](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626174951554.png)</p>\n<p>如果你不给提供初始值，编译器将会报错。</p>\n<p>![image-20220626175035323](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175035323.png)</p>\n<p>基本类型必须在变量的使用范围内被固定，所以对基本类型进行修改的尝试也会得出一个错误的结果。</p>\n<p>![image-20220626175134539](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175134539.png)</p>\n<p>对于使用不透明类型的参数来说，基本类型是在被调用的位置传入的实参值推断出来的。</p>\n<p>![image-20220626175314696](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175314696.png)</p>\n<p>在参数位置使用 some 是 Swift 5.7 新增的功能。</p>\n<p>![image-20220626175447382](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175447382.png)</p>\n<p>基本类型只需要在参数的使用范围内被固定，所以每次调用都可以提供一个类型不同的参数。</p>\n<p>![image-20220626175640411](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175640411.png)</p>\n<p>对不透明类型的返回值来说，基本类型是在函数实现中的返回值的位置进行推断的。</p>\n<p>![image-20220626180718256](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626180718256.png)</p>\n<p>有不透明类型返回值的方法或者计算属性，可以在程序的任何位置被调用，所以这个值的可用范围是全局的。这意味着，返回值的基本类型需要在所有的返回语句中保持一致。如果没有保持一致，编译器将会报错，基本类型返回值的类型不匹配。</p>\n<p>![image-20220626181045890](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626181045890.png)</p>\n<p>对于不透明类型的 SwiftUI View，ViewBuilder DSL 可以将控制流语句的每个分支都转换成拥有相同基本类型的返回值。</p>\n<p>所以在这个场景下，我们可以使用 ViewBuilder DSL 来解决这个问题。在方法前写一个修饰符 @ViewBuilder，并且移除掉 return 语句，将会允许通过 ViewBuilder 的类型来为我们构建返回值类型。</p>\n<p>![image-20220626181303429](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626181303429.png)</p>\n<p>让我们回到 feedAnimal 方法吧。</p>\n<p>我将会使用 some 在参数列表中，因为我并不需要在其他位置引用这个参数类型。当你需要多次引用这个不透明类型时，也就是说类型参数在手边。</p>\n<p>![image-20220626181701328](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626181701328.png)</p>\n<p>举个例子，当我们给 Animal 协议添加另外一个关联值，Habitat。</p>\n<p>![image-20220626181844443](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626181844443.png)</p>\n<p>我们也许想要在农场上为某个指定的动物构建一个栖息地，这个场景下，返回值类型就依赖于这个具体的动物的类型了，所以我们需要用类型参数 A 作为参数的类型，和返回值类型。</p>\n<p>![image-20220626183735613](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626183735613.png)</p>\n<p>另一个常你需要多次使用不透明类型的见的地方，是在泛型中。代码通常在泛型类型上声明一个类型参数，给一个存储属性使用类型参数，或者给一个成员构造器传递参数。</p>\n<p>![image-20220626184243060](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626184243060.png)</p>\n<p>在不同的上下文中引用泛型类型，也需要你用尖括号明确指出类型参数。在声明中的尖括号里的泛型可以帮助阐明如何使用一个泛型类型，所以不透明类型必须总是被命名为泛型类型。</p>\n<p>![image-20220626190535609](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626190535609.png)</p>\n<p>现在，让我们一起构造出 feed 方法的实现吧。</p>\n<p>我们可以使用动物参数的类型来访问种植的庄稼类型，通过 Feed 的关联类型。我们调用 Feed.grow() 来获取庄稼实例，这个庄稼可以产出要用来喂动物进食的类型的食物。</p>\n<p>![image-20220626190910250](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626190910250.png)</p>\n<p>接下来，我们需要收割庄稼的产出，可以通过调用庄稼的一个方法 harvest()</p>\n<p>![image-20220626191404371](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626191404371.png)</p>\n<p>最后我们可以把产出的食物喂给动物吃，因为基本的动物类型是固定的，编译器知道植物类型与产出食物类型，以及在多个方法之间调用的动物类型之间的关系。</p>\n<p>![image-20220626191534121](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626191534121.png)</p>\n<p>这些静态的关系阻止我们给动物喂错食物。</p>\n<p>如果我们尝试使用没有被保证可以为这个动物喂养的食物类型，编译器就会告诉我们。</p>\n<p>![image-20220626191900776](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626191900776.png)</p>\n<p>想要学习其他的农场协议是如何定义，并用来表达喂养动物的类型和它的植物之间关系的，请参考 110353</p>\n<p>![image-20220626193714763](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626193714763.png)</p>\n<p>最后，让我们添加一个 feedAll(animals:) 方法，接收一个数组作为参数，我知道元素类型需要遵循 Animal 协议，但是我希望这个数组可以存储不同类型的动物。</p>\n<p>![image-20220626202924050](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626202924050.png)</p>\n<p>让我们看看这里用不透明类型 some Animal 是否可行。</p>\n<p>![image-20220626203030188](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626203030188.png)</p>\n<p>使用 some，这里有一个具体的基本类型不能发生改变，因为基本类型是固定的，数组中所有的元素都必须是相同的类型，所以，用 some Animal 描述数组元素的类型并不能准确表达我们的意图。因为我想要一个可以存储不同类型元素的数组。</p>\n<p>![image-20220626203102314](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626203102314.png)</p>\n<p>这里，我们需要一个可以代表任何动物的超类，我们可以使用 any Animal 来表示任意类型的动物。</p>\n<p>![image-20220626203544327](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626203544327.png)</p>\n<p>any 关键字表明这个类型可以存储任意类型的动物，基本类型在运行时也可以改变。</p>\n<p>就像 some 关键字那样，any 关键字后也跟随着一个要遵循的协议，任何动物都是一个单一的静态类型，拥有动态存储任意动物实体类型的能力。这个能力允许我们对值类型使用子类多态。为了允许这个灵活的存储，any Animal 在内存中有一个特殊的表达。</p>\n<p>你可以把这种表达形式想成一个盒子，有时候，值能够直接装进盒子。</p>\n<p>![image-20220626204305609](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626204305609.png)</p>\n<p>另外一些值太大了盒子装不下，</p>\n<p>![image-20220626204414695](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626204414695.png)</p>\n<p>所以值需要在其他位置分配内存空间，盒子只是用一个指针指向这个空间。</p>\n<p>![image-20220626204442868](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626204442868.png)</p>\n<p>any Animal 这个静态类型可以动态存储任何实体类型这种行为被正式的成为存在主义类型。</p>\n<p>![image-20220626204819602](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626204819602.png)</p>\n<p>对不同实体类型使用相同表达的策略叫做类型擦除。</p>\n<p>在编译时，实体类型的类型被擦除，直到运行时才被体现出来。</p>\n<p>存在类型 any Animal 的这两个实例，有相同的静态类型，但是不同的动态类型。</p>\n<p>类型擦除消除了不同动物在类型级别的区别，这允许我们使用静态类型相同但动态类型不同的值。</p>\n<p>![image-20220626205158501](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626205158501.png)</p>\n<p>我们可以使用类型擦除来书写一个异源值类型数组，这正是我们在 feedAll(animals:) 方法中所需要的。</p>\n<p>![image-20220626205642059](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626205642059.png)</p>\n<p>所以我们使用一个数组，用 any Animal 作为参数的类型，对协议使用 any 关键字和关联类型是 Swift 5.7 新增的功能。</p>\n<p>为了实现 feedAll(animals:) 方法，我们首先遍历这个 animals 数组。</p>\n<p>![image-20220626205904465](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626205904465.png)</p>\n<p>对于每个动物，我们都想调用 Animal 协议中的 eat(food:) 方法。</p>\n<p>![image-20220626210014893](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626210014893.png)</p>\n<p>为了调用这个方法，在这次遍历中，我们需要获取到具体的基本类型 Feed 的类型。</p>\n<p>![image-20220626210159916](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626210159916.png)</p>\n<p>但是一旦我们对 any Animal 调用 eat(food:) 方法，我们将会得到一个编译错误。</p>\n<p>![image-20220626210358657](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626210358657.png)</p>\n<p>因为我们消除了具体动物类型在编译时类型级别的区别，我们也消除了所有类型之间的关系，这些关系本身是依赖于具体的动物类型的，也包括关联类型。</p>\n<p>所以我们不知道这个类型的动物希望被喂什么类型的食物。为了能够依赖这些类型之间的关系，我们需要回到之前动物的具体类型仍然固定的上下文，不再直接对 any Animal 调用 eat(food:) 方法，我们需要调用可以接收 some Animal 的 feed 方法。</p>\n<p>![image-20220626211117177](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626211117177.png)</p>\n<p>any Animal 跟 some Animal 是不同的，但是编译器可以通过“拆包”基本类型值的方式将 any Animal 的实例转换为 some Animal，并且把它直接传给 some Animal 参数。</p>\n<p>这个“拆包”实参的能力是 Swift 5. 7 新增的。</p>\n<p>![image-20220626211430157](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626211430157.png)</p>\n<p>你可以把拆包看作是编译器打开了盒子并取出了存在其中的值。</p>\n<p>some Animal 参数的使用范围内，这个值都有一个固定的基本类型。所以我们可以访问所有对基本类型的操作，包括访问关联类型。</p>\n<p>这真的很酷，因为它允许我们在需要的时候选择灵活存储，同时也可以回到之前的拥有函数体内可使用范围的固定基本类型的静态类型系统完整表达的上下文。</p>\n<p>大多数情况下，你并不需要去考虑拆包，因为它就是按照你期待的方式工作的，与对 any Animal 调用协议方法类似，就是对基本类型调用这个方法。</p>\n<p>所以我们可以对每个动物都调用 feed(animal:) 方法，在那里，每次遍历我们都可以种植并且收割合适的庄稼来喂养具体的动物。</p>\n<p>![image-20220626215127833](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626215127833.png)</p>\n<p>在这个过程中，我们看到了 some 和 any 不同的能力。</p>\n<p>使用 some，基本类型就是固定的，这允许你在泛型代码中依赖于固定类型之间的关系，所以你有对 API 和协议关联类型的完整的访问权限。</p>\n<p>使用 any，当你需要存储任意实体类型时，any 提供了类型擦除，允许你表达异源集合，表达基本类型的缺席，使用可选项，同时抽象实现细节。</p>\n<p>![image-20220626215828321](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626215828321.png)</p>\n<p>总而言之，默认情况下使用 some，当你想要存储任意类型的值时，将 some 改为 any。</p>\n<p>使用这种方式，只在你需要存储灵活性时，付出类型擦除和语义限制的代价即可。</p>\n<p>这个工作流程与默认书写 let 表示常量，直到你需要变量时类似。</p>\n<p>在这个视频中，我们想要通过这个工作流程随着代码的演进来生成代码并且获得更多的功能。</p>\n<p>我们从实体类型开始，随着代码获得更多的功能，我们发觉在不同的类型中的代码重复。从这里开始，我们确定了通用的能力，并且使用协议生成了这些能力，最后我们用 some 和 any 写了抽象代码，并且讨论了我们倾向于使用 some 来书写更具有表达性的代码。</p>\n<p>想要更深入的构建协议和理解类型擦除，可以看 110353。</p>\n<p>![image-20220626220750663](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626220750663.png)</p>\n"},{"_content":"[TOC]\n\n# WWDC 22 - 110352 拥抱 Swift 泛型 概述&大纲\n\n\n\n## 概述\n\n### 1. 泛型是什么，什么时间用？\n\n泛型是一个书写 Swift 抽象代码的基本工具，随着代码的演化发展，泛型是起到管理复杂性的关键。\n\n### 2. 抽象是什么，怎么做？\n\n抽象概念可以将思想从特定的细节中分离出来，用泛型。\n\n\n\n## 多态分类\n\n![image-20220628195428703](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220628195428703.png)\n\n\n\n### Overloads 重载实现临时多态\n\n![image-20220626141648138](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626141648138.png)\n\n![image-20220626142527042](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626142527042.png)\n\n\n\n### Subtypes 子类化实现子类多态\n\n#### Any\n\n![image-20220626150958877](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626150958877.png)\n\n\n\n####  \\<T\\> 泛型\n\n![image-20220626152712935](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626152712935.png)\n\n![image-20220626153746315](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626153746315.png)\n\n**根本问题是，类是一种数据类型，我们却想要尝试复杂化一个超类，然后让它代表实体类型的抽象思想。**\n\n\n\n### Generics 泛型实现确定参数多态\n\n#### 接口定义\n\n![image-20220626160017654](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626160017654.png)\n\n![image-20220626160729154](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626160729154.png)\n\n\n\n#### 协议遵循\n\n![image-20220626162949349](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626162949349.png)\n\n\n\n#### 不透明类型\n\n##### 格式\n\n![image-20220626173329398](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626173329398.png)\n\n###### feed<A: Animal>(_ animal: A)\n\n![image-20220626165033294](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626165033294.png)\n\n###### feed<A>(_ animal: A) where A: Animal\n\n![image-20220626165151422](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626165151422.png)\n\n###### feed(_ animal: some Animal)\n\n![image-20220626170002361](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626170002361.png)\n\n![image-20220626170932734](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626170932734.png)\n\n\n\n##### 位置\n\n![image-20220626173940091](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626173940091.png)\n\n![image-20220626174210668](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626174210668.png)\n\n\n\n###### 返回值位置使用 some\n\n![image-20220626180718256](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626180718256.png)\n\n![image-20220626181045890](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626181045890.png)\n\n![image-20220626181303429](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626181303429.png)\n\n\n\n###### 参数位置使用 some——Swift 5.7\n\n![image-20220626175447382](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175447382.png)\n\n![image-20220626175640411](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175640411.png)\n\n\n\n###### 举例说明\n\n![image-20220626191534121](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626191534121.png)\n\n\n\n###### 参数位置使用 any——Swift 5.7\n\n![image-20220626205642059](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626205642059.png)\n\n\n\n###### 举例说明\n\n![image-20220626203030188](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626203030188.png)\n\n![image-20220626203102314](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626203102314.png)\n\n![image-20220626204819602](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626204819602.png)\n\n![image-20220626205158501](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626205158501.png)\n\n![image-20220626205904465](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626205904465.png)\n\n![image-20220626210358657](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626210358657.png)\n\n![image-20220626211430157](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626211430157.png)\n\n![image-20220626215127833](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626215127833.png)\n\n\n\n#### 总结\n\n![image-20220626215828321](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626215828321.png)\n\n\n\n## 总结\n\n![image-20220626220750663](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626220750663.png)\n\n","source":"_drafts/WWDC 22 - 110352 拥抱 Swift 泛型 概述&大纲.md","raw":"[TOC]\n\n# WWDC 22 - 110352 拥抱 Swift 泛型 概述&大纲\n\n\n\n## 概述\n\n### 1. 泛型是什么，什么时间用？\n\n泛型是一个书写 Swift 抽象代码的基本工具，随着代码的演化发展，泛型是起到管理复杂性的关键。\n\n### 2. 抽象是什么，怎么做？\n\n抽象概念可以将思想从特定的细节中分离出来，用泛型。\n\n\n\n## 多态分类\n\n![image-20220628195428703](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220628195428703.png)\n\n\n\n### Overloads 重载实现临时多态\n\n![image-20220626141648138](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626141648138.png)\n\n![image-20220626142527042](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626142527042.png)\n\n\n\n### Subtypes 子类化实现子类多态\n\n#### Any\n\n![image-20220626150958877](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626150958877.png)\n\n\n\n####  \\<T\\> 泛型\n\n![image-20220626152712935](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626152712935.png)\n\n![image-20220626153746315](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626153746315.png)\n\n**根本问题是，类是一种数据类型，我们却想要尝试复杂化一个超类，然后让它代表实体类型的抽象思想。**\n\n\n\n### Generics 泛型实现确定参数多态\n\n#### 接口定义\n\n![image-20220626160017654](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626160017654.png)\n\n![image-20220626160729154](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626160729154.png)\n\n\n\n#### 协议遵循\n\n![image-20220626162949349](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626162949349.png)\n\n\n\n#### 不透明类型\n\n##### 格式\n\n![image-20220626173329398](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626173329398.png)\n\n###### feed<A: Animal>(_ animal: A)\n\n![image-20220626165033294](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626165033294.png)\n\n###### feed<A>(_ animal: A) where A: Animal\n\n![image-20220626165151422](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626165151422.png)\n\n###### feed(_ animal: some Animal)\n\n![image-20220626170002361](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626170002361.png)\n\n![image-20220626170932734](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626170932734.png)\n\n\n\n##### 位置\n\n![image-20220626173940091](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626173940091.png)\n\n![image-20220626174210668](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626174210668.png)\n\n\n\n###### 返回值位置使用 some\n\n![image-20220626180718256](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626180718256.png)\n\n![image-20220626181045890](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626181045890.png)\n\n![image-20220626181303429](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626181303429.png)\n\n\n\n###### 参数位置使用 some——Swift 5.7\n\n![image-20220626175447382](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175447382.png)\n\n![image-20220626175640411](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175640411.png)\n\n\n\n###### 举例说明\n\n![image-20220626191534121](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626191534121.png)\n\n\n\n###### 参数位置使用 any——Swift 5.7\n\n![image-20220626205642059](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626205642059.png)\n\n\n\n###### 举例说明\n\n![image-20220626203030188](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626203030188.png)\n\n![image-20220626203102314](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626203102314.png)\n\n![image-20220626204819602](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626204819602.png)\n\n![image-20220626205158501](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626205158501.png)\n\n![image-20220626205904465](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626205904465.png)\n\n![image-20220626210358657](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626210358657.png)\n\n![image-20220626211430157](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626211430157.png)\n\n![image-20220626215127833](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626215127833.png)\n\n\n\n#### 总结\n\n![image-20220626215828321](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626215828321.png)\n\n\n\n## 总结\n\n![image-20220626220750663](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626220750663.png)\n\n","slug":"WWDC 22 - 110352 拥抱 Swift 泛型 概述&大纲","published":0,"date":"2022-06-29T06:25:44.438Z","updated":"2022-07-01T06:54:39.379Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ejwd820000o4dxa20hdqmj","content":"<p>[TOC]</p>\n<h1 id=\"WWDC-22-110352-拥抱-Swift-泛型-概述-amp-大纲\"><a href=\"#WWDC-22-110352-拥抱-Swift-泛型-概述-amp-大纲\" class=\"headerlink\" title=\"WWDC 22 - 110352 拥抱 Swift 泛型 概述&amp;大纲\"></a>WWDC 22 - 110352 拥抱 Swift 泛型 概述&amp;大纲</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"1-泛型是什么，什么时间用？\"><a href=\"#1-泛型是什么，什么时间用？\" class=\"headerlink\" title=\"1. 泛型是什么，什么时间用？\"></a>1. 泛型是什么，什么时间用？</h3><p>泛型是一个书写 Swift 抽象代码的基本工具，随着代码的演化发展，泛型是起到管理复杂性的关键。</p>\n<h3 id=\"2-抽象是什么，怎么做？\"><a href=\"#2-抽象是什么，怎么做？\" class=\"headerlink\" title=\"2. 抽象是什么，怎么做？\"></a>2. 抽象是什么，怎么做？</h3><p>抽象概念可以将思想从特定的细节中分离出来，用泛型。</p>\n<h2 id=\"多态分类\"><a href=\"#多态分类\" class=\"headerlink\" title=\"多态分类\"></a>多态分类</h2><p>![image-20220628195428703](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220628195428703.png)</p>\n<h3 id=\"Overloads-重载实现临时多态\"><a href=\"#Overloads-重载实现临时多态\" class=\"headerlink\" title=\"Overloads 重载实现临时多态\"></a>Overloads 重载实现临时多态</h3><p>![image-20220626141648138](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626141648138.png)</p>\n<p>![image-20220626142527042](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626142527042.png)</p>\n<h3 id=\"Subtypes-子类化实现子类多态\"><a href=\"#Subtypes-子类化实现子类多态\" class=\"headerlink\" title=\"Subtypes 子类化实现子类多态\"></a>Subtypes 子类化实现子类多态</h3><h4 id=\"Any\"><a href=\"#Any\" class=\"headerlink\" title=\"Any\"></a>Any</h4><p>![image-20220626150958877](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626150958877.png)</p>\n<h4 id=\"lt-T-gt-泛型\"><a href=\"#lt-T-gt-泛型\" class=\"headerlink\" title=\"&lt;T&gt; 泛型\"></a>&lt;T&gt; 泛型</h4><p>![image-20220626152712935](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626152712935.png)</p>\n<p>![image-20220626153746315](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626153746315.png)</p>\n<p><strong>根本问题是，类是一种数据类型，我们却想要尝试复杂化一个超类，然后让它代表实体类型的抽象思想。</strong></p>\n<h3 id=\"Generics-泛型实现确定参数多态\"><a href=\"#Generics-泛型实现确定参数多态\" class=\"headerlink\" title=\"Generics 泛型实现确定参数多态\"></a>Generics 泛型实现确定参数多态</h3><h4 id=\"接口定义\"><a href=\"#接口定义\" class=\"headerlink\" title=\"接口定义\"></a>接口定义</h4><p>![image-20220626160017654](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626160017654.png)</p>\n<p>![image-20220626160729154](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626160729154.png)</p>\n<h4 id=\"协议遵循\"><a href=\"#协议遵循\" class=\"headerlink\" title=\"协议遵循\"></a>协议遵循</h4><p>![image-20220626162949349](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626162949349.png)</p>\n<h4 id=\"不透明类型\"><a href=\"#不透明类型\" class=\"headerlink\" title=\"不透明类型\"></a>不透明类型</h4><h5 id=\"格式\"><a href=\"#格式\" class=\"headerlink\" title=\"格式\"></a>格式</h5><p>![image-20220626173329398](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626173329398.png)</p>\n<h6 id=\"feed-lt-A-Animal-gt-animal-A\"><a href=\"#feed-lt-A-Animal-gt-animal-A\" class=\"headerlink\" title=\"feed&lt;A: Animal&gt;(_ animal: A)\"></a>feed&lt;A: Animal&gt;(_ animal: A)</h6><p>![image-20220626165033294](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626165033294.png)</p>\n<h6 id=\"feed-animal-A-where-A-Animal\"><a href=\"#feed-animal-A-where-A-Animal\" class=\"headerlink\" title=\"feed(_ animal: A) where A: Animal\"></a>feed<A>(_ animal: A) where A: Animal</h6><p>![image-20220626165151422](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626165151422.png)</p>\n<h6 id=\"feed-animal-some-Animal\"><a href=\"#feed-animal-some-Animal\" class=\"headerlink\" title=\"feed(_ animal: some Animal)\"></a>feed(_ animal: some Animal)</h6><p>![image-20220626170002361](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626170002361.png)</p>\n<p>![image-20220626170932734](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626170932734.png)</p>\n<h5 id=\"位置\"><a href=\"#位置\" class=\"headerlink\" title=\"位置\"></a>位置</h5><p>![image-20220626173940091](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626173940091.png)</p>\n<p>![image-20220626174210668](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626174210668.png)</p>\n<h6 id=\"返回值位置使用-some\"><a href=\"#返回值位置使用-some\" class=\"headerlink\" title=\"返回值位置使用 some\"></a>返回值位置使用 some</h6><p>![image-20220626180718256](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626180718256.png)</p>\n<p>![image-20220626181045890](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626181045890.png)</p>\n<p>![image-20220626181303429](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626181303429.png)</p>\n<h6 id=\"参数位置使用-some——Swift-5-7\"><a href=\"#参数位置使用-some——Swift-5-7\" class=\"headerlink\" title=\"参数位置使用 some——Swift 5.7\"></a>参数位置使用 some——Swift 5.7</h6><p>![image-20220626175447382](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175447382.png)</p>\n<p>![image-20220626175640411](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175640411.png)</p>\n<h6 id=\"举例说明\"><a href=\"#举例说明\" class=\"headerlink\" title=\"举例说明\"></a>举例说明</h6><p>![image-20220626191534121](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626191534121.png)</p>\n<h6 id=\"参数位置使用-any——Swift-5-7\"><a href=\"#参数位置使用-any——Swift-5-7\" class=\"headerlink\" title=\"参数位置使用 any——Swift 5.7\"></a>参数位置使用 any——Swift 5.7</h6><p>![image-20220626205642059](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626205642059.png)</p>\n<h6 id=\"举例说明-1\"><a href=\"#举例说明-1\" class=\"headerlink\" title=\"举例说明\"></a>举例说明</h6><p>![image-20220626203030188](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626203030188.png)</p>\n<p>![image-20220626203102314](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626203102314.png)</p>\n<p>![image-20220626204819602](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626204819602.png)</p>\n<p>![image-20220626205158501](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626205158501.png)</p>\n<p>![image-20220626205904465](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626205904465.png)</p>\n<p>![image-20220626210358657](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626210358657.png)</p>\n<p>![image-20220626211430157](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626211430157.png)</p>\n<p>![image-20220626215127833](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626215127833.png)</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>![image-20220626215828321](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626215828321.png)</p>\n<h2 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>![image-20220626220750663](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626220750663.png)</p>\n","site":{"data":{}},"excerpt":"","more":"<p>[TOC]</p>\n<h1 id=\"WWDC-22-110352-拥抱-Swift-泛型-概述-amp-大纲\"><a href=\"#WWDC-22-110352-拥抱-Swift-泛型-概述-amp-大纲\" class=\"headerlink\" title=\"WWDC 22 - 110352 拥抱 Swift 泛型 概述&amp;大纲\"></a>WWDC 22 - 110352 拥抱 Swift 泛型 概述&amp;大纲</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"1-泛型是什么，什么时间用？\"><a href=\"#1-泛型是什么，什么时间用？\" class=\"headerlink\" title=\"1. 泛型是什么，什么时间用？\"></a>1. 泛型是什么，什么时间用？</h3><p>泛型是一个书写 Swift 抽象代码的基本工具，随着代码的演化发展，泛型是起到管理复杂性的关键。</p>\n<h3 id=\"2-抽象是什么，怎么做？\"><a href=\"#2-抽象是什么，怎么做？\" class=\"headerlink\" title=\"2. 抽象是什么，怎么做？\"></a>2. 抽象是什么，怎么做？</h3><p>抽象概念可以将思想从特定的细节中分离出来，用泛型。</p>\n<h2 id=\"多态分类\"><a href=\"#多态分类\" class=\"headerlink\" title=\"多态分类\"></a>多态分类</h2><p>![image-20220628195428703](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220628195428703.png)</p>\n<h3 id=\"Overloads-重载实现临时多态\"><a href=\"#Overloads-重载实现临时多态\" class=\"headerlink\" title=\"Overloads 重载实现临时多态\"></a>Overloads 重载实现临时多态</h3><p>![image-20220626141648138](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626141648138.png)</p>\n<p>![image-20220626142527042](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626142527042.png)</p>\n<h3 id=\"Subtypes-子类化实现子类多态\"><a href=\"#Subtypes-子类化实现子类多态\" class=\"headerlink\" title=\"Subtypes 子类化实现子类多态\"></a>Subtypes 子类化实现子类多态</h3><h4 id=\"Any\"><a href=\"#Any\" class=\"headerlink\" title=\"Any\"></a>Any</h4><p>![image-20220626150958877](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626150958877.png)</p>\n<h4 id=\"lt-T-gt-泛型\"><a href=\"#lt-T-gt-泛型\" class=\"headerlink\" title=\"&lt;T&gt; 泛型\"></a>&lt;T&gt; 泛型</h4><p>![image-20220626152712935](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626152712935.png)</p>\n<p>![image-20220626153746315](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626153746315.png)</p>\n<p><strong>根本问题是，类是一种数据类型，我们却想要尝试复杂化一个超类，然后让它代表实体类型的抽象思想。</strong></p>\n<h3 id=\"Generics-泛型实现确定参数多态\"><a href=\"#Generics-泛型实现确定参数多态\" class=\"headerlink\" title=\"Generics 泛型实现确定参数多态\"></a>Generics 泛型实现确定参数多态</h3><h4 id=\"接口定义\"><a href=\"#接口定义\" class=\"headerlink\" title=\"接口定义\"></a>接口定义</h4><p>![image-20220626160017654](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626160017654.png)</p>\n<p>![image-20220626160729154](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626160729154.png)</p>\n<h4 id=\"协议遵循\"><a href=\"#协议遵循\" class=\"headerlink\" title=\"协议遵循\"></a>协议遵循</h4><p>![image-20220626162949349](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626162949349.png)</p>\n<h4 id=\"不透明类型\"><a href=\"#不透明类型\" class=\"headerlink\" title=\"不透明类型\"></a>不透明类型</h4><h5 id=\"格式\"><a href=\"#格式\" class=\"headerlink\" title=\"格式\"></a>格式</h5><p>![image-20220626173329398](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626173329398.png)</p>\n<h6 id=\"feed-lt-A-Animal-gt-animal-A\"><a href=\"#feed-lt-A-Animal-gt-animal-A\" class=\"headerlink\" title=\"feed&lt;A: Animal&gt;(_ animal: A)\"></a>feed&lt;A: Animal&gt;(_ animal: A)</h6><p>![image-20220626165033294](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626165033294.png)</p>\n<h6 id=\"feed-animal-A-where-A-Animal\"><a href=\"#feed-animal-A-where-A-Animal\" class=\"headerlink\" title=\"feed(_ animal: A) where A: Animal\"></a>feed<A>(_ animal: A) where A: Animal</h6><p>![image-20220626165151422](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626165151422.png)</p>\n<h6 id=\"feed-animal-some-Animal\"><a href=\"#feed-animal-some-Animal\" class=\"headerlink\" title=\"feed(_ animal: some Animal)\"></a>feed(_ animal: some Animal)</h6><p>![image-20220626170002361](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626170002361.png)</p>\n<p>![image-20220626170932734](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626170932734.png)</p>\n<h5 id=\"位置\"><a href=\"#位置\" class=\"headerlink\" title=\"位置\"></a>位置</h5><p>![image-20220626173940091](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626173940091.png)</p>\n<p>![image-20220626174210668](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626174210668.png)</p>\n<h6 id=\"返回值位置使用-some\"><a href=\"#返回值位置使用-some\" class=\"headerlink\" title=\"返回值位置使用 some\"></a>返回值位置使用 some</h6><p>![image-20220626180718256](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626180718256.png)</p>\n<p>![image-20220626181045890](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626181045890.png)</p>\n<p>![image-20220626181303429](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626181303429.png)</p>\n<h6 id=\"参数位置使用-some——Swift-5-7\"><a href=\"#参数位置使用-some——Swift-5-7\" class=\"headerlink\" title=\"参数位置使用 some——Swift 5.7\"></a>参数位置使用 some——Swift 5.7</h6><p>![image-20220626175447382](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175447382.png)</p>\n<p>![image-20220626175640411](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175640411.png)</p>\n<h6 id=\"举例说明\"><a href=\"#举例说明\" class=\"headerlink\" title=\"举例说明\"></a>举例说明</h6><p>![image-20220626191534121](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626191534121.png)</p>\n<h6 id=\"参数位置使用-any——Swift-5-7\"><a href=\"#参数位置使用-any——Swift-5-7\" class=\"headerlink\" title=\"参数位置使用 any——Swift 5.7\"></a>参数位置使用 any——Swift 5.7</h6><p>![image-20220626205642059](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626205642059.png)</p>\n<h6 id=\"举例说明-1\"><a href=\"#举例说明-1\" class=\"headerlink\" title=\"举例说明\"></a>举例说明</h6><p>![image-20220626203030188](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626203030188.png)</p>\n<p>![image-20220626203102314](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626203102314.png)</p>\n<p>![image-20220626204819602](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626204819602.png)</p>\n<p>![image-20220626205158501](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626205158501.png)</p>\n<p>![image-20220626205904465](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626205904465.png)</p>\n<p>![image-20220626210358657](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626210358657.png)</p>\n<p>![image-20220626211430157](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626211430157.png)</p>\n<p>![image-20220626215127833](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626215127833.png)</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>![image-20220626215828321](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626215828321.png)</p>\n<h2 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>![image-20220626220750663](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626220750663.png)</p>\n"},{"_content":"# WWDC 22 - 110352 拥抱 Swift 泛型 第一次整理\n\n大家好，我是 holly，来自 Swift 编译组，欢迎来到拥抱 Swift 泛型。\n\n泛型是一个书写 Swift 抽象代码的基本工具，随着代码的演化发展，泛型是起到管理复杂性的关键。\n\n抽象概念可以将思想从特定的细节中分离出来，在代码中，有很多种方式(途径)可以使用泛型(泛型都起到了作用)。\n\n你可能经常使用到的一种抽象概念的形式就是将代码抽出来到一个函数或是一个局部变量，如果你想要多次使用同一功能或同一个值时，这是非常有用的。\n\n当你把一个功能提取到一个函数里时，函数的细节就被抽出去(抽象化)了，而使用(调用)个抽象函数的代码，就可以表达所发生的事情，而不需要重复细节了。\n\n在 Swift 中，你也可以将实体类型抽象出来，如果你有一系列的类型，它们使用了相同的思想，和不同的实现细节，你就可以写抽象的代码来实现所有这些实体类型。\n\n今天，我们将通过模型化实体类型、确定一系列实体类型的通用能力、构建一个接口来表达(呈现)这些能力、深入了解如何使用这些接口来实现泛型的书写的步骤来向你展示泛型的具体使用场景。\n\n![image-20220626140259410](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626140259410.png)\n\n我们将通过构建一些代码来模拟一个农场的形式，一起探索 Swift 抽象工具的使用。\n\n\n\n## Model with concrete types\n\n让我们先来写几个实体类型吧。\n\n首先创建一个叫做 Cow 的结构体，它有一个方法叫做 eat(food:)，接收一个 Hay 类型的参数。\n\nHay 是另一个结构体，它有一个**静态**方法叫做 grow() -> Alfalfa，可以种植一些能够长出 Hay 的庄稼 Alfalfa。\n\nAlfalfa 结构体有一个方法 harvest() -> Hay 通过 Alfalfa 实例来收获 Hay。\n\n最后，我们抽象出一个农场 Farm，它有一个方法 feed(animal:) 可以喂养奶牛。\n\nfeed(animal:) 方法可以通过首先种一些苜蓿 Alfalfa 来生产干草 Hay，然后收获干草 Hay ，最后用干草 Hay 来喂养奶牛 Cow 的方式实现。\n\n这时，我就能在我的农场来饲养奶牛了。\n\n![image-20220626141648138](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626141648138.png)\n\n\n\n但是我想饲养更多的动物。\n\n我可以添加更多的结构体来代表其他的动物，就像 Horse 马和 Chicken 鸡。\n\n我想在农场上饲养奶牛，马，鸡。\n\n\n\n### Overloads\n\n我可以重载这个 feed(animal:) 方法分别来接收不同类型的参数，但是每个重载函数都会有一个相当类似的实现。\n\n![image-20220626142527042](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626142527042.png)\n\n当我添加更多的动物类型时，这将造成类似代码的堆积，基本上到处都是重复的代码。\n\n当你发现自己写的重载代码有重复的实现时，就是概括归纳(抽象、重构)的预兆了。\n\n基本上说，这些实现都很类似，因为(饲养)不同类型的动物在功能(喂养)上是相似的。\n\n\n\n## Identify common capabilities\n\n第二步，就是来确定动物类型的通用能力了。\n\n我们已经构建了一系列动物类型了，它们都有一个能力，吃某一种食物。\n\n每种类型的动物都有不同的进食方式，所以每个动物的 eat(food:) 方法都有不同的行为表现。\n\n我们要做的就是允许抽象代码在调用的时候调同一个方法，也就是 eat(food:) 方法，在这个的同时，让这些抽象代码在 eat(food:) 方法中的行为表现不同，这取决于抽象代码所执行在的实体的具体类型。\n\n抽象代码在不同的实体类型上可以表现不同能力的功能叫做多态，多态允许一份代码拥有多种行为表现，取决于代码是被如何使用的。\n\n更恰当地说的话，多态本身就是不同形式的。\n\n首先是函数的重载，根据传入参数类型的不同，同样的函数调用可以意味着不同的事物。重载被称为 ad-hoc(临时安排的、特别的、专门的) 多态，因为它并不是一个通用的解决方案。我们只是为了看到重载到底是如何一步步走向重复代码的。\n\n下一步，是子类多态。代码在一个超类上去执行调用，实际上却会在运行时基于特定的子类而产生不同的表现。\n\n最后是使用泛型来实现的确定(指定)参数的多态。\n\n![image-20220628195428703](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220628195428703.png)\n\n\n\n泛型代码使用类型参数，来允许书写一份代码与不同类型一起奏效(工作、运行)。而实体类型呢，则将作为实参进行传递。\n\n我们早就已经把重载排除出局了，所以让我们尝试使用子类多态吧。\n\n\n\n### Subtypes\n\n代表子类关系的一种方式是使用类层级(用类替换结构体)。我们可以引入一个类叫做 Animal 动物。\n\n![image-20220626145345481](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626145345481.png)\n\n然后，我们将每种动物类型从结构体更改为类。\n\n每个具体的动物类都继承自 Animal 动物这个超类并且重写 eat(food:) 方法。\n\n现在，我们有一个抽象的基类 Animal 动物，可以代表我们每一个具体的动物类型。调用 Animal 动物的 eat(food:) 方法将会通过使用子类多态而调用到子类的具体实现，但这样还没完。\n\n我们仍然没有补全 Animal 动物 eat(:food) 方法的参数类型，这份代码还有一些报错。\n\n首先，使用类将强制我们使用引用类型语义，即使我们并不需要分享不同实例间的任何状态。这个策略也需要子类去重写基类中的方法。但是忘记重写基类方法只有在运行时才会被捕获。\n\n但是对这个模型抽象的过程中更大的问题是每种子类动物都会食用不同类型的食物，这种依赖用类层级相当难以表达。(即 eat(food:) 方法中 food 参数的类型必须明确标明，但是因为每种动物所食用的食物都是不同的，所以很难明确写清楚)\n\n\n\n#### Any\n\n一种方式是让 eat(food:) 方法中食物的参数接收一个不具体(明确)的类型， 例如 Any。\n\n![image-20220626150733935](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626150733935.png)\n\n但是这种策略在子类实现中，仍然需要在运行时确定好准确的类型并传入，这样，在每个重写的方法中又一次出现了代码堆积。(只是把代码堆积的位置改变了而已)\n\n![image-20220626150958877](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626150958877.png)\n\n但是更重要的是，这份代码允许你不小心传入一个错误的食物类型，造成另一个只能在运行时才捕获的 bug。我们再试试别的方法吧。(即使你在调用的时候，传入的食物类型与实际期待的不符，也只会在运行时才会报错)\n\n\n\n####  \\<T\\>\n\n我们可以通过在超类 Animal 动物类上引入一种类型安全的类型参数的方式，来替代表达喂养动物所用食物的类型。\n\n这种类型参数对每一个子类的食物喂养类型使用一个占位符，通过这种方式，Food 参数的类型必须被提升到 Animal 类的声明中才行。\n\n![image-20220626152712935](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626152712935.png)\n\n这看起来有点诡异，因为尽管动物需要食物来填饱肚子，但是进食并不是动物的主要目标，很多与动物相关的代码也许根本不关心它们吃什么食物。尽管如此，所有对 Animal 类的引用(也就是对 Animal 的实例化)都需要指明 Food 的类型。\n\n举个例子，每个 Animal 的子类都需要在声明继承的代码中使用尖括号明确指出它的食物类型，如果我们添加更多需要明确指定的类型给每种 Animal，这种代码模板在每个使用 Animal 类的地方都将变得非常繁琐。\n\n![image-20220626153746315](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626153746315.png)\n\n所以我们上述的两种方式既低效，又不能正确地表达语义。\n\n**根本问题是，类是一种数据类型，我们却想要尝试复杂化一个超类，然后让它代表实体类型的抽象思想。**\n\n取而代之的是，我们想要构建一个能够代表类型的能力，但不需要这个能力实现的细节。\n\n动物有两个常见的能力，每种动物都有一种具体的食物类型，和一种进食方式。\n\n\n\n## Build an interface\n\n我们可以构建一种接口来代表这两种能力。\n\n在 Swift 中，使用协议来实现这种功能。\n\n协议是一种抽象工具，描述了遵循它协议的类型的功能。使用协议，你可以把一个类所做的事情的构思与其具体的实现区分开来。一个类所做的事情的构思用接口来表达。\n\n让我们将动物的能力使用协议接口来翻译一下。\n\n协议的名称代表我们所描述的这种类型的分类(类别、范畴、种类)，所以我管这个协议叫“Animal 动物”。\n\n每个能力都将映射到一个协议的必要条件(要求、接口、方法)上。\n\n食物的具体类型将会映射为协议中的一个关联类型，就像类型参数一样，关联类型也是作为实体类型的占位符。\n\n![image-20220626160017654](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626160017654.png)\n\n关联类型的特别之处在于，它取决于遵循协议的那个类型的具体类型，这层关系是有保障的。所以对应到(每个)具体的动物类型的不同实例都有相同的食物类型。\n\n接下来，进食的行为将会映射为一个方法。这个方法叫做 eat(food:)，它接收一个参数，喂养动物所需食物的类型。\n\n![image-20220626160729154](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626160729154.png)\n\n协议中并没有这个方法的实现，实体动物类型被要求去实现它(具体的动物类型才需要去实现它)。\n\n现在，我们有一个动物协议，我们可以让每个实体动物类型都遵循它。\n\n你可以对一个实体类型进行标记，在它的声明或者扩展中，代表它遵循了一个协议。\n\n![image-20220626162949349](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626162949349.png)\n\n协议并不仅限于类去遵循，我们也可以对结构体、枚举和 actors 使用协议。\n\n当你写下这个协议遵循的标注，编译器将会检查实体类型是否实现了协议中要求的必要条件。\n\n每个动物类型都必须实现 eat(food:) 这个方法，而且编译器可以推断出喂养所需食物的类型，因为它在参数列表中已经被使用(描述)过了(每个具体的类型对 eat 方法的实现里，都传入了具体的 food 参数的类型名称)。\n\nFeed 也可以通过类型别名明确的写出。\n\n\n\n## Write generic code\n\n我们成功地确定了动物的通用能力，并且使用协议表达了这些能力。现在，我们可以开始书写泛型代码了。\n\n\n\n### Generics\n\n我们可以使用动物协议来实现农场的 feed(animal:) 方法，我们想写一种实现，可以对所有的动物实体类型都通用。\n\n我们使用确定参数的多态，并且引入一个类型参数，当方法被调用的时候，类型参数会被替换为实体类型。\n\n类型参数是用尖括号包裹并写在函数名称后面的，就像通常的变量和函数参数那样，你可以随意给参数类型命名。\n\n并且就像任何其他的类型那样，你可以在函数体内使用类型参数的名称引用这个类型参数。\n\n这里我声明了一个类型参数 A，并且使用 A 作为函数参数动物的类型。\n\n![image-20220626164416814](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626164416814.png)\n\n我们总是希望实体动物类型遵循动物协议，所以在尖括号包裹的 A 之后标注其遵循 Animal 协议。\n\n![image-20220626165033294](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626165033294.png)\n\n协议遵循可以写在尖括号里，也可以在语句末尾使用 where 语句声明，在这里你还可以指明不同类型参数之间的关系。\n\n![image-20220626165151422](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626165151422.png)\n\n命名类型参数(也就在用尖括号包裹的类型参数后标注协议遵循)和在语句末尾使用 wehre 语句是非常有力量的，因为它允许你写出复杂的~~必要条件~~(要求)与类型之间的关系。但是大多数的泛型函数不需要这样的通用性。\n\n让我们把焦点放在 feed(animal:) 方法上。\n\n类型参数 A 在参数列表中出现过一次，而 where 语句罗列出了类型参数的必要条件的遵循情况。\n\n在这种情况下，命名类型参数和使用 where 语句让这个方法看起来过于复杂。\n\n![image-20220626165501956](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626165501956.png)\n\n这种泛型样式是相当常见的，所以有更简单的方式表达它。\n\n不再明确写出类型参数，我们可以就协议的遵循情况通过写成 some Animal 来表达这个抽象类型，这种声明方式跟前面的是等价的，但是那些不必要的类型参数列表和 where 语句都消失了，因为我们并不需要它们所提供的这种表达形式，使用 some Animal 更加直接。因为它减少了语法干扰，还在参数声明的右半部分包含了关于动物参数的语义信息。\n\n![image-20220626170002361](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626170002361.png)\n\n\n\n#### some\n\n让我们看看 some Animal 的语法。\n\nsome 暗示这里有某一个具体的类型，some 之后总是会跟着一个要遵循的协议。\n\n在这个场景里，具体的类型必须遵循 Animal 协议，这允许我们在参数值上使用 Animal 协议中的必要条件(这允许我们对这个参数实例调用 Animal 协议中声明的方法)。\n\nsome 关键字可以在函数参数和返回值的类型中使用，如果你之前写过 SwiftUI 代码，你应该早就用过 some，在返回值的位置使用 some View。\n\n返回值的类型 some View 跟这里恰恰是完全相同的概念。在 SwiftUI 的视图中，body 属性返回某个具体类型的视图，但是使用 body 属性的代码并不需要知道这个具体的类型是什么。\n\n![image-20220626170932734](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626170932734.png)\n\n让我们返回回去更好的理解一下一个(具体、特定、某一个)的抽象类型的概念。\n\n代表一个具体的实体类型的占位符的抽象类型叫做“不透明类型”。\n\n被替换的具体的实体类型叫做(underlying)基本类型，对于不透明类型的值，在值的使用范围内，基本类型是固定的。\n\n这样，泛型代码使用的值就被保证了值每次被访问的时候，都会获取到相同的基本类型。\n\n使用 some 关键字的类型，和一个用尖括号命名的类型参数，都声明了一个不透明类型。\n\n![image-20220626173329398](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626173329398.png)\n\n不透明类型在输入输出中都可以使用，所以它们可以声明在函数(方法)参数的位置，或是返回值的位置。\n\n函数的箭头将这两个位置分为两部分。\n\n![image-20220626173940091](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626173940091.png)\n\n不透明类型的位置决定了程序的哪个部分可以看到抽象类型，以及程序的哪个部分决定实体类型。\n\n命名类型参数总是声明在输入侧，所以调用者决定了基本类型，而实现使用了抽象类型。\n\n![image-20220626174210668](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626174210668.png)\n\n通常情况下，提供不透明参数或返回值类型的那部分程序，决定了基本类型；而使用这个值的那部分程序可以看到抽象类型。\n\n\n\n让我们深入了解一下这是怎么运转起来的。跟着我们对参数和返回值的直觉走。\n\n因为基本类型是通过一个值推断出来的，基本类型总是跟值一起出现在相同的位置。\n\n对于一个局部变量来说，基本类型是通过右边的赋值操作推断出来的，这意味着有着不透明类型的局部变量总是需要一个初始值(这样才能推断出其基本类型)。\n\n![image-20220626174951554](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626174951554.png)\n\n如果你不给提供初始值，编译器将会报错。\n\n![image-20220626175035323](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175035323.png)\n\n基本类型必须在变量的使用范围内被固定，所以对基本类型进行修改的尝试也会得出一个错误的结果。\n\n![image-20220626175134539](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175134539.png)\n\n对于使用不透明类型的参数来说，基本类型是在被调用的位置传入的实参值推断出来的。\n\n![image-20220626175314696](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175314696.png)\n\n##### Swift 5.7——参数位置使用 some\n\n在参数位置使用 some 是 Swift 5.7 新增的功能。\n\n![image-20220626175447382](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175447382.png)\n\n基本类型只需要在参数的使用范围内被固定，所以每次调用都可以提供一个类型不同的参数。\n\n![image-20220626175640411](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175640411.png)\n\n\n\n##### 返回值位置使用 some\n\n对不透明类型的返回值来说，基本类型是在函数实现中的返回值的位置进行推断的。\n\n![image-20220626180718256](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626180718256.png)\n\n有不透明类型返回值的方法或者计算属性，可以在程序的任何位置被调用，所以这个值的可用范围是全局的。这意味着，返回值的基本类型需要在所有的返回语句中保持一致。如果没有保持一致，编译器将会报错，基本类型返回值的类型不匹配。\n\n![image-20220626181045890](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626181045890.png)\n\n对于不透明类型的 SwiftUI View，ViewBuilder DSL 可以将控制流语句的每个分支都转换成拥有相同基本类型的返回值。\n\n所以在这个场景下，我们可以使用 ViewBuilder DSL 来解决这个问题。在方法前写一个修饰符 @ViewBuilder，并且移除掉 return 语句，将会允许通过 ViewBuilder 的类型来为我们构建返回值类型。\n\n![image-20220626181303429](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626181303429.png)\n\n\n\n##### 举例说明\n\n让我们回到 feedAnimal 方法吧。\n\n我将会使用 some 在参数列表中，因为我并不需要在其他位置引用这个不透明类型的参数。当你需要在函数体中多次引用这个不透明类型时，也就是说类型参数的名称要能手到擒来。\n\n举个例子，当我们给 Animal 协议添加另外一个关联值，Habitat。\n\n![image-20220626181844443](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626181844443.png)\n\n我们也许想要在农场上为某个指定的动物构建一个栖息地，这个场景下，返回值类型就依赖于这个具体的动物的类型了，所以我们在参数和返回值的位置都需要用到类型参数 A。\n\n![image-20220626183735613](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626183735613.png)\n\n另一个你需要多次引用不透明类型的常见的地方，是在泛型中。代码通常在泛型类型上声明一个类型参数，为一个存储属性使用类型参数，并且也给一个成员构造器传递参数。\n\n![image-20220626184243060](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626184243060.png)\n\n在不同的上下文中引用泛型类型，也需要你用尖括号明确指出类型参数(也就是说在同一个上下文范围内，明确指出一次应该就够了，之后编辑器可以推断出来)。在声明中的尖括号里的泛型可以帮助阐明如何使用一个泛型类型，**所以不透明类型必须总是被命名为泛型类型**。\n\n![image-20220626190535609](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626190535609.png)\n\n现在，让我们一起构造出 feed 方法的实现吧。\n\n\n\n我们可以使用动物参数的类型来访问种植的庄稼类型，通过 Feed 的关联类型。我们调用 Feed.grow() 来获取庄稼实例，这个庄稼可以产出要用来喂动物进食的类型的食物。\n\n![image-20220626190910250](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626190910250.png)\n\n接下来，我们需要收割庄稼的产出，可以通过调用庄稼的一个方法 harvest()\n\n![image-20220626191404371](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626191404371.png)\n\n最后我们可以把产出的食物喂给动物吃，因为基本的动物类型是固定的，编译器知道植物类型(alfara)与产出食物类型(hay)，以及在多个方法之间调用的动物类型(cow)之间的关系。\n\n![image-20220626191534121](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626191534121.png)\n\n这些静态的关系可以让我们避免给动物喂错食物。\n\n如果我们尝试使用没有被保证可以为这个动物喂养的食物类型，编译器就会告诉我们。\n\n![image-20220626191900776](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626191900776.png)\n\n想要学习其他的农场协议是如何定义，并用来表达喂养动物的类型和它所食用的植物之间关系的，请参考 110353\n\n![image-20220626193714763](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626193714763.png)\n\n最后，让我们添加一个 feedAll(animals:) 方法，接收一个数组作为参数，我知道元素类型需要遵循 Animal 协议，但是我希望这个数组可以存储不同类型的动物。\n\n![image-20220626202924050](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626202924050.png)\n\n让我们看看这里用不透明类型 some Animal 是否可行。\n\n![image-20220626203030188](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626203030188.png)\n\n使用 some 关键字，就意味着这个具体的基本类型不能发生改变，因为基本类型是固定的，数组中所有的元素都必须是相同的类型，所以，用 some Animal 描述数组元素的类型并不能准确表达我们的意图。因为我想要一个可以存储不同类型元素的数组。\n\n![image-20220626203102314](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626203102314.png)\n\n这里，我们需要的是一个可以代表任何动物的超类，我们可以使用 any Animal 来表示任意类型的动物。\n\n![image-20220626203544327](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626203544327.png)\n\nany 关键字表明这个类型可以存储任意类型的动物，基本类型在运行时也可以改变。\n\n就像 some 关键字那样，any 关键字后也跟随着一个要遵循的协议，any Animal 是一个单一的静态类型，拥有动态存储任意动物实体类型的能力。这个能力允许我们对值类型使用**子类多态**。为了允许这个灵活的存储，any Animal 在内存中的存储有一个特殊的表达。\n\n你可以把这种表达形式想像成一个盒子，有时候，值能够直接装进盒子。\n\n![image-20220626204305609](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626204305609.png)\n\n而另外一些值太大了盒子装不下，所以值需要在其他位置分配内存空间，盒子只是用一个指针指向这个空间。\n\n![image-20220626204442868](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626204442868.png)\n\nany Animal 这个静态类型可以动态存储任何实体类型这种行为被正式的称为**存在主义类型**。\n\n![image-20220626204819602](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626204819602.png)\n\n对不同实体类型使用相同表达的策略叫做类型擦除。\n\n在编译时，实体类型的类型被擦除，直到运行时才被体现出来。\n\n存在类型 any Animal 的这两个实例，有相同的静态类型(具体的静态类型是什么？)，但是不同的动态类型(具体的动态类型又是什么？)。\n\n类型擦除消除了不同动物在类型级别的区别，这允许我们使用静态类型相同但动态类型不同的值。\n\n![image-20220626205158501](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626205158501.png)\n\n我们可以使用类型擦除来书写一个异源值类型数组，这正是我们在 feedAll(animals:) 方法中所需要的。\n\n\n\n##### Swift 5.7——参数位置使用 any\n\n![image-20220626205642059](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626205642059.png)\n\n所以我们使用一个数组，用 any Animal 作为参数的类型，**对协议使用 any 关键字和关联类型(哪里使用关联类型了？)是 Swift 5.7 新增的功能**。\n\n为了实现 feedAll(animals:) 方法，我们首先遍历这个 animals 数组。\n\n![image-20220626205904465](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626205904465.png)\n\n对于每个动物，我们都想调用 Animal 协议中的 eat(food:) 方法。\n\n![image-20220626210014893](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626210014893.png)\n\n为了调用这个方法，在这次遍历中，我们需要获取到具体的基本类型 Feed 的类型。\n\n![image-20220626210159916](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626210159916.png)\n\n但是一旦我们对 any Animal 调用 eat(food:) 方法，我们将会得到一个编译错误。\n\n![image-20220626210358657](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626210358657.png)\n\n因为我们消除了具体动物类型在编译时类型级别的区别，我们也消除了所有类型之间的关系，这些关系本身是依赖于具体的动物类型的，也包括关联类型。\n\n**所以我们不知道这个类型的动物希望被喂什么类型的食物。为了能够依赖这些类型之间的关系，我们需要回到之前动物的具体类型仍然固定的上下文，不再直接对 any Animal 调用 eat(food:) 方法，我们需要调用可以接收 some Animal 的 feed 方法。**\n\n![image-20220626211117177](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626211117177.png)\n\nany Animal 跟 some Animal 是不同的，但是编译器可以通过“拆包”基本类型值的方式将 any Animal 的实例转换为 some Animal，并且把它直接传给 some Animal 参数。\n\n**这个“拆包”实参的能力是 Swift 5. 7 新增的。**\n\n![image-20220626211430157](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626211430157.png)\n\n你可以把拆包看作是编译器打开了盒子并取出了存在其中的值。\n\nsome Animal 参数的使用范围内，这个值都有一个固定的基本类型。所以我们可以访问所有对基本类型的操作，包括访问关联类型。\n\n这真的很酷，因为它允许我们在需要的时候选择灵活的存储(即类型擦除，装进盒子里)，同时也可以回到之前的拥有函数体内可使用范围的固定基本类型的静态类型系统完整表达的上下文。\n\n大多数情况下，你并不需要去考虑拆包，因为它就是按照你期待的方式工作的，与对 any Animal 调用协议方法类似，就是对基本类型调用这个方法。\n\n所以我们可以对每个动物都调用 feed(animal:) 方法，在那里，每次遍历我们都可以种植并且收割合适的庄稼来喂养具体的动物。\n\n![image-20220626215127833](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626215127833.png)\n\n在这个过程中，我们看到了 some 和 any 不同的能力。\n\n使用 some，基本类型就是固定的，这允许你在泛型代码中依赖于固定的基本类型之间的关系，所以你有对 API 和协议关联类型的完整的访问权限。\n\n使用 any，当你需要存储任意实体类型时，any 提供了类型擦除，允许你表达异源集合，表达基本类型的缺席，使用可选项，同时抽象实现细节。\n\n![image-20220626215828321](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626215828321.png)\n\n总而言之，默认情况下使用 some，当你想要存储任意类型的值时，将 some 改为 any。\n\n使用这种方式，只在你需要存储灵活性时，付出类型擦除和语义限制的代价即可。\n\n这个工作流程与默认书写 let 表示常量，直到你需要变量时类似。\n\n在这个视频中，我们想要通过这个工作流程随着代码的演进来生成代码并且获得更多的功能。\n\n\n\n我们从实体类型开始，随着代码获得更多的功能，我们发觉在不同的类型中的代码重复。从这里开始，我们确定了通用的能力，并且使用协议生成了这些能力，最后我们用 some 和 any 写了抽象代码，并且讨论了我们倾向于使用 some 来书写更具有表达性的代码。\n\n想要更深入的构建协议和理解类型擦除，可以看 110353。\n\n![image-20220626220750663](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626220750663.png)","source":"_drafts/WWDC 22 - 110352 拥抱 Swift 泛型 第一次整理.md","raw":"# WWDC 22 - 110352 拥抱 Swift 泛型 第一次整理\n\n大家好，我是 holly，来自 Swift 编译组，欢迎来到拥抱 Swift 泛型。\n\n泛型是一个书写 Swift 抽象代码的基本工具，随着代码的演化发展，泛型是起到管理复杂性的关键。\n\n抽象概念可以将思想从特定的细节中分离出来，在代码中，有很多种方式(途径)可以使用泛型(泛型都起到了作用)。\n\n你可能经常使用到的一种抽象概念的形式就是将代码抽出来到一个函数或是一个局部变量，如果你想要多次使用同一功能或同一个值时，这是非常有用的。\n\n当你把一个功能提取到一个函数里时，函数的细节就被抽出去(抽象化)了，而使用(调用)个抽象函数的代码，就可以表达所发生的事情，而不需要重复细节了。\n\n在 Swift 中，你也可以将实体类型抽象出来，如果你有一系列的类型，它们使用了相同的思想，和不同的实现细节，你就可以写抽象的代码来实现所有这些实体类型。\n\n今天，我们将通过模型化实体类型、确定一系列实体类型的通用能力、构建一个接口来表达(呈现)这些能力、深入了解如何使用这些接口来实现泛型的书写的步骤来向你展示泛型的具体使用场景。\n\n![image-20220626140259410](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626140259410.png)\n\n我们将通过构建一些代码来模拟一个农场的形式，一起探索 Swift 抽象工具的使用。\n\n\n\n## Model with concrete types\n\n让我们先来写几个实体类型吧。\n\n首先创建一个叫做 Cow 的结构体，它有一个方法叫做 eat(food:)，接收一个 Hay 类型的参数。\n\nHay 是另一个结构体，它有一个**静态**方法叫做 grow() -> Alfalfa，可以种植一些能够长出 Hay 的庄稼 Alfalfa。\n\nAlfalfa 结构体有一个方法 harvest() -> Hay 通过 Alfalfa 实例来收获 Hay。\n\n最后，我们抽象出一个农场 Farm，它有一个方法 feed(animal:) 可以喂养奶牛。\n\nfeed(animal:) 方法可以通过首先种一些苜蓿 Alfalfa 来生产干草 Hay，然后收获干草 Hay ，最后用干草 Hay 来喂养奶牛 Cow 的方式实现。\n\n这时，我就能在我的农场来饲养奶牛了。\n\n![image-20220626141648138](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626141648138.png)\n\n\n\n但是我想饲养更多的动物。\n\n我可以添加更多的结构体来代表其他的动物，就像 Horse 马和 Chicken 鸡。\n\n我想在农场上饲养奶牛，马，鸡。\n\n\n\n### Overloads\n\n我可以重载这个 feed(animal:) 方法分别来接收不同类型的参数，但是每个重载函数都会有一个相当类似的实现。\n\n![image-20220626142527042](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626142527042.png)\n\n当我添加更多的动物类型时，这将造成类似代码的堆积，基本上到处都是重复的代码。\n\n当你发现自己写的重载代码有重复的实现时，就是概括归纳(抽象、重构)的预兆了。\n\n基本上说，这些实现都很类似，因为(饲养)不同类型的动物在功能(喂养)上是相似的。\n\n\n\n## Identify common capabilities\n\n第二步，就是来确定动物类型的通用能力了。\n\n我们已经构建了一系列动物类型了，它们都有一个能力，吃某一种食物。\n\n每种类型的动物都有不同的进食方式，所以每个动物的 eat(food:) 方法都有不同的行为表现。\n\n我们要做的就是允许抽象代码在调用的时候调同一个方法，也就是 eat(food:) 方法，在这个的同时，让这些抽象代码在 eat(food:) 方法中的行为表现不同，这取决于抽象代码所执行在的实体的具体类型。\n\n抽象代码在不同的实体类型上可以表现不同能力的功能叫做多态，多态允许一份代码拥有多种行为表现，取决于代码是被如何使用的。\n\n更恰当地说的话，多态本身就是不同形式的。\n\n首先是函数的重载，根据传入参数类型的不同，同样的函数调用可以意味着不同的事物。重载被称为 ad-hoc(临时安排的、特别的、专门的) 多态，因为它并不是一个通用的解决方案。我们只是为了看到重载到底是如何一步步走向重复代码的。\n\n下一步，是子类多态。代码在一个超类上去执行调用，实际上却会在运行时基于特定的子类而产生不同的表现。\n\n最后是使用泛型来实现的确定(指定)参数的多态。\n\n![image-20220628195428703](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220628195428703.png)\n\n\n\n泛型代码使用类型参数，来允许书写一份代码与不同类型一起奏效(工作、运行)。而实体类型呢，则将作为实参进行传递。\n\n我们早就已经把重载排除出局了，所以让我们尝试使用子类多态吧。\n\n\n\n### Subtypes\n\n代表子类关系的一种方式是使用类层级(用类替换结构体)。我们可以引入一个类叫做 Animal 动物。\n\n![image-20220626145345481](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626145345481.png)\n\n然后，我们将每种动物类型从结构体更改为类。\n\n每个具体的动物类都继承自 Animal 动物这个超类并且重写 eat(food:) 方法。\n\n现在，我们有一个抽象的基类 Animal 动物，可以代表我们每一个具体的动物类型。调用 Animal 动物的 eat(food:) 方法将会通过使用子类多态而调用到子类的具体实现，但这样还没完。\n\n我们仍然没有补全 Animal 动物 eat(:food) 方法的参数类型，这份代码还有一些报错。\n\n首先，使用类将强制我们使用引用类型语义，即使我们并不需要分享不同实例间的任何状态。这个策略也需要子类去重写基类中的方法。但是忘记重写基类方法只有在运行时才会被捕获。\n\n但是对这个模型抽象的过程中更大的问题是每种子类动物都会食用不同类型的食物，这种依赖用类层级相当难以表达。(即 eat(food:) 方法中 food 参数的类型必须明确标明，但是因为每种动物所食用的食物都是不同的，所以很难明确写清楚)\n\n\n\n#### Any\n\n一种方式是让 eat(food:) 方法中食物的参数接收一个不具体(明确)的类型， 例如 Any。\n\n![image-20220626150733935](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626150733935.png)\n\n但是这种策略在子类实现中，仍然需要在运行时确定好准确的类型并传入，这样，在每个重写的方法中又一次出现了代码堆积。(只是把代码堆积的位置改变了而已)\n\n![image-20220626150958877](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626150958877.png)\n\n但是更重要的是，这份代码允许你不小心传入一个错误的食物类型，造成另一个只能在运行时才捕获的 bug。我们再试试别的方法吧。(即使你在调用的时候，传入的食物类型与实际期待的不符，也只会在运行时才会报错)\n\n\n\n####  \\<T\\>\n\n我们可以通过在超类 Animal 动物类上引入一种类型安全的类型参数的方式，来替代表达喂养动物所用食物的类型。\n\n这种类型参数对每一个子类的食物喂养类型使用一个占位符，通过这种方式，Food 参数的类型必须被提升到 Animal 类的声明中才行。\n\n![image-20220626152712935](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626152712935.png)\n\n这看起来有点诡异，因为尽管动物需要食物来填饱肚子，但是进食并不是动物的主要目标，很多与动物相关的代码也许根本不关心它们吃什么食物。尽管如此，所有对 Animal 类的引用(也就是对 Animal 的实例化)都需要指明 Food 的类型。\n\n举个例子，每个 Animal 的子类都需要在声明继承的代码中使用尖括号明确指出它的食物类型，如果我们添加更多需要明确指定的类型给每种 Animal，这种代码模板在每个使用 Animal 类的地方都将变得非常繁琐。\n\n![image-20220626153746315](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626153746315.png)\n\n所以我们上述的两种方式既低效，又不能正确地表达语义。\n\n**根本问题是，类是一种数据类型，我们却想要尝试复杂化一个超类，然后让它代表实体类型的抽象思想。**\n\n取而代之的是，我们想要构建一个能够代表类型的能力，但不需要这个能力实现的细节。\n\n动物有两个常见的能力，每种动物都有一种具体的食物类型，和一种进食方式。\n\n\n\n## Build an interface\n\n我们可以构建一种接口来代表这两种能力。\n\n在 Swift 中，使用协议来实现这种功能。\n\n协议是一种抽象工具，描述了遵循它协议的类型的功能。使用协议，你可以把一个类所做的事情的构思与其具体的实现区分开来。一个类所做的事情的构思用接口来表达。\n\n让我们将动物的能力使用协议接口来翻译一下。\n\n协议的名称代表我们所描述的这种类型的分类(类别、范畴、种类)，所以我管这个协议叫“Animal 动物”。\n\n每个能力都将映射到一个协议的必要条件(要求、接口、方法)上。\n\n食物的具体类型将会映射为协议中的一个关联类型，就像类型参数一样，关联类型也是作为实体类型的占位符。\n\n![image-20220626160017654](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626160017654.png)\n\n关联类型的特别之处在于，它取决于遵循协议的那个类型的具体类型，这层关系是有保障的。所以对应到(每个)具体的动物类型的不同实例都有相同的食物类型。\n\n接下来，进食的行为将会映射为一个方法。这个方法叫做 eat(food:)，它接收一个参数，喂养动物所需食物的类型。\n\n![image-20220626160729154](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626160729154.png)\n\n协议中并没有这个方法的实现，实体动物类型被要求去实现它(具体的动物类型才需要去实现它)。\n\n现在，我们有一个动物协议，我们可以让每个实体动物类型都遵循它。\n\n你可以对一个实体类型进行标记，在它的声明或者扩展中，代表它遵循了一个协议。\n\n![image-20220626162949349](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626162949349.png)\n\n协议并不仅限于类去遵循，我们也可以对结构体、枚举和 actors 使用协议。\n\n当你写下这个协议遵循的标注，编译器将会检查实体类型是否实现了协议中要求的必要条件。\n\n每个动物类型都必须实现 eat(food:) 这个方法，而且编译器可以推断出喂养所需食物的类型，因为它在参数列表中已经被使用(描述)过了(每个具体的类型对 eat 方法的实现里，都传入了具体的 food 参数的类型名称)。\n\nFeed 也可以通过类型别名明确的写出。\n\n\n\n## Write generic code\n\n我们成功地确定了动物的通用能力，并且使用协议表达了这些能力。现在，我们可以开始书写泛型代码了。\n\n\n\n### Generics\n\n我们可以使用动物协议来实现农场的 feed(animal:) 方法，我们想写一种实现，可以对所有的动物实体类型都通用。\n\n我们使用确定参数的多态，并且引入一个类型参数，当方法被调用的时候，类型参数会被替换为实体类型。\n\n类型参数是用尖括号包裹并写在函数名称后面的，就像通常的变量和函数参数那样，你可以随意给参数类型命名。\n\n并且就像任何其他的类型那样，你可以在函数体内使用类型参数的名称引用这个类型参数。\n\n这里我声明了一个类型参数 A，并且使用 A 作为函数参数动物的类型。\n\n![image-20220626164416814](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626164416814.png)\n\n我们总是希望实体动物类型遵循动物协议，所以在尖括号包裹的 A 之后标注其遵循 Animal 协议。\n\n![image-20220626165033294](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626165033294.png)\n\n协议遵循可以写在尖括号里，也可以在语句末尾使用 where 语句声明，在这里你还可以指明不同类型参数之间的关系。\n\n![image-20220626165151422](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626165151422.png)\n\n命名类型参数(也就在用尖括号包裹的类型参数后标注协议遵循)和在语句末尾使用 wehre 语句是非常有力量的，因为它允许你写出复杂的~~必要条件~~(要求)与类型之间的关系。但是大多数的泛型函数不需要这样的通用性。\n\n让我们把焦点放在 feed(animal:) 方法上。\n\n类型参数 A 在参数列表中出现过一次，而 where 语句罗列出了类型参数的必要条件的遵循情况。\n\n在这种情况下，命名类型参数和使用 where 语句让这个方法看起来过于复杂。\n\n![image-20220626165501956](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626165501956.png)\n\n这种泛型样式是相当常见的，所以有更简单的方式表达它。\n\n不再明确写出类型参数，我们可以就协议的遵循情况通过写成 some Animal 来表达这个抽象类型，这种声明方式跟前面的是等价的，但是那些不必要的类型参数列表和 where 语句都消失了，因为我们并不需要它们所提供的这种表达形式，使用 some Animal 更加直接。因为它减少了语法干扰，还在参数声明的右半部分包含了关于动物参数的语义信息。\n\n![image-20220626170002361](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626170002361.png)\n\n\n\n#### some\n\n让我们看看 some Animal 的语法。\n\nsome 暗示这里有某一个具体的类型，some 之后总是会跟着一个要遵循的协议。\n\n在这个场景里，具体的类型必须遵循 Animal 协议，这允许我们在参数值上使用 Animal 协议中的必要条件(这允许我们对这个参数实例调用 Animal 协议中声明的方法)。\n\nsome 关键字可以在函数参数和返回值的类型中使用，如果你之前写过 SwiftUI 代码，你应该早就用过 some，在返回值的位置使用 some View。\n\n返回值的类型 some View 跟这里恰恰是完全相同的概念。在 SwiftUI 的视图中，body 属性返回某个具体类型的视图，但是使用 body 属性的代码并不需要知道这个具体的类型是什么。\n\n![image-20220626170932734](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626170932734.png)\n\n让我们返回回去更好的理解一下一个(具体、特定、某一个)的抽象类型的概念。\n\n代表一个具体的实体类型的占位符的抽象类型叫做“不透明类型”。\n\n被替换的具体的实体类型叫做(underlying)基本类型，对于不透明类型的值，在值的使用范围内，基本类型是固定的。\n\n这样，泛型代码使用的值就被保证了值每次被访问的时候，都会获取到相同的基本类型。\n\n使用 some 关键字的类型，和一个用尖括号命名的类型参数，都声明了一个不透明类型。\n\n![image-20220626173329398](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626173329398.png)\n\n不透明类型在输入输出中都可以使用，所以它们可以声明在函数(方法)参数的位置，或是返回值的位置。\n\n函数的箭头将这两个位置分为两部分。\n\n![image-20220626173940091](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626173940091.png)\n\n不透明类型的位置决定了程序的哪个部分可以看到抽象类型，以及程序的哪个部分决定实体类型。\n\n命名类型参数总是声明在输入侧，所以调用者决定了基本类型，而实现使用了抽象类型。\n\n![image-20220626174210668](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626174210668.png)\n\n通常情况下，提供不透明参数或返回值类型的那部分程序，决定了基本类型；而使用这个值的那部分程序可以看到抽象类型。\n\n\n\n让我们深入了解一下这是怎么运转起来的。跟着我们对参数和返回值的直觉走。\n\n因为基本类型是通过一个值推断出来的，基本类型总是跟值一起出现在相同的位置。\n\n对于一个局部变量来说，基本类型是通过右边的赋值操作推断出来的，这意味着有着不透明类型的局部变量总是需要一个初始值(这样才能推断出其基本类型)。\n\n![image-20220626174951554](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626174951554.png)\n\n如果你不给提供初始值，编译器将会报错。\n\n![image-20220626175035323](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175035323.png)\n\n基本类型必须在变量的使用范围内被固定，所以对基本类型进行修改的尝试也会得出一个错误的结果。\n\n![image-20220626175134539](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175134539.png)\n\n对于使用不透明类型的参数来说，基本类型是在被调用的位置传入的实参值推断出来的。\n\n![image-20220626175314696](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175314696.png)\n\n##### Swift 5.7——参数位置使用 some\n\n在参数位置使用 some 是 Swift 5.7 新增的功能。\n\n![image-20220626175447382](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175447382.png)\n\n基本类型只需要在参数的使用范围内被固定，所以每次调用都可以提供一个类型不同的参数。\n\n![image-20220626175640411](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175640411.png)\n\n\n\n##### 返回值位置使用 some\n\n对不透明类型的返回值来说，基本类型是在函数实现中的返回值的位置进行推断的。\n\n![image-20220626180718256](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626180718256.png)\n\n有不透明类型返回值的方法或者计算属性，可以在程序的任何位置被调用，所以这个值的可用范围是全局的。这意味着，返回值的基本类型需要在所有的返回语句中保持一致。如果没有保持一致，编译器将会报错，基本类型返回值的类型不匹配。\n\n![image-20220626181045890](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626181045890.png)\n\n对于不透明类型的 SwiftUI View，ViewBuilder DSL 可以将控制流语句的每个分支都转换成拥有相同基本类型的返回值。\n\n所以在这个场景下，我们可以使用 ViewBuilder DSL 来解决这个问题。在方法前写一个修饰符 @ViewBuilder，并且移除掉 return 语句，将会允许通过 ViewBuilder 的类型来为我们构建返回值类型。\n\n![image-20220626181303429](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626181303429.png)\n\n\n\n##### 举例说明\n\n让我们回到 feedAnimal 方法吧。\n\n我将会使用 some 在参数列表中，因为我并不需要在其他位置引用这个不透明类型的参数。当你需要在函数体中多次引用这个不透明类型时，也就是说类型参数的名称要能手到擒来。\n\n举个例子，当我们给 Animal 协议添加另外一个关联值，Habitat。\n\n![image-20220626181844443](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626181844443.png)\n\n我们也许想要在农场上为某个指定的动物构建一个栖息地，这个场景下，返回值类型就依赖于这个具体的动物的类型了，所以我们在参数和返回值的位置都需要用到类型参数 A。\n\n![image-20220626183735613](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626183735613.png)\n\n另一个你需要多次引用不透明类型的常见的地方，是在泛型中。代码通常在泛型类型上声明一个类型参数，为一个存储属性使用类型参数，并且也给一个成员构造器传递参数。\n\n![image-20220626184243060](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626184243060.png)\n\n在不同的上下文中引用泛型类型，也需要你用尖括号明确指出类型参数(也就是说在同一个上下文范围内，明确指出一次应该就够了，之后编辑器可以推断出来)。在声明中的尖括号里的泛型可以帮助阐明如何使用一个泛型类型，**所以不透明类型必须总是被命名为泛型类型**。\n\n![image-20220626190535609](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626190535609.png)\n\n现在，让我们一起构造出 feed 方法的实现吧。\n\n\n\n我们可以使用动物参数的类型来访问种植的庄稼类型，通过 Feed 的关联类型。我们调用 Feed.grow() 来获取庄稼实例，这个庄稼可以产出要用来喂动物进食的类型的食物。\n\n![image-20220626190910250](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626190910250.png)\n\n接下来，我们需要收割庄稼的产出，可以通过调用庄稼的一个方法 harvest()\n\n![image-20220626191404371](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626191404371.png)\n\n最后我们可以把产出的食物喂给动物吃，因为基本的动物类型是固定的，编译器知道植物类型(alfara)与产出食物类型(hay)，以及在多个方法之间调用的动物类型(cow)之间的关系。\n\n![image-20220626191534121](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626191534121.png)\n\n这些静态的关系可以让我们避免给动物喂错食物。\n\n如果我们尝试使用没有被保证可以为这个动物喂养的食物类型，编译器就会告诉我们。\n\n![image-20220626191900776](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626191900776.png)\n\n想要学习其他的农场协议是如何定义，并用来表达喂养动物的类型和它所食用的植物之间关系的，请参考 110353\n\n![image-20220626193714763](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626193714763.png)\n\n最后，让我们添加一个 feedAll(animals:) 方法，接收一个数组作为参数，我知道元素类型需要遵循 Animal 协议，但是我希望这个数组可以存储不同类型的动物。\n\n![image-20220626202924050](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626202924050.png)\n\n让我们看看这里用不透明类型 some Animal 是否可行。\n\n![image-20220626203030188](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626203030188.png)\n\n使用 some 关键字，就意味着这个具体的基本类型不能发生改变，因为基本类型是固定的，数组中所有的元素都必须是相同的类型，所以，用 some Animal 描述数组元素的类型并不能准确表达我们的意图。因为我想要一个可以存储不同类型元素的数组。\n\n![image-20220626203102314](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626203102314.png)\n\n这里，我们需要的是一个可以代表任何动物的超类，我们可以使用 any Animal 来表示任意类型的动物。\n\n![image-20220626203544327](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626203544327.png)\n\nany 关键字表明这个类型可以存储任意类型的动物，基本类型在运行时也可以改变。\n\n就像 some 关键字那样，any 关键字后也跟随着一个要遵循的协议，any Animal 是一个单一的静态类型，拥有动态存储任意动物实体类型的能力。这个能力允许我们对值类型使用**子类多态**。为了允许这个灵活的存储，any Animal 在内存中的存储有一个特殊的表达。\n\n你可以把这种表达形式想像成一个盒子，有时候，值能够直接装进盒子。\n\n![image-20220626204305609](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626204305609.png)\n\n而另外一些值太大了盒子装不下，所以值需要在其他位置分配内存空间，盒子只是用一个指针指向这个空间。\n\n![image-20220626204442868](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626204442868.png)\n\nany Animal 这个静态类型可以动态存储任何实体类型这种行为被正式的称为**存在主义类型**。\n\n![image-20220626204819602](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626204819602.png)\n\n对不同实体类型使用相同表达的策略叫做类型擦除。\n\n在编译时，实体类型的类型被擦除，直到运行时才被体现出来。\n\n存在类型 any Animal 的这两个实例，有相同的静态类型(具体的静态类型是什么？)，但是不同的动态类型(具体的动态类型又是什么？)。\n\n类型擦除消除了不同动物在类型级别的区别，这允许我们使用静态类型相同但动态类型不同的值。\n\n![image-20220626205158501](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626205158501.png)\n\n我们可以使用类型擦除来书写一个异源值类型数组，这正是我们在 feedAll(animals:) 方法中所需要的。\n\n\n\n##### Swift 5.7——参数位置使用 any\n\n![image-20220626205642059](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626205642059.png)\n\n所以我们使用一个数组，用 any Animal 作为参数的类型，**对协议使用 any 关键字和关联类型(哪里使用关联类型了？)是 Swift 5.7 新增的功能**。\n\n为了实现 feedAll(animals:) 方法，我们首先遍历这个 animals 数组。\n\n![image-20220626205904465](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626205904465.png)\n\n对于每个动物，我们都想调用 Animal 协议中的 eat(food:) 方法。\n\n![image-20220626210014893](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626210014893.png)\n\n为了调用这个方法，在这次遍历中，我们需要获取到具体的基本类型 Feed 的类型。\n\n![image-20220626210159916](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626210159916.png)\n\n但是一旦我们对 any Animal 调用 eat(food:) 方法，我们将会得到一个编译错误。\n\n![image-20220626210358657](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626210358657.png)\n\n因为我们消除了具体动物类型在编译时类型级别的区别，我们也消除了所有类型之间的关系，这些关系本身是依赖于具体的动物类型的，也包括关联类型。\n\n**所以我们不知道这个类型的动物希望被喂什么类型的食物。为了能够依赖这些类型之间的关系，我们需要回到之前动物的具体类型仍然固定的上下文，不再直接对 any Animal 调用 eat(food:) 方法，我们需要调用可以接收 some Animal 的 feed 方法。**\n\n![image-20220626211117177](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626211117177.png)\n\nany Animal 跟 some Animal 是不同的，但是编译器可以通过“拆包”基本类型值的方式将 any Animal 的实例转换为 some Animal，并且把它直接传给 some Animal 参数。\n\n**这个“拆包”实参的能力是 Swift 5. 7 新增的。**\n\n![image-20220626211430157](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626211430157.png)\n\n你可以把拆包看作是编译器打开了盒子并取出了存在其中的值。\n\nsome Animal 参数的使用范围内，这个值都有一个固定的基本类型。所以我们可以访问所有对基本类型的操作，包括访问关联类型。\n\n这真的很酷，因为它允许我们在需要的时候选择灵活的存储(即类型擦除，装进盒子里)，同时也可以回到之前的拥有函数体内可使用范围的固定基本类型的静态类型系统完整表达的上下文。\n\n大多数情况下，你并不需要去考虑拆包，因为它就是按照你期待的方式工作的，与对 any Animal 调用协议方法类似，就是对基本类型调用这个方法。\n\n所以我们可以对每个动物都调用 feed(animal:) 方法，在那里，每次遍历我们都可以种植并且收割合适的庄稼来喂养具体的动物。\n\n![image-20220626215127833](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626215127833.png)\n\n在这个过程中，我们看到了 some 和 any 不同的能力。\n\n使用 some，基本类型就是固定的，这允许你在泛型代码中依赖于固定的基本类型之间的关系，所以你有对 API 和协议关联类型的完整的访问权限。\n\n使用 any，当你需要存储任意实体类型时，any 提供了类型擦除，允许你表达异源集合，表达基本类型的缺席，使用可选项，同时抽象实现细节。\n\n![image-20220626215828321](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626215828321.png)\n\n总而言之，默认情况下使用 some，当你想要存储任意类型的值时，将 some 改为 any。\n\n使用这种方式，只在你需要存储灵活性时，付出类型擦除和语义限制的代价即可。\n\n这个工作流程与默认书写 let 表示常量，直到你需要变量时类似。\n\n在这个视频中，我们想要通过这个工作流程随着代码的演进来生成代码并且获得更多的功能。\n\n\n\n我们从实体类型开始，随着代码获得更多的功能，我们发觉在不同的类型中的代码重复。从这里开始，我们确定了通用的能力，并且使用协议生成了这些能力，最后我们用 some 和 any 写了抽象代码，并且讨论了我们倾向于使用 some 来书写更具有表达性的代码。\n\n想要更深入的构建协议和理解类型擦除，可以看 110353。\n\n![image-20220626220750663](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626220750663.png)","slug":"WWDC 22 - 110352 拥抱 Swift 泛型 第一次整理","published":0,"date":"2022-06-28T09:13:29.169Z","updated":"2022-06-29T05:55:23.368Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ejwd840001o4dx3kttegy6","content":"<h1 id=\"WWDC-22-110352-拥抱-Swift-泛型-第一次整理\"><a href=\"#WWDC-22-110352-拥抱-Swift-泛型-第一次整理\" class=\"headerlink\" title=\"WWDC 22 - 110352 拥抱 Swift 泛型 第一次整理\"></a>WWDC 22 - 110352 拥抱 Swift 泛型 第一次整理</h1><p>大家好，我是 holly，来自 Swift 编译组，欢迎来到拥抱 Swift 泛型。</p>\n<p>泛型是一个书写 Swift 抽象代码的基本工具，随着代码的演化发展，泛型是起到管理复杂性的关键。</p>\n<p>抽象概念可以将思想从特定的细节中分离出来，在代码中，有很多种方式(途径)可以使用泛型(泛型都起到了作用)。</p>\n<p>你可能经常使用到的一种抽象概念的形式就是将代码抽出来到一个函数或是一个局部变量，如果你想要多次使用同一功能或同一个值时，这是非常有用的。</p>\n<p>当你把一个功能提取到一个函数里时，函数的细节就被抽出去(抽象化)了，而使用(调用)个抽象函数的代码，就可以表达所发生的事情，而不需要重复细节了。</p>\n<p>在 Swift 中，你也可以将实体类型抽象出来，如果你有一系列的类型，它们使用了相同的思想，和不同的实现细节，你就可以写抽象的代码来实现所有这些实体类型。</p>\n<p>今天，我们将通过模型化实体类型、确定一系列实体类型的通用能力、构建一个接口来表达(呈现)这些能力、深入了解如何使用这些接口来实现泛型的书写的步骤来向你展示泛型的具体使用场景。</p>\n<p>![image-20220626140259410](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626140259410.png)</p>\n<p>我们将通过构建一些代码来模拟一个农场的形式，一起探索 Swift 抽象工具的使用。</p>\n<h2 id=\"Model-with-concrete-types\"><a href=\"#Model-with-concrete-types\" class=\"headerlink\" title=\"Model with concrete types\"></a>Model with concrete types</h2><p>让我们先来写几个实体类型吧。</p>\n<p>首先创建一个叫做 Cow 的结构体，它有一个方法叫做 eat(food:)，接收一个 Hay 类型的参数。</p>\n<p>Hay 是另一个结构体，它有一个<strong>静态</strong>方法叫做 grow() -&gt; Alfalfa，可以种植一些能够长出 Hay 的庄稼 Alfalfa。</p>\n<p>Alfalfa 结构体有一个方法 harvest() -&gt; Hay 通过 Alfalfa 实例来收获 Hay。</p>\n<p>最后，我们抽象出一个农场 Farm，它有一个方法 feed(animal:) 可以喂养奶牛。</p>\n<p>feed(animal:) 方法可以通过首先种一些苜蓿 Alfalfa 来生产干草 Hay，然后收获干草 Hay ，最后用干草 Hay 来喂养奶牛 Cow 的方式实现。</p>\n<p>这时，我就能在我的农场来饲养奶牛了。</p>\n<p>![image-20220626141648138](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626141648138.png)</p>\n<p>但是我想饲养更多的动物。</p>\n<p>我可以添加更多的结构体来代表其他的动物，就像 Horse 马和 Chicken 鸡。</p>\n<p>我想在农场上饲养奶牛，马，鸡。</p>\n<h3 id=\"Overloads\"><a href=\"#Overloads\" class=\"headerlink\" title=\"Overloads\"></a>Overloads</h3><p>我可以重载这个 feed(animal:) 方法分别来接收不同类型的参数，但是每个重载函数都会有一个相当类似的实现。</p>\n<p>![image-20220626142527042](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626142527042.png)</p>\n<p>当我添加更多的动物类型时，这将造成类似代码的堆积，基本上到处都是重复的代码。</p>\n<p>当你发现自己写的重载代码有重复的实现时，就是概括归纳(抽象、重构)的预兆了。</p>\n<p>基本上说，这些实现都很类似，因为(饲养)不同类型的动物在功能(喂养)上是相似的。</p>\n<h2 id=\"Identify-common-capabilities\"><a href=\"#Identify-common-capabilities\" class=\"headerlink\" title=\"Identify common capabilities\"></a>Identify common capabilities</h2><p>第二步，就是来确定动物类型的通用能力了。</p>\n<p>我们已经构建了一系列动物类型了，它们都有一个能力，吃某一种食物。</p>\n<p>每种类型的动物都有不同的进食方式，所以每个动物的 eat(food:) 方法都有不同的行为表现。</p>\n<p>我们要做的就是允许抽象代码在调用的时候调同一个方法，也就是 eat(food:) 方法，在这个的同时，让这些抽象代码在 eat(food:) 方法中的行为表现不同，这取决于抽象代码所执行在的实体的具体类型。</p>\n<p>抽象代码在不同的实体类型上可以表现不同能力的功能叫做多态，多态允许一份代码拥有多种行为表现，取决于代码是被如何使用的。</p>\n<p>更恰当地说的话，多态本身就是不同形式的。</p>\n<p>首先是函数的重载，根据传入参数类型的不同，同样的函数调用可以意味着不同的事物。重载被称为 ad-hoc(临时安排的、特别的、专门的) 多态，因为它并不是一个通用的解决方案。我们只是为了看到重载到底是如何一步步走向重复代码的。</p>\n<p>下一步，是子类多态。代码在一个超类上去执行调用，实际上却会在运行时基于特定的子类而产生不同的表现。</p>\n<p>最后是使用泛型来实现的确定(指定)参数的多态。</p>\n<p>![image-20220628195428703](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220628195428703.png)</p>\n<p>泛型代码使用类型参数，来允许书写一份代码与不同类型一起奏效(工作、运行)。而实体类型呢，则将作为实参进行传递。</p>\n<p>我们早就已经把重载排除出局了，所以让我们尝试使用子类多态吧。</p>\n<h3 id=\"Subtypes\"><a href=\"#Subtypes\" class=\"headerlink\" title=\"Subtypes\"></a>Subtypes</h3><p>代表子类关系的一种方式是使用类层级(用类替换结构体)。我们可以引入一个类叫做 Animal 动物。</p>\n<p>![image-20220626145345481](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626145345481.png)</p>\n<p>然后，我们将每种动物类型从结构体更改为类。</p>\n<p>每个具体的动物类都继承自 Animal 动物这个超类并且重写 eat(food:) 方法。</p>\n<p>现在，我们有一个抽象的基类 Animal 动物，可以代表我们每一个具体的动物类型。调用 Animal 动物的 eat(food:) 方法将会通过使用子类多态而调用到子类的具体实现，但这样还没完。</p>\n<p>我们仍然没有补全 Animal 动物 eat(:food) 方法的参数类型，这份代码还有一些报错。</p>\n<p>首先，使用类将强制我们使用引用类型语义，即使我们并不需要分享不同实例间的任何状态。这个策略也需要子类去重写基类中的方法。但是忘记重写基类方法只有在运行时才会被捕获。</p>\n<p>但是对这个模型抽象的过程中更大的问题是每种子类动物都会食用不同类型的食物，这种依赖用类层级相当难以表达。(即 eat(food:) 方法中 food 参数的类型必须明确标明，但是因为每种动物所食用的食物都是不同的，所以很难明确写清楚)</p>\n<h4 id=\"Any\"><a href=\"#Any\" class=\"headerlink\" title=\"Any\"></a>Any</h4><p>一种方式是让 eat(food:) 方法中食物的参数接收一个不具体(明确)的类型， 例如 Any。</p>\n<p>![image-20220626150733935](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626150733935.png)</p>\n<p>但是这种策略在子类实现中，仍然需要在运行时确定好准确的类型并传入，这样，在每个重写的方法中又一次出现了代码堆积。(只是把代码堆积的位置改变了而已)</p>\n<p>![image-20220626150958877](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626150958877.png)</p>\n<p>但是更重要的是，这份代码允许你不小心传入一个错误的食物类型，造成另一个只能在运行时才捕获的 bug。我们再试试别的方法吧。(即使你在调用的时候，传入的食物类型与实际期待的不符，也只会在运行时才会报错)</p>\n<h4 id=\"lt-T-gt\"><a href=\"#lt-T-gt\" class=\"headerlink\" title=\"&lt;T&gt;\"></a>&lt;T&gt;</h4><p>我们可以通过在超类 Animal 动物类上引入一种类型安全的类型参数的方式，来替代表达喂养动物所用食物的类型。</p>\n<p>这种类型参数对每一个子类的食物喂养类型使用一个占位符，通过这种方式，Food 参数的类型必须被提升到 Animal 类的声明中才行。</p>\n<p>![image-20220626152712935](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626152712935.png)</p>\n<p>这看起来有点诡异，因为尽管动物需要食物来填饱肚子，但是进食并不是动物的主要目标，很多与动物相关的代码也许根本不关心它们吃什么食物。尽管如此，所有对 Animal 类的引用(也就是对 Animal 的实例化)都需要指明 Food 的类型。</p>\n<p>举个例子，每个 Animal 的子类都需要在声明继承的代码中使用尖括号明确指出它的食物类型，如果我们添加更多需要明确指定的类型给每种 Animal，这种代码模板在每个使用 Animal 类的地方都将变得非常繁琐。</p>\n<p>![image-20220626153746315](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626153746315.png)</p>\n<p>所以我们上述的两种方式既低效，又不能正确地表达语义。</p>\n<p><strong>根本问题是，类是一种数据类型，我们却想要尝试复杂化一个超类，然后让它代表实体类型的抽象思想。</strong></p>\n<p>取而代之的是，我们想要构建一个能够代表类型的能力，但不需要这个能力实现的细节。</p>\n<p>动物有两个常见的能力，每种动物都有一种具体的食物类型，和一种进食方式。</p>\n<h2 id=\"Build-an-interface\"><a href=\"#Build-an-interface\" class=\"headerlink\" title=\"Build an interface\"></a>Build an interface</h2><p>我们可以构建一种接口来代表这两种能力。</p>\n<p>在 Swift 中，使用协议来实现这种功能。</p>\n<p>协议是一种抽象工具，描述了遵循它协议的类型的功能。使用协议，你可以把一个类所做的事情的构思与其具体的实现区分开来。一个类所做的事情的构思用接口来表达。</p>\n<p>让我们将动物的能力使用协议接口来翻译一下。</p>\n<p>协议的名称代表我们所描述的这种类型的分类(类别、范畴、种类)，所以我管这个协议叫“Animal 动物”。</p>\n<p>每个能力都将映射到一个协议的必要条件(要求、接口、方法)上。</p>\n<p>食物的具体类型将会映射为协议中的一个关联类型，就像类型参数一样，关联类型也是作为实体类型的占位符。</p>\n<p>![image-20220626160017654](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626160017654.png)</p>\n<p>关联类型的特别之处在于，它取决于遵循协议的那个类型的具体类型，这层关系是有保障的。所以对应到(每个)具体的动物类型的不同实例都有相同的食物类型。</p>\n<p>接下来，进食的行为将会映射为一个方法。这个方法叫做 eat(food:)，它接收一个参数，喂养动物所需食物的类型。</p>\n<p>![image-20220626160729154](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626160729154.png)</p>\n<p>协议中并没有这个方法的实现，实体动物类型被要求去实现它(具体的动物类型才需要去实现它)。</p>\n<p>现在，我们有一个动物协议，我们可以让每个实体动物类型都遵循它。</p>\n<p>你可以对一个实体类型进行标记，在它的声明或者扩展中，代表它遵循了一个协议。</p>\n<p>![image-20220626162949349](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626162949349.png)</p>\n<p>协议并不仅限于类去遵循，我们也可以对结构体、枚举和 actors 使用协议。</p>\n<p>当你写下这个协议遵循的标注，编译器将会检查实体类型是否实现了协议中要求的必要条件。</p>\n<p>每个动物类型都必须实现 eat(food:) 这个方法，而且编译器可以推断出喂养所需食物的类型，因为它在参数列表中已经被使用(描述)过了(每个具体的类型对 eat 方法的实现里，都传入了具体的 food 参数的类型名称)。</p>\n<p>Feed 也可以通过类型别名明确的写出。</p>\n<h2 id=\"Write-generic-code\"><a href=\"#Write-generic-code\" class=\"headerlink\" title=\"Write generic code\"></a>Write generic code</h2><p>我们成功地确定了动物的通用能力，并且使用协议表达了这些能力。现在，我们可以开始书写泛型代码了。</p>\n<h3 id=\"Generics\"><a href=\"#Generics\" class=\"headerlink\" title=\"Generics\"></a>Generics</h3><p>我们可以使用动物协议来实现农场的 feed(animal:) 方法，我们想写一种实现，可以对所有的动物实体类型都通用。</p>\n<p>我们使用确定参数的多态，并且引入一个类型参数，当方法被调用的时候，类型参数会被替换为实体类型。</p>\n<p>类型参数是用尖括号包裹并写在函数名称后面的，就像通常的变量和函数参数那样，你可以随意给参数类型命名。</p>\n<p>并且就像任何其他的类型那样，你可以在函数体内使用类型参数的名称引用这个类型参数。</p>\n<p>这里我声明了一个类型参数 A，并且使用 A 作为函数参数动物的类型。</p>\n<p>![image-20220626164416814](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626164416814.png)</p>\n<p>我们总是希望实体动物类型遵循动物协议，所以在尖括号包裹的 A 之后标注其遵循 Animal 协议。</p>\n<p>![image-20220626165033294](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626165033294.png)</p>\n<p>协议遵循可以写在尖括号里，也可以在语句末尾使用 where 语句声明，在这里你还可以指明不同类型参数之间的关系。</p>\n<p>![image-20220626165151422](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626165151422.png)</p>\n<p>命名类型参数(也就在用尖括号包裹的类型参数后标注协议遵循)和在语句末尾使用 wehre 语句是非常有力量的，因为它允许你写出复杂的<del>必要条件</del>(要求)与类型之间的关系。但是大多数的泛型函数不需要这样的通用性。</p>\n<p>让我们把焦点放在 feed(animal:) 方法上。</p>\n<p>类型参数 A 在参数列表中出现过一次，而 where 语句罗列出了类型参数的必要条件的遵循情况。</p>\n<p>在这种情况下，命名类型参数和使用 where 语句让这个方法看起来过于复杂。</p>\n<p>![image-20220626165501956](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626165501956.png)</p>\n<p>这种泛型样式是相当常见的，所以有更简单的方式表达它。</p>\n<p>不再明确写出类型参数，我们可以就协议的遵循情况通过写成 some Animal 来表达这个抽象类型，这种声明方式跟前面的是等价的，但是那些不必要的类型参数列表和 where 语句都消失了，因为我们并不需要它们所提供的这种表达形式，使用 some Animal 更加直接。因为它减少了语法干扰，还在参数声明的右半部分包含了关于动物参数的语义信息。</p>\n<p>![image-20220626170002361](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626170002361.png)</p>\n<h4 id=\"some\"><a href=\"#some\" class=\"headerlink\" title=\"some\"></a>some</h4><p>让我们看看 some Animal 的语法。</p>\n<p>some 暗示这里有某一个具体的类型，some 之后总是会跟着一个要遵循的协议。</p>\n<p>在这个场景里，具体的类型必须遵循 Animal 协议，这允许我们在参数值上使用 Animal 协议中的必要条件(这允许我们对这个参数实例调用 Animal 协议中声明的方法)。</p>\n<p>some 关键字可以在函数参数和返回值的类型中使用，如果你之前写过 SwiftUI 代码，你应该早就用过 some，在返回值的位置使用 some View。</p>\n<p>返回值的类型 some View 跟这里恰恰是完全相同的概念。在 SwiftUI 的视图中，body 属性返回某个具体类型的视图，但是使用 body 属性的代码并不需要知道这个具体的类型是什么。</p>\n<p>![image-20220626170932734](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626170932734.png)</p>\n<p>让我们返回回去更好的理解一下一个(具体、特定、某一个)的抽象类型的概念。</p>\n<p>代表一个具体的实体类型的占位符的抽象类型叫做“不透明类型”。</p>\n<p>被替换的具体的实体类型叫做(underlying)基本类型，对于不透明类型的值，在值的使用范围内，基本类型是固定的。</p>\n<p>这样，泛型代码使用的值就被保证了值每次被访问的时候，都会获取到相同的基本类型。</p>\n<p>使用 some 关键字的类型，和一个用尖括号命名的类型参数，都声明了一个不透明类型。</p>\n<p>![image-20220626173329398](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626173329398.png)</p>\n<p>不透明类型在输入输出中都可以使用，所以它们可以声明在函数(方法)参数的位置，或是返回值的位置。</p>\n<p>函数的箭头将这两个位置分为两部分。</p>\n<p>![image-20220626173940091](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626173940091.png)</p>\n<p>不透明类型的位置决定了程序的哪个部分可以看到抽象类型，以及程序的哪个部分决定实体类型。</p>\n<p>命名类型参数总是声明在输入侧，所以调用者决定了基本类型，而实现使用了抽象类型。</p>\n<p>![image-20220626174210668](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626174210668.png)</p>\n<p>通常情况下，提供不透明参数或返回值类型的那部分程序，决定了基本类型；而使用这个值的那部分程序可以看到抽象类型。</p>\n<p>让我们深入了解一下这是怎么运转起来的。跟着我们对参数和返回值的直觉走。</p>\n<p>因为基本类型是通过一个值推断出来的，基本类型总是跟值一起出现在相同的位置。</p>\n<p>对于一个局部变量来说，基本类型是通过右边的赋值操作推断出来的，这意味着有着不透明类型的局部变量总是需要一个初始值(这样才能推断出其基本类型)。</p>\n<p>![image-20220626174951554](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626174951554.png)</p>\n<p>如果你不给提供初始值，编译器将会报错。</p>\n<p>![image-20220626175035323](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175035323.png)</p>\n<p>基本类型必须在变量的使用范围内被固定，所以对基本类型进行修改的尝试也会得出一个错误的结果。</p>\n<p>![image-20220626175134539](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175134539.png)</p>\n<p>对于使用不透明类型的参数来说，基本类型是在被调用的位置传入的实参值推断出来的。</p>\n<p>![image-20220626175314696](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175314696.png)</p>\n<h5 id=\"Swift-5-7——参数位置使用-some\"><a href=\"#Swift-5-7——参数位置使用-some\" class=\"headerlink\" title=\"Swift 5.7——参数位置使用 some\"></a>Swift 5.7——参数位置使用 some</h5><p>在参数位置使用 some 是 Swift 5.7 新增的功能。</p>\n<p>![image-20220626175447382](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175447382.png)</p>\n<p>基本类型只需要在参数的使用范围内被固定，所以每次调用都可以提供一个类型不同的参数。</p>\n<p>![image-20220626175640411](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175640411.png)</p>\n<h5 id=\"返回值位置使用-some\"><a href=\"#返回值位置使用-some\" class=\"headerlink\" title=\"返回值位置使用 some\"></a>返回值位置使用 some</h5><p>对不透明类型的返回值来说，基本类型是在函数实现中的返回值的位置进行推断的。</p>\n<p>![image-20220626180718256](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626180718256.png)</p>\n<p>有不透明类型返回值的方法或者计算属性，可以在程序的任何位置被调用，所以这个值的可用范围是全局的。这意味着，返回值的基本类型需要在所有的返回语句中保持一致。如果没有保持一致，编译器将会报错，基本类型返回值的类型不匹配。</p>\n<p>![image-20220626181045890](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626181045890.png)</p>\n<p>对于不透明类型的 SwiftUI View，ViewBuilder DSL 可以将控制流语句的每个分支都转换成拥有相同基本类型的返回值。</p>\n<p>所以在这个场景下，我们可以使用 ViewBuilder DSL 来解决这个问题。在方法前写一个修饰符 @ViewBuilder，并且移除掉 return 语句，将会允许通过 ViewBuilder 的类型来为我们构建返回值类型。</p>\n<p>![image-20220626181303429](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626181303429.png)</p>\n<h5 id=\"举例说明\"><a href=\"#举例说明\" class=\"headerlink\" title=\"举例说明\"></a>举例说明</h5><p>让我们回到 feedAnimal 方法吧。</p>\n<p>我将会使用 some 在参数列表中，因为我并不需要在其他位置引用这个不透明类型的参数。当你需要在函数体中多次引用这个不透明类型时，也就是说类型参数的名称要能手到擒来。</p>\n<p>举个例子，当我们给 Animal 协议添加另外一个关联值，Habitat。</p>\n<p>![image-20220626181844443](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626181844443.png)</p>\n<p>我们也许想要在农场上为某个指定的动物构建一个栖息地，这个场景下，返回值类型就依赖于这个具体的动物的类型了，所以我们在参数和返回值的位置都需要用到类型参数 A。</p>\n<p>![image-20220626183735613](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626183735613.png)</p>\n<p>另一个你需要多次引用不透明类型的常见的地方，是在泛型中。代码通常在泛型类型上声明一个类型参数，为一个存储属性使用类型参数，并且也给一个成员构造器传递参数。</p>\n<p>![image-20220626184243060](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626184243060.png)</p>\n<p>在不同的上下文中引用泛型类型，也需要你用尖括号明确指出类型参数(也就是说在同一个上下文范围内，明确指出一次应该就够了，之后编辑器可以推断出来)。在声明中的尖括号里的泛型可以帮助阐明如何使用一个泛型类型，<strong>所以不透明类型必须总是被命名为泛型类型</strong>。</p>\n<p>![image-20220626190535609](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626190535609.png)</p>\n<p>现在，让我们一起构造出 feed 方法的实现吧。</p>\n<p>我们可以使用动物参数的类型来访问种植的庄稼类型，通过 Feed 的关联类型。我们调用 Feed.grow() 来获取庄稼实例，这个庄稼可以产出要用来喂动物进食的类型的食物。</p>\n<p>![image-20220626190910250](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626190910250.png)</p>\n<p>接下来，我们需要收割庄稼的产出，可以通过调用庄稼的一个方法 harvest()</p>\n<p>![image-20220626191404371](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626191404371.png)</p>\n<p>最后我们可以把产出的食物喂给动物吃，因为基本的动物类型是固定的，编译器知道植物类型(alfara)与产出食物类型(hay)，以及在多个方法之间调用的动物类型(cow)之间的关系。</p>\n<p>![image-20220626191534121](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626191534121.png)</p>\n<p>这些静态的关系可以让我们避免给动物喂错食物。</p>\n<p>如果我们尝试使用没有被保证可以为这个动物喂养的食物类型，编译器就会告诉我们。</p>\n<p>![image-20220626191900776](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626191900776.png)</p>\n<p>想要学习其他的农场协议是如何定义，并用来表达喂养动物的类型和它所食用的植物之间关系的，请参考 110353</p>\n<p>![image-20220626193714763](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626193714763.png)</p>\n<p>最后，让我们添加一个 feedAll(animals:) 方法，接收一个数组作为参数，我知道元素类型需要遵循 Animal 协议，但是我希望这个数组可以存储不同类型的动物。</p>\n<p>![image-20220626202924050](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626202924050.png)</p>\n<p>让我们看看这里用不透明类型 some Animal 是否可行。</p>\n<p>![image-20220626203030188](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626203030188.png)</p>\n<p>使用 some 关键字，就意味着这个具体的基本类型不能发生改变，因为基本类型是固定的，数组中所有的元素都必须是相同的类型，所以，用 some Animal 描述数组元素的类型并不能准确表达我们的意图。因为我想要一个可以存储不同类型元素的数组。</p>\n<p>![image-20220626203102314](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626203102314.png)</p>\n<p>这里，我们需要的是一个可以代表任何动物的超类，我们可以使用 any Animal 来表示任意类型的动物。</p>\n<p>![image-20220626203544327](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626203544327.png)</p>\n<p>any 关键字表明这个类型可以存储任意类型的动物，基本类型在运行时也可以改变。</p>\n<p>就像 some 关键字那样，any 关键字后也跟随着一个要遵循的协议，any Animal 是一个单一的静态类型，拥有动态存储任意动物实体类型的能力。这个能力允许我们对值类型使用<strong>子类多态</strong>。为了允许这个灵活的存储，any Animal 在内存中的存储有一个特殊的表达。</p>\n<p>你可以把这种表达形式想像成一个盒子，有时候，值能够直接装进盒子。</p>\n<p>![image-20220626204305609](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626204305609.png)</p>\n<p>而另外一些值太大了盒子装不下，所以值需要在其他位置分配内存空间，盒子只是用一个指针指向这个空间。</p>\n<p>![image-20220626204442868](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626204442868.png)</p>\n<p>any Animal 这个静态类型可以动态存储任何实体类型这种行为被正式的称为<strong>存在主义类型</strong>。</p>\n<p>![image-20220626204819602](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626204819602.png)</p>\n<p>对不同实体类型使用相同表达的策略叫做类型擦除。</p>\n<p>在编译时，实体类型的类型被擦除，直到运行时才被体现出来。</p>\n<p>存在类型 any Animal 的这两个实例，有相同的静态类型(具体的静态类型是什么？)，但是不同的动态类型(具体的动态类型又是什么？)。</p>\n<p>类型擦除消除了不同动物在类型级别的区别，这允许我们使用静态类型相同但动态类型不同的值。</p>\n<p>![image-20220626205158501](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626205158501.png)</p>\n<p>我们可以使用类型擦除来书写一个异源值类型数组，这正是我们在 feedAll(animals:) 方法中所需要的。</p>\n<h5 id=\"Swift-5-7——参数位置使用-any\"><a href=\"#Swift-5-7——参数位置使用-any\" class=\"headerlink\" title=\"Swift 5.7——参数位置使用 any\"></a>Swift 5.7——参数位置使用 any</h5><p>![image-20220626205642059](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626205642059.png)</p>\n<p>所以我们使用一个数组，用 any Animal 作为参数的类型，<strong>对协议使用 any 关键字和关联类型(哪里使用关联类型了？)是 Swift 5.7 新增的功能</strong>。</p>\n<p>为了实现 feedAll(animals:) 方法，我们首先遍历这个 animals 数组。</p>\n<p>![image-20220626205904465](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626205904465.png)</p>\n<p>对于每个动物，我们都想调用 Animal 协议中的 eat(food:) 方法。</p>\n<p>![image-20220626210014893](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626210014893.png)</p>\n<p>为了调用这个方法，在这次遍历中，我们需要获取到具体的基本类型 Feed 的类型。</p>\n<p>![image-20220626210159916](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626210159916.png)</p>\n<p>但是一旦我们对 any Animal 调用 eat(food:) 方法，我们将会得到一个编译错误。</p>\n<p>![image-20220626210358657](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626210358657.png)</p>\n<p>因为我们消除了具体动物类型在编译时类型级别的区别，我们也消除了所有类型之间的关系，这些关系本身是依赖于具体的动物类型的，也包括关联类型。</p>\n<p><strong>所以我们不知道这个类型的动物希望被喂什么类型的食物。为了能够依赖这些类型之间的关系，我们需要回到之前动物的具体类型仍然固定的上下文，不再直接对 any Animal 调用 eat(food:) 方法，我们需要调用可以接收 some Animal 的 feed 方法。</strong></p>\n<p>![image-20220626211117177](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626211117177.png)</p>\n<p>any Animal 跟 some Animal 是不同的，但是编译器可以通过“拆包”基本类型值的方式将 any Animal 的实例转换为 some Animal，并且把它直接传给 some Animal 参数。</p>\n<p><strong>这个“拆包”实参的能力是 Swift 5. 7 新增的。</strong></p>\n<p>![image-20220626211430157](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626211430157.png)</p>\n<p>你可以把拆包看作是编译器打开了盒子并取出了存在其中的值。</p>\n<p>some Animal 参数的使用范围内，这个值都有一个固定的基本类型。所以我们可以访问所有对基本类型的操作，包括访问关联类型。</p>\n<p>这真的很酷，因为它允许我们在需要的时候选择灵活的存储(即类型擦除，装进盒子里)，同时也可以回到之前的拥有函数体内可使用范围的固定基本类型的静态类型系统完整表达的上下文。</p>\n<p>大多数情况下，你并不需要去考虑拆包，因为它就是按照你期待的方式工作的，与对 any Animal 调用协议方法类似，就是对基本类型调用这个方法。</p>\n<p>所以我们可以对每个动物都调用 feed(animal:) 方法，在那里，每次遍历我们都可以种植并且收割合适的庄稼来喂养具体的动物。</p>\n<p>![image-20220626215127833](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626215127833.png)</p>\n<p>在这个过程中，我们看到了 some 和 any 不同的能力。</p>\n<p>使用 some，基本类型就是固定的，这允许你在泛型代码中依赖于固定的基本类型之间的关系，所以你有对 API 和协议关联类型的完整的访问权限。</p>\n<p>使用 any，当你需要存储任意实体类型时，any 提供了类型擦除，允许你表达异源集合，表达基本类型的缺席，使用可选项，同时抽象实现细节。</p>\n<p>![image-20220626215828321](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626215828321.png)</p>\n<p>总而言之，默认情况下使用 some，当你想要存储任意类型的值时，将 some 改为 any。</p>\n<p>使用这种方式，只在你需要存储灵活性时，付出类型擦除和语义限制的代价即可。</p>\n<p>这个工作流程与默认书写 let 表示常量，直到你需要变量时类似。</p>\n<p>在这个视频中，我们想要通过这个工作流程随着代码的演进来生成代码并且获得更多的功能。</p>\n<p>我们从实体类型开始，随着代码获得更多的功能，我们发觉在不同的类型中的代码重复。从这里开始，我们确定了通用的能力，并且使用协议生成了这些能力，最后我们用 some 和 any 写了抽象代码，并且讨论了我们倾向于使用 some 来书写更具有表达性的代码。</p>\n<p>想要更深入的构建协议和理解类型擦除，可以看 110353。</p>\n<p>![image-20220626220750663](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626220750663.png)</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"WWDC-22-110352-拥抱-Swift-泛型-第一次整理\"><a href=\"#WWDC-22-110352-拥抱-Swift-泛型-第一次整理\" class=\"headerlink\" title=\"WWDC 22 - 110352 拥抱 Swift 泛型 第一次整理\"></a>WWDC 22 - 110352 拥抱 Swift 泛型 第一次整理</h1><p>大家好，我是 holly，来自 Swift 编译组，欢迎来到拥抱 Swift 泛型。</p>\n<p>泛型是一个书写 Swift 抽象代码的基本工具，随着代码的演化发展，泛型是起到管理复杂性的关键。</p>\n<p>抽象概念可以将思想从特定的细节中分离出来，在代码中，有很多种方式(途径)可以使用泛型(泛型都起到了作用)。</p>\n<p>你可能经常使用到的一种抽象概念的形式就是将代码抽出来到一个函数或是一个局部变量，如果你想要多次使用同一功能或同一个值时，这是非常有用的。</p>\n<p>当你把一个功能提取到一个函数里时，函数的细节就被抽出去(抽象化)了，而使用(调用)个抽象函数的代码，就可以表达所发生的事情，而不需要重复细节了。</p>\n<p>在 Swift 中，你也可以将实体类型抽象出来，如果你有一系列的类型，它们使用了相同的思想，和不同的实现细节，你就可以写抽象的代码来实现所有这些实体类型。</p>\n<p>今天，我们将通过模型化实体类型、确定一系列实体类型的通用能力、构建一个接口来表达(呈现)这些能力、深入了解如何使用这些接口来实现泛型的书写的步骤来向你展示泛型的具体使用场景。</p>\n<p>![image-20220626140259410](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626140259410.png)</p>\n<p>我们将通过构建一些代码来模拟一个农场的形式，一起探索 Swift 抽象工具的使用。</p>\n<h2 id=\"Model-with-concrete-types\"><a href=\"#Model-with-concrete-types\" class=\"headerlink\" title=\"Model with concrete types\"></a>Model with concrete types</h2><p>让我们先来写几个实体类型吧。</p>\n<p>首先创建一个叫做 Cow 的结构体，它有一个方法叫做 eat(food:)，接收一个 Hay 类型的参数。</p>\n<p>Hay 是另一个结构体，它有一个<strong>静态</strong>方法叫做 grow() -&gt; Alfalfa，可以种植一些能够长出 Hay 的庄稼 Alfalfa。</p>\n<p>Alfalfa 结构体有一个方法 harvest() -&gt; Hay 通过 Alfalfa 实例来收获 Hay。</p>\n<p>最后，我们抽象出一个农场 Farm，它有一个方法 feed(animal:) 可以喂养奶牛。</p>\n<p>feed(animal:) 方法可以通过首先种一些苜蓿 Alfalfa 来生产干草 Hay，然后收获干草 Hay ，最后用干草 Hay 来喂养奶牛 Cow 的方式实现。</p>\n<p>这时，我就能在我的农场来饲养奶牛了。</p>\n<p>![image-20220626141648138](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626141648138.png)</p>\n<p>但是我想饲养更多的动物。</p>\n<p>我可以添加更多的结构体来代表其他的动物，就像 Horse 马和 Chicken 鸡。</p>\n<p>我想在农场上饲养奶牛，马，鸡。</p>\n<h3 id=\"Overloads\"><a href=\"#Overloads\" class=\"headerlink\" title=\"Overloads\"></a>Overloads</h3><p>我可以重载这个 feed(animal:) 方法分别来接收不同类型的参数，但是每个重载函数都会有一个相当类似的实现。</p>\n<p>![image-20220626142527042](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626142527042.png)</p>\n<p>当我添加更多的动物类型时，这将造成类似代码的堆积，基本上到处都是重复的代码。</p>\n<p>当你发现自己写的重载代码有重复的实现时，就是概括归纳(抽象、重构)的预兆了。</p>\n<p>基本上说，这些实现都很类似，因为(饲养)不同类型的动物在功能(喂养)上是相似的。</p>\n<h2 id=\"Identify-common-capabilities\"><a href=\"#Identify-common-capabilities\" class=\"headerlink\" title=\"Identify common capabilities\"></a>Identify common capabilities</h2><p>第二步，就是来确定动物类型的通用能力了。</p>\n<p>我们已经构建了一系列动物类型了，它们都有一个能力，吃某一种食物。</p>\n<p>每种类型的动物都有不同的进食方式，所以每个动物的 eat(food:) 方法都有不同的行为表现。</p>\n<p>我们要做的就是允许抽象代码在调用的时候调同一个方法，也就是 eat(food:) 方法，在这个的同时，让这些抽象代码在 eat(food:) 方法中的行为表现不同，这取决于抽象代码所执行在的实体的具体类型。</p>\n<p>抽象代码在不同的实体类型上可以表现不同能力的功能叫做多态，多态允许一份代码拥有多种行为表现，取决于代码是被如何使用的。</p>\n<p>更恰当地说的话，多态本身就是不同形式的。</p>\n<p>首先是函数的重载，根据传入参数类型的不同，同样的函数调用可以意味着不同的事物。重载被称为 ad-hoc(临时安排的、特别的、专门的) 多态，因为它并不是一个通用的解决方案。我们只是为了看到重载到底是如何一步步走向重复代码的。</p>\n<p>下一步，是子类多态。代码在一个超类上去执行调用，实际上却会在运行时基于特定的子类而产生不同的表现。</p>\n<p>最后是使用泛型来实现的确定(指定)参数的多态。</p>\n<p>![image-20220628195428703](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220628195428703.png)</p>\n<p>泛型代码使用类型参数，来允许书写一份代码与不同类型一起奏效(工作、运行)。而实体类型呢，则将作为实参进行传递。</p>\n<p>我们早就已经把重载排除出局了，所以让我们尝试使用子类多态吧。</p>\n<h3 id=\"Subtypes\"><a href=\"#Subtypes\" class=\"headerlink\" title=\"Subtypes\"></a>Subtypes</h3><p>代表子类关系的一种方式是使用类层级(用类替换结构体)。我们可以引入一个类叫做 Animal 动物。</p>\n<p>![image-20220626145345481](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626145345481.png)</p>\n<p>然后，我们将每种动物类型从结构体更改为类。</p>\n<p>每个具体的动物类都继承自 Animal 动物这个超类并且重写 eat(food:) 方法。</p>\n<p>现在，我们有一个抽象的基类 Animal 动物，可以代表我们每一个具体的动物类型。调用 Animal 动物的 eat(food:) 方法将会通过使用子类多态而调用到子类的具体实现，但这样还没完。</p>\n<p>我们仍然没有补全 Animal 动物 eat(:food) 方法的参数类型，这份代码还有一些报错。</p>\n<p>首先，使用类将强制我们使用引用类型语义，即使我们并不需要分享不同实例间的任何状态。这个策略也需要子类去重写基类中的方法。但是忘记重写基类方法只有在运行时才会被捕获。</p>\n<p>但是对这个模型抽象的过程中更大的问题是每种子类动物都会食用不同类型的食物，这种依赖用类层级相当难以表达。(即 eat(food:) 方法中 food 参数的类型必须明确标明，但是因为每种动物所食用的食物都是不同的，所以很难明确写清楚)</p>\n<h4 id=\"Any\"><a href=\"#Any\" class=\"headerlink\" title=\"Any\"></a>Any</h4><p>一种方式是让 eat(food:) 方法中食物的参数接收一个不具体(明确)的类型， 例如 Any。</p>\n<p>![image-20220626150733935](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626150733935.png)</p>\n<p>但是这种策略在子类实现中，仍然需要在运行时确定好准确的类型并传入，这样，在每个重写的方法中又一次出现了代码堆积。(只是把代码堆积的位置改变了而已)</p>\n<p>![image-20220626150958877](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626150958877.png)</p>\n<p>但是更重要的是，这份代码允许你不小心传入一个错误的食物类型，造成另一个只能在运行时才捕获的 bug。我们再试试别的方法吧。(即使你在调用的时候，传入的食物类型与实际期待的不符，也只会在运行时才会报错)</p>\n<h4 id=\"lt-T-gt\"><a href=\"#lt-T-gt\" class=\"headerlink\" title=\"&lt;T&gt;\"></a>&lt;T&gt;</h4><p>我们可以通过在超类 Animal 动物类上引入一种类型安全的类型参数的方式，来替代表达喂养动物所用食物的类型。</p>\n<p>这种类型参数对每一个子类的食物喂养类型使用一个占位符，通过这种方式，Food 参数的类型必须被提升到 Animal 类的声明中才行。</p>\n<p>![image-20220626152712935](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626152712935.png)</p>\n<p>这看起来有点诡异，因为尽管动物需要食物来填饱肚子，但是进食并不是动物的主要目标，很多与动物相关的代码也许根本不关心它们吃什么食物。尽管如此，所有对 Animal 类的引用(也就是对 Animal 的实例化)都需要指明 Food 的类型。</p>\n<p>举个例子，每个 Animal 的子类都需要在声明继承的代码中使用尖括号明确指出它的食物类型，如果我们添加更多需要明确指定的类型给每种 Animal，这种代码模板在每个使用 Animal 类的地方都将变得非常繁琐。</p>\n<p>![image-20220626153746315](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626153746315.png)</p>\n<p>所以我们上述的两种方式既低效，又不能正确地表达语义。</p>\n<p><strong>根本问题是，类是一种数据类型，我们却想要尝试复杂化一个超类，然后让它代表实体类型的抽象思想。</strong></p>\n<p>取而代之的是，我们想要构建一个能够代表类型的能力，但不需要这个能力实现的细节。</p>\n<p>动物有两个常见的能力，每种动物都有一种具体的食物类型，和一种进食方式。</p>\n<h2 id=\"Build-an-interface\"><a href=\"#Build-an-interface\" class=\"headerlink\" title=\"Build an interface\"></a>Build an interface</h2><p>我们可以构建一种接口来代表这两种能力。</p>\n<p>在 Swift 中，使用协议来实现这种功能。</p>\n<p>协议是一种抽象工具，描述了遵循它协议的类型的功能。使用协议，你可以把一个类所做的事情的构思与其具体的实现区分开来。一个类所做的事情的构思用接口来表达。</p>\n<p>让我们将动物的能力使用协议接口来翻译一下。</p>\n<p>协议的名称代表我们所描述的这种类型的分类(类别、范畴、种类)，所以我管这个协议叫“Animal 动物”。</p>\n<p>每个能力都将映射到一个协议的必要条件(要求、接口、方法)上。</p>\n<p>食物的具体类型将会映射为协议中的一个关联类型，就像类型参数一样，关联类型也是作为实体类型的占位符。</p>\n<p>![image-20220626160017654](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626160017654.png)</p>\n<p>关联类型的特别之处在于，它取决于遵循协议的那个类型的具体类型，这层关系是有保障的。所以对应到(每个)具体的动物类型的不同实例都有相同的食物类型。</p>\n<p>接下来，进食的行为将会映射为一个方法。这个方法叫做 eat(food:)，它接收一个参数，喂养动物所需食物的类型。</p>\n<p>![image-20220626160729154](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626160729154.png)</p>\n<p>协议中并没有这个方法的实现，实体动物类型被要求去实现它(具体的动物类型才需要去实现它)。</p>\n<p>现在，我们有一个动物协议，我们可以让每个实体动物类型都遵循它。</p>\n<p>你可以对一个实体类型进行标记，在它的声明或者扩展中，代表它遵循了一个协议。</p>\n<p>![image-20220626162949349](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626162949349.png)</p>\n<p>协议并不仅限于类去遵循，我们也可以对结构体、枚举和 actors 使用协议。</p>\n<p>当你写下这个协议遵循的标注，编译器将会检查实体类型是否实现了协议中要求的必要条件。</p>\n<p>每个动物类型都必须实现 eat(food:) 这个方法，而且编译器可以推断出喂养所需食物的类型，因为它在参数列表中已经被使用(描述)过了(每个具体的类型对 eat 方法的实现里，都传入了具体的 food 参数的类型名称)。</p>\n<p>Feed 也可以通过类型别名明确的写出。</p>\n<h2 id=\"Write-generic-code\"><a href=\"#Write-generic-code\" class=\"headerlink\" title=\"Write generic code\"></a>Write generic code</h2><p>我们成功地确定了动物的通用能力，并且使用协议表达了这些能力。现在，我们可以开始书写泛型代码了。</p>\n<h3 id=\"Generics\"><a href=\"#Generics\" class=\"headerlink\" title=\"Generics\"></a>Generics</h3><p>我们可以使用动物协议来实现农场的 feed(animal:) 方法，我们想写一种实现，可以对所有的动物实体类型都通用。</p>\n<p>我们使用确定参数的多态，并且引入一个类型参数，当方法被调用的时候，类型参数会被替换为实体类型。</p>\n<p>类型参数是用尖括号包裹并写在函数名称后面的，就像通常的变量和函数参数那样，你可以随意给参数类型命名。</p>\n<p>并且就像任何其他的类型那样，你可以在函数体内使用类型参数的名称引用这个类型参数。</p>\n<p>这里我声明了一个类型参数 A，并且使用 A 作为函数参数动物的类型。</p>\n<p>![image-20220626164416814](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626164416814.png)</p>\n<p>我们总是希望实体动物类型遵循动物协议，所以在尖括号包裹的 A 之后标注其遵循 Animal 协议。</p>\n<p>![image-20220626165033294](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626165033294.png)</p>\n<p>协议遵循可以写在尖括号里，也可以在语句末尾使用 where 语句声明，在这里你还可以指明不同类型参数之间的关系。</p>\n<p>![image-20220626165151422](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626165151422.png)</p>\n<p>命名类型参数(也就在用尖括号包裹的类型参数后标注协议遵循)和在语句末尾使用 wehre 语句是非常有力量的，因为它允许你写出复杂的<del>必要条件</del>(要求)与类型之间的关系。但是大多数的泛型函数不需要这样的通用性。</p>\n<p>让我们把焦点放在 feed(animal:) 方法上。</p>\n<p>类型参数 A 在参数列表中出现过一次，而 where 语句罗列出了类型参数的必要条件的遵循情况。</p>\n<p>在这种情况下，命名类型参数和使用 where 语句让这个方法看起来过于复杂。</p>\n<p>![image-20220626165501956](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626165501956.png)</p>\n<p>这种泛型样式是相当常见的，所以有更简单的方式表达它。</p>\n<p>不再明确写出类型参数，我们可以就协议的遵循情况通过写成 some Animal 来表达这个抽象类型，这种声明方式跟前面的是等价的，但是那些不必要的类型参数列表和 where 语句都消失了，因为我们并不需要它们所提供的这种表达形式，使用 some Animal 更加直接。因为它减少了语法干扰，还在参数声明的右半部分包含了关于动物参数的语义信息。</p>\n<p>![image-20220626170002361](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626170002361.png)</p>\n<h4 id=\"some\"><a href=\"#some\" class=\"headerlink\" title=\"some\"></a>some</h4><p>让我们看看 some Animal 的语法。</p>\n<p>some 暗示这里有某一个具体的类型，some 之后总是会跟着一个要遵循的协议。</p>\n<p>在这个场景里，具体的类型必须遵循 Animal 协议，这允许我们在参数值上使用 Animal 协议中的必要条件(这允许我们对这个参数实例调用 Animal 协议中声明的方法)。</p>\n<p>some 关键字可以在函数参数和返回值的类型中使用，如果你之前写过 SwiftUI 代码，你应该早就用过 some，在返回值的位置使用 some View。</p>\n<p>返回值的类型 some View 跟这里恰恰是完全相同的概念。在 SwiftUI 的视图中，body 属性返回某个具体类型的视图，但是使用 body 属性的代码并不需要知道这个具体的类型是什么。</p>\n<p>![image-20220626170932734](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626170932734.png)</p>\n<p>让我们返回回去更好的理解一下一个(具体、特定、某一个)的抽象类型的概念。</p>\n<p>代表一个具体的实体类型的占位符的抽象类型叫做“不透明类型”。</p>\n<p>被替换的具体的实体类型叫做(underlying)基本类型，对于不透明类型的值，在值的使用范围内，基本类型是固定的。</p>\n<p>这样，泛型代码使用的值就被保证了值每次被访问的时候，都会获取到相同的基本类型。</p>\n<p>使用 some 关键字的类型，和一个用尖括号命名的类型参数，都声明了一个不透明类型。</p>\n<p>![image-20220626173329398](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626173329398.png)</p>\n<p>不透明类型在输入输出中都可以使用，所以它们可以声明在函数(方法)参数的位置，或是返回值的位置。</p>\n<p>函数的箭头将这两个位置分为两部分。</p>\n<p>![image-20220626173940091](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626173940091.png)</p>\n<p>不透明类型的位置决定了程序的哪个部分可以看到抽象类型，以及程序的哪个部分决定实体类型。</p>\n<p>命名类型参数总是声明在输入侧，所以调用者决定了基本类型，而实现使用了抽象类型。</p>\n<p>![image-20220626174210668](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626174210668.png)</p>\n<p>通常情况下，提供不透明参数或返回值类型的那部分程序，决定了基本类型；而使用这个值的那部分程序可以看到抽象类型。</p>\n<p>让我们深入了解一下这是怎么运转起来的。跟着我们对参数和返回值的直觉走。</p>\n<p>因为基本类型是通过一个值推断出来的，基本类型总是跟值一起出现在相同的位置。</p>\n<p>对于一个局部变量来说，基本类型是通过右边的赋值操作推断出来的，这意味着有着不透明类型的局部变量总是需要一个初始值(这样才能推断出其基本类型)。</p>\n<p>![image-20220626174951554](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626174951554.png)</p>\n<p>如果你不给提供初始值，编译器将会报错。</p>\n<p>![image-20220626175035323](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175035323.png)</p>\n<p>基本类型必须在变量的使用范围内被固定，所以对基本类型进行修改的尝试也会得出一个错误的结果。</p>\n<p>![image-20220626175134539](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175134539.png)</p>\n<p>对于使用不透明类型的参数来说，基本类型是在被调用的位置传入的实参值推断出来的。</p>\n<p>![image-20220626175314696](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175314696.png)</p>\n<h5 id=\"Swift-5-7——参数位置使用-some\"><a href=\"#Swift-5-7——参数位置使用-some\" class=\"headerlink\" title=\"Swift 5.7——参数位置使用 some\"></a>Swift 5.7——参数位置使用 some</h5><p>在参数位置使用 some 是 Swift 5.7 新增的功能。</p>\n<p>![image-20220626175447382](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175447382.png)</p>\n<p>基本类型只需要在参数的使用范围内被固定，所以每次调用都可以提供一个类型不同的参数。</p>\n<p>![image-20220626175640411](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626175640411.png)</p>\n<h5 id=\"返回值位置使用-some\"><a href=\"#返回值位置使用-some\" class=\"headerlink\" title=\"返回值位置使用 some\"></a>返回值位置使用 some</h5><p>对不透明类型的返回值来说，基本类型是在函数实现中的返回值的位置进行推断的。</p>\n<p>![image-20220626180718256](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626180718256.png)</p>\n<p>有不透明类型返回值的方法或者计算属性，可以在程序的任何位置被调用，所以这个值的可用范围是全局的。这意味着，返回值的基本类型需要在所有的返回语句中保持一致。如果没有保持一致，编译器将会报错，基本类型返回值的类型不匹配。</p>\n<p>![image-20220626181045890](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626181045890.png)</p>\n<p>对于不透明类型的 SwiftUI View，ViewBuilder DSL 可以将控制流语句的每个分支都转换成拥有相同基本类型的返回值。</p>\n<p>所以在这个场景下，我们可以使用 ViewBuilder DSL 来解决这个问题。在方法前写一个修饰符 @ViewBuilder，并且移除掉 return 语句，将会允许通过 ViewBuilder 的类型来为我们构建返回值类型。</p>\n<p>![image-20220626181303429](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626181303429.png)</p>\n<h5 id=\"举例说明\"><a href=\"#举例说明\" class=\"headerlink\" title=\"举例说明\"></a>举例说明</h5><p>让我们回到 feedAnimal 方法吧。</p>\n<p>我将会使用 some 在参数列表中，因为我并不需要在其他位置引用这个不透明类型的参数。当你需要在函数体中多次引用这个不透明类型时，也就是说类型参数的名称要能手到擒来。</p>\n<p>举个例子，当我们给 Animal 协议添加另外一个关联值，Habitat。</p>\n<p>![image-20220626181844443](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626181844443.png)</p>\n<p>我们也许想要在农场上为某个指定的动物构建一个栖息地，这个场景下，返回值类型就依赖于这个具体的动物的类型了，所以我们在参数和返回值的位置都需要用到类型参数 A。</p>\n<p>![image-20220626183735613](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626183735613.png)</p>\n<p>另一个你需要多次引用不透明类型的常见的地方，是在泛型中。代码通常在泛型类型上声明一个类型参数，为一个存储属性使用类型参数，并且也给一个成员构造器传递参数。</p>\n<p>![image-20220626184243060](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626184243060.png)</p>\n<p>在不同的上下文中引用泛型类型，也需要你用尖括号明确指出类型参数(也就是说在同一个上下文范围内，明确指出一次应该就够了，之后编辑器可以推断出来)。在声明中的尖括号里的泛型可以帮助阐明如何使用一个泛型类型，<strong>所以不透明类型必须总是被命名为泛型类型</strong>。</p>\n<p>![image-20220626190535609](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626190535609.png)</p>\n<p>现在，让我们一起构造出 feed 方法的实现吧。</p>\n<p>我们可以使用动物参数的类型来访问种植的庄稼类型，通过 Feed 的关联类型。我们调用 Feed.grow() 来获取庄稼实例，这个庄稼可以产出要用来喂动物进食的类型的食物。</p>\n<p>![image-20220626190910250](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626190910250.png)</p>\n<p>接下来，我们需要收割庄稼的产出，可以通过调用庄稼的一个方法 harvest()</p>\n<p>![image-20220626191404371](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626191404371.png)</p>\n<p>最后我们可以把产出的食物喂给动物吃，因为基本的动物类型是固定的，编译器知道植物类型(alfara)与产出食物类型(hay)，以及在多个方法之间调用的动物类型(cow)之间的关系。</p>\n<p>![image-20220626191534121](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626191534121.png)</p>\n<p>这些静态的关系可以让我们避免给动物喂错食物。</p>\n<p>如果我们尝试使用没有被保证可以为这个动物喂养的食物类型，编译器就会告诉我们。</p>\n<p>![image-20220626191900776](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626191900776.png)</p>\n<p>想要学习其他的农场协议是如何定义，并用来表达喂养动物的类型和它所食用的植物之间关系的，请参考 110353</p>\n<p>![image-20220626193714763](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626193714763.png)</p>\n<p>最后，让我们添加一个 feedAll(animals:) 方法，接收一个数组作为参数，我知道元素类型需要遵循 Animal 协议，但是我希望这个数组可以存储不同类型的动物。</p>\n<p>![image-20220626202924050](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626202924050.png)</p>\n<p>让我们看看这里用不透明类型 some Animal 是否可行。</p>\n<p>![image-20220626203030188](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626203030188.png)</p>\n<p>使用 some 关键字，就意味着这个具体的基本类型不能发生改变，因为基本类型是固定的，数组中所有的元素都必须是相同的类型，所以，用 some Animal 描述数组元素的类型并不能准确表达我们的意图。因为我想要一个可以存储不同类型元素的数组。</p>\n<p>![image-20220626203102314](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626203102314.png)</p>\n<p>这里，我们需要的是一个可以代表任何动物的超类，我们可以使用 any Animal 来表示任意类型的动物。</p>\n<p>![image-20220626203544327](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626203544327.png)</p>\n<p>any 关键字表明这个类型可以存储任意类型的动物，基本类型在运行时也可以改变。</p>\n<p>就像 some 关键字那样，any 关键字后也跟随着一个要遵循的协议，any Animal 是一个单一的静态类型，拥有动态存储任意动物实体类型的能力。这个能力允许我们对值类型使用<strong>子类多态</strong>。为了允许这个灵活的存储，any Animal 在内存中的存储有一个特殊的表达。</p>\n<p>你可以把这种表达形式想像成一个盒子，有时候，值能够直接装进盒子。</p>\n<p>![image-20220626204305609](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626204305609.png)</p>\n<p>而另外一些值太大了盒子装不下，所以值需要在其他位置分配内存空间，盒子只是用一个指针指向这个空间。</p>\n<p>![image-20220626204442868](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626204442868.png)</p>\n<p>any Animal 这个静态类型可以动态存储任何实体类型这种行为被正式的称为<strong>存在主义类型</strong>。</p>\n<p>![image-20220626204819602](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626204819602.png)</p>\n<p>对不同实体类型使用相同表达的策略叫做类型擦除。</p>\n<p>在编译时，实体类型的类型被擦除，直到运行时才被体现出来。</p>\n<p>存在类型 any Animal 的这两个实例，有相同的静态类型(具体的静态类型是什么？)，但是不同的动态类型(具体的动态类型又是什么？)。</p>\n<p>类型擦除消除了不同动物在类型级别的区别，这允许我们使用静态类型相同但动态类型不同的值。</p>\n<p>![image-20220626205158501](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626205158501.png)</p>\n<p>我们可以使用类型擦除来书写一个异源值类型数组，这正是我们在 feedAll(animals:) 方法中所需要的。</p>\n<h5 id=\"Swift-5-7——参数位置使用-any\"><a href=\"#Swift-5-7——参数位置使用-any\" class=\"headerlink\" title=\"Swift 5.7——参数位置使用 any\"></a>Swift 5.7——参数位置使用 any</h5><p>![image-20220626205642059](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626205642059.png)</p>\n<p>所以我们使用一个数组，用 any Animal 作为参数的类型，<strong>对协议使用 any 关键字和关联类型(哪里使用关联类型了？)是 Swift 5.7 新增的功能</strong>。</p>\n<p>为了实现 feedAll(animals:) 方法，我们首先遍历这个 animals 数组。</p>\n<p>![image-20220626205904465](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626205904465.png)</p>\n<p>对于每个动物，我们都想调用 Animal 协议中的 eat(food:) 方法。</p>\n<p>![image-20220626210014893](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626210014893.png)</p>\n<p>为了调用这个方法，在这次遍历中，我们需要获取到具体的基本类型 Feed 的类型。</p>\n<p>![image-20220626210159916](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626210159916.png)</p>\n<p>但是一旦我们对 any Animal 调用 eat(food:) 方法，我们将会得到一个编译错误。</p>\n<p>![image-20220626210358657](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626210358657.png)</p>\n<p>因为我们消除了具体动物类型在编译时类型级别的区别，我们也消除了所有类型之间的关系，这些关系本身是依赖于具体的动物类型的，也包括关联类型。</p>\n<p><strong>所以我们不知道这个类型的动物希望被喂什么类型的食物。为了能够依赖这些类型之间的关系，我们需要回到之前动物的具体类型仍然固定的上下文，不再直接对 any Animal 调用 eat(food:) 方法，我们需要调用可以接收 some Animal 的 feed 方法。</strong></p>\n<p>![image-20220626211117177](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626211117177.png)</p>\n<p>any Animal 跟 some Animal 是不同的，但是编译器可以通过“拆包”基本类型值的方式将 any Animal 的实例转换为 some Animal，并且把它直接传给 some Animal 参数。</p>\n<p><strong>这个“拆包”实参的能力是 Swift 5. 7 新增的。</strong></p>\n<p>![image-20220626211430157](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626211430157.png)</p>\n<p>你可以把拆包看作是编译器打开了盒子并取出了存在其中的值。</p>\n<p>some Animal 参数的使用范围内，这个值都有一个固定的基本类型。所以我们可以访问所有对基本类型的操作，包括访问关联类型。</p>\n<p>这真的很酷，因为它允许我们在需要的时候选择灵活的存储(即类型擦除，装进盒子里)，同时也可以回到之前的拥有函数体内可使用范围的固定基本类型的静态类型系统完整表达的上下文。</p>\n<p>大多数情况下，你并不需要去考虑拆包，因为它就是按照你期待的方式工作的，与对 any Animal 调用协议方法类似，就是对基本类型调用这个方法。</p>\n<p>所以我们可以对每个动物都调用 feed(animal:) 方法，在那里，每次遍历我们都可以种植并且收割合适的庄稼来喂养具体的动物。</p>\n<p>![image-20220626215127833](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626215127833.png)</p>\n<p>在这个过程中，我们看到了 some 和 any 不同的能力。</p>\n<p>使用 some，基本类型就是固定的，这允许你在泛型代码中依赖于固定的基本类型之间的关系，所以你有对 API 和协议关联类型的完整的访问权限。</p>\n<p>使用 any，当你需要存储任意实体类型时，any 提供了类型擦除，允许你表达异源集合，表达基本类型的缺席，使用可选项，同时抽象实现细节。</p>\n<p>![image-20220626215828321](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626215828321.png)</p>\n<p>总而言之，默认情况下使用 some，当你想要存储任意类型的值时，将 some 改为 any。</p>\n<p>使用这种方式，只在你需要存储灵活性时，付出类型擦除和语义限制的代价即可。</p>\n<p>这个工作流程与默认书写 let 表示常量，直到你需要变量时类似。</p>\n<p>在这个视频中，我们想要通过这个工作流程随着代码的演进来生成代码并且获得更多的功能。</p>\n<p>我们从实体类型开始，随着代码获得更多的功能，我们发觉在不同的类型中的代码重复。从这里开始，我们确定了通用的能力，并且使用协议生成了这些能力，最后我们用 some 和 any 写了抽象代码，并且讨论了我们倾向于使用 some 来书写更具有表达性的代码。</p>\n<p>想要更深入的构建协议和理解类型擦除，可以看 110353。</p>\n<p>![image-20220626220750663](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220626220750663.png)</p>\n"},{"_content":"# WWDC 22 - 110353 设计 Swift 协议接口 直译\n\n我将会为你展示一些使用协议抽象实体类型和模型化类型关系的高级技巧， 这个视频会涉及到已经存在的语言特性与 Swift 5.7 引入的新的能力。\n\n这个视频有三个主题：\n\n首先，我将通过解释返回值类型擦除的例子来为你展示协议和关联类型与 any 的共同使用。\n\n![image-20220629164630483](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629164630483.png)\n\n接下来，我将通过隔离接口与实现来解释返回值使用不透明类型的进一步优化封装。\n\n![image-20220629164839506](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629164839506.png)\n\n最后一点，你将看到协议中相同类型的必要条件是如何模型化多种不同实体类型的关系的。\n\n![image-20220629165151452](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629165151452.png)\n\n\n\n首先让我们从学习协议和关联类型是如何与 any 共同作用的。\n\n这里，我们有一个包含多个协议和四个实体类型的数据模型。这里有两种动物，鸡和奶牛，和两种食物，鸡蛋和牛奶。\n\n![image-20220629165311725](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629165311725.png)\n\n鸡下蛋，奶牛产奶。\n\n![image-20220629165456814](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629165456814.png)\n\n为了抽象食物的产出，我为 Animal 协议添加了一个 produce() 方法。\n\n![image-20220629165620924](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629165620924.png)\n\n你应该还记得上一个视频中，对不同返回值类型进行抽象(如对奶牛和鸡分别调用 produce() 方法)的最佳方法是使用一个关联类型。\n\n通过使用关联类型，我们进行如下声明：\n\n给 Animal 声明一些实体类型，调用 produce() 方法返回某个具体的 Food 类型，是依赖于对应的 Animal 实体类型的。\n\n我们可以用一张图来表示这种关系。\n\n![image-20220629171008403](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629171008403.png)\n\n 协议中的 self 代表一个遵循 Animal 协议的真实的实体类型，self 类型有一个关联类型：CommodityType，这个类型遵循 Food 协议。\n\n让我们来看看奶牛和鸡这些实体类型与图中 Animal 协议的关联类型的关系。\n\n鸡类型遵循 Animal 协议，同时其 CommodityType 的类型为 Egg。\n\n![image-20220629171528411](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629171528411.png)\n\n而奶牛类型遵循 Animal 协议，其 CommodityType 为 Milk。\n\n![image-20220629171619514](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629171619514.png)\n\n现在我们可以说我们的农场里有好多种动物，animals 存储属性是一个元素为异源 any Animal 类型的数组。\n\n![image-20220629171725309](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629171725309.png)\n\n在上个视频中，我们看到了 any Animal 类型是如何拥有一个盒子而有能力动态存储任何实体动物类型的。为不同的实体类型使用相同的表达形式的策略叫做类型擦除。\n\nproduceCommodities() 方法遍历了 animals 数组并对每一个 animal 调用了 produce() 方法。\n\n这个方法看起来很简单，但是我们知道类型擦除会将动物的基本类型之间的静态关系消除掉，所以这值得我们深入了解一下，为什么会有这样的代码检查。\n\nmap 闭包中的 animal 实例的类型是 any Animal。\n\n![image-20220629172625634](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629172625634.png)\n\n而 produce() 方法返回值的类型是一个关联类型。\n\n![image-20220629172716930](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629172716930.png)\n\n当你调用一个方法，其返回值是一个存在主义类型实例的关联类型时，编译器会使用类型擦除来决定这次调用的返回值类型。\n\n![image-20220629172841153](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629172841153.png)\n\n类型擦除取代了这些关联类型和相关的存在主义类型，有相同的限制。\n\n![image-20220629173021458](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629173021458.png)\n\n我们通过使用 any Animal 和 any Food 擦除了 Animal 实体类型与关联类型 CommodityType 的关系。\n\nany Food 的类型被叫做关联类型 CommodityType 的上层限制。(upper bound)\n\n既然 produce() 方法是被 any Animal 调用的，而返回值类型又被擦除了，返回给我们的就是一个 any Food 的返回值类型，这恰恰是我们所期待的类型。\n\n![image-20220629174005511](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629174005511.png)\n\n让我们仔细看看 Swift 5.7 中的新特性关联类型的擦除是如何工作的。关联类型出现在协议方法返回值类型的位置，即在方法声明中箭头的右边被叫做“产出位置”，因为调用这个方法将会得出一个该类型的值。\n\n![image-20220629174027749](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629174027749.png)\n\n当我们对 any Animal 调用这个方法时，我们在编译时是不知道返回值的实体类型的，但是我们知道它是“上层限制”的某个子类。\n\n![image-20220629174451155](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629174451155.png)\n\n这里是一个示例，我们对 any Animal 调用 produce() 方法，在运行时，这个数组中只有一个 Cow() 实例，在这种情况下，produce() 方法返回值的类型是 Milk，Milk 是可以被存储在 any Food 中的，它是在 Animal 协议中被定义的关联类型 CommodityType 的“上层限制”。\n\n![image-20220629174755209](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629174755209.png)\n\n这在遵循 Animal 协议的实体类型中总是安全的。\n\n![image-20220629175017570](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629175017570.png)\n\n\n\n让我们考虑一下如果关联类型出现在方法的参数列表或者是构造器中在会发生什么吧。\n\n这里，Animal 协议中的 eat(:) 方法有一个关联类型 FeedType 在“消费位置”，我们调用这个方法的时候需要传递一个 FeedType 的值进去。因为转变(类型的确定)是在方法外部做的，这样就无法执行类型擦除了。\n\n![image-20220629175125068](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629175125068.png)\n\n关联类型的上层限制存在主义类型并不能安全地将其转换为真实的实体类型，因为实体类型是未知的。\n\n![image-20220630090442475](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630090442475.png)\n\n让我们来看一个例子，我们再一次用 any Animal 存储一个 Cow 实例。\n\n![image-20220630090754140](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630090754140.png)\n\n假设 Cow 的 eat(:)  方法传入的参数类型为 Hay，Animal 协议 FeedType 关联类型的上层限制是 any AnimalFeed。\n\n![image-20220630090825995](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630090825995.png)\n\n但是传入任意的 any AnimalFeed，就没有办法静态保证是 Hay 这个实体类型的实例了。\n\n![image-20220630091131974](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630091131974.png)\n\n类型擦除并不允许我们将关联类型作为参数放在消费位置使用的。\n\n取而代之的是，你必须通过将 any 类型的存在主义类型传给一个接收 some 不透明类型作为参数的函数进行拆包。\n\n有关联类型的类型擦除行为与 Swift 5.6 中已经存在的语言特性类似，考虑一个拷贝引用类型的协议，这个协议定义了一个 clone() 方法，返回值类型为 Self。\n\n![image-20220630091555660](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630091555660.png)\n\n当你对一个 any Cloneable 类型的实例调用 clone() 方法时，返回值类型 Self 就被弃上层限制擦除类型了。\n\n![image-20220630091709706](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630091709706.png)\n\nSelf 类型的上层限制总是协议本身，所以我们得到了一个新的 any Cloneable 类型的实例。\n\n![image-20220630091851919](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630091851919.png)\n\n所以总结一下，你可以使用 any 去声明一个存储了遵循某个协议的实体类型的存在主义类型的值，甚至可以是有关联类型的协议。\n\n当调用一个关联类型在产出位置的协议方法时，关联类型被类型擦除为其上层限制，是另一个存在主义类型，携带了关联类型的限制(我的理解是关系，比如 Milk 和 Cow 的关系)。\n\n![image-20220630092431718](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630092431718.png)\n\n\n\n抽象实体类型并不只是针对函数的输入，也可以用作函数输出，所以实体类型仅在函数实现中才能被看到。\n\n让我们看看如何将返回值位置的实体类型抽象出来，通过将必要的接口与实现细节隔离开来。使静态类型的赋值在发生变化时能够更加模块化与健壮。\n\n让我们笼统地认为动物都需要喂食。动物会饿，当它们饿的时候就需要进食。让我们添加一个 isHungry 属性给 Animal 协议。\n\n![image-20220630093842665](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630093842665.png)\n\nFarm 的 feedAnimals() 方法将会对饿了的动物进行喂食。我用 filter() 方法将饥饿的动物通过 isHungry 属性过滤出来并存在计算属性 hungryAnimals 中。对 any Animal 类型的数组元素调用 filter() 将会返回一个新的 any Animal 类型的数组。\n\n你可能注意到了 feedAnimals() 方法只对 hungryAnimals 遍历了一遍过后，就立刻忽略掉这个临时的数组了，如果农场有大量饥饿的动物的话，这是非常低效的。\n\n![image-20220630094032753](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630094032753.png)\n\n一种避免这种临时内存空间分配的方式是使用标准库中的懒加载集合特性。通过将 filter 替换为 lazy.filter，我们就能得到懒加载的集合了。懒加载集合与数组返回的元素是相同的，就是直白的调用了 filter，但是它可以避免临时内存空间的分配。\n\n然而，hungryAnimals 属性的类型声明就要比它本来的实体类型复杂了：遵循 LazyFilterSequence 协议的由 any Animal 类型元素组成的数组。\n\n这里暴露了许多不必要的实现细节。feedAnimals() 方法这个客户并不关心我们在 hungryAnimals 的实现中使用了 lazy.filter。\n\n![image-20220630094835199](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630094835199.png)\n\n它只需要知道它获取到的是一个可以遍历的集合就够了。\n\n可以使用一个不透明的返回值类型来隐藏抽象接口背后的复杂的实体类型集合。\n\n![image-20220630095819276](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630095819276.png)\n\n现在，客户调用 hungryAnimals 时只知道它们可以得到某个遵循 Collection 协议的实体类型，但是并不知道集合具体的实体类型是什么。\n\n然而，就像写着的那样，这样确实对客户隐藏了太多静态类型的信息。我们声明了 hungryAnimals 会输出某个遵循 Collection 协议的实体类型，但是我们对这个集合的元素类型一无所知。如果不知道这个集合的元素类型是 any Animal，我们对这个元素类型所能做的就只有将其进行传递，我们不能调用 Animal 协议中的任何方法，让我们把焦点放在遵循 Collection 协议的不透明类型的返回值上面吧。\n\n![image-20220630100218811](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630100218811.png)\n\n我们可以通过使用一个限制的不透明返回值类型来协调隐藏实现细节与暴露足够丰富的接口之间的平衡。\n\n限制的不透明返回值类型是 Swift 5.7 新增的特性。\n\n![image-20220630112236985](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630112236985.png)\n\n一个限制的不透明返回值类型是通过在协议之后提供尖括号包裹的类型参数声明的。\n\nCollection 协议有一个单一的类型参数，即元素的类型。\n\n现在，一旦 hungryAnimals 的声明是一个限制的不透明返回值类型，它是一个遵循 LazyFilterSequence 协议的元素为 any Animal 类型的数组这个事实就被隐藏起来不被客户看到了，但客户仍然知道它是某个遵循 Collection 协议的实体类型，且其元素的关联类型等价于 any Animal，这才是我们真正想要的接口。\n\n![image-20220630112538737](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630112538737.png)\n\n在 feedAnimals() 的 for 循环中，animal 变量的的类型是 any Animal，这就允许每个 hungryAnimal 都可以调用 Animal 协议中的方法。\n\n![image-20220630113056298](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630113056298.png)\n\n这都是因为 Collection 协议声明了 Element 这个主要的关联类型，所以才能行得通的。你也可以像这样通过在协议名之后命名一个或多个尖括号包裹的关联类型来声明你自己的拥有主要关联类型的协议。\n\n![image-20220630113349346](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630113349346.png)\n\n关联类型作为主要的关联类型总是被调用者提供，例如集合的 Element 类型，与之相对的是实现细节，就像是集合的迭代类型。\n\n你总是可以看到协议的主要关联类型与泛型的类型参数传入的实体类型之间的相关(相似)性。这里，你可以看到 Collection 协议的主要关联类型 Element 被 Element 泛型参数 Array 和 Set 实现了，这两个实体类型定义在标准库中，都遵循了 Collection 协议。\n\n![image-20220630113748370](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630113748370.png)\n\nCollection\\<Element\\> 可以通过 some 关键字的修饰被用作不透明的返回值类型。\n\n![image-20220630115019329](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630115019329.png)\n\n同样也可以通过 any 关键字的修饰被用作限制的存在主义类型。\n\n![image-20220630115034795](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630115034795.png)\n\n在 Swift 5.7 之前，你并不需要写自己的数据类型来代表一个有具体泛型参数的存在主义类型。Swift 5.7 引入限制的存在主义类型这个概念。\n\n如果我们希望 hungryAnimals 的计算拥有懒加载或是立刻加载(eagerly)的选择权，使用一个不透明的元素类型为 any Animal 的 Collection 会发生编译错误，因为返回了两个不同基本类型的值。\n\n![image-20220630130306325](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630130306325.png)\n\n![image-20220630130357415](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630130357415.png)\n\n我们可以用 any 替换 some，返回遵循 any Animal 协议的 any Collection 类型，提示这个 API 被调用时可以返回不同类型的值。\n\n![image-20220630130545010](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630130545010.png)\n\n限制主要关联类型的能力给不透明类型和存在主义类型提供了更多的表达能力，这个能力可以用在多种标准库协议中，例如 Collection，你也可以声明你自己的带有主要关联类型的协议。\n\n使用不透明类型编写泛型代码必须依赖于抽象类型之间的关系，让我们来探讨一下如何确定并保证使用相关联协议的多个抽象类型之间的必要关系。\n\n我们要给 Animal 协议新增一个关联类型 AnimalFeed 实体类型(动物进食的食物类型)，同时新增一个eat(:) 方法来告诉动物可以消费这种类型的食物。\n\n![image-20220630131309999](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630131309999.png)\n\n为了让事情变得更有趣，我将要介绍一个额外的复杂功能。在我们给动物喂食之前，我们必须种植合适的庄稼，并且收获庄稼产出的食物。这是第一部分实体类：\n\n![image-20220630131748293](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630131748293.png)\n\nCow 吃 Hay，所以我们首先需要种一些 Hay，这样可以得到 Alfalfa，它能够产出 Hay，这种 Cow 能吃的食物。\n\n这里是第二部分实体类：\n\n![image-20220630132014917](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630132014917.png)\n\nChicken 吃 Scratch，所以我们首先种一些 Millet，可以产出 Scratch，然后喂给 Chicken。\n\n我想将这两种相关的实体类型抽象出来，所以我可以实现一次 feedAnimal(:) 方法，就能同时喂养 Cow 和 Chicken，以及我之后可能会喂养的新的动物。\n\n![image-20220630133327284](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630133327284.png)\n\n因为 feedAnimal(:) 方法需要与 Animal 协议中的 eat(:) 方法共同作用，它在消费位置有一个关联类型，我将通过声明参数类型为 some Animal 的 feedAnimal(:) 方法来对存在主义类型进行拆包。\n\n开始之前，我先用我们目前对协议和关联类型所知的内容声明几个协议 AnimalFeed 和 Crop。\n\nAnimalFeed 有一个关联类型 CropType，它遵循 Crop 协议。Crop 有一个关联类型遵循 AnimalFeed。\n\n![image-20220630133922382](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630133922382.png)\n\n像之前那样，我们先看一组协议类型参数的图。\n\n我们先看 AnimalFeed，每个协议都有一个类型 Self，代表遵循协议的实体类型。\n\n![image-20220630134329982](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630134329982.png)\n\n我们的协议有一个关联类型 CropType，遵循 Crop 协议。\n\n![image-20220630134542175](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630134542175.png)\n\n关联类型 CropType 有一个内嵌的关联类型 FeedType，遵循 AnimalFeed 协议，这个 AnimalFeed 也有一个内嵌的关联类型 CropType，遵循 Crop 协议，循环往复，关联类型在 AnimalFeed 与 Crop 之间互相遵循，不断切换，无限嵌套。\n\n![image-20220630134846558](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630134846558.png)\n\n对于 Crop 协议也是相同的情况，从遵循 Crop 协议的 Self 类型开始，有一个遵循 AnimalFeed 协议的关联类型 FeedType，这个关联类型有一个内嵌的关联类型 CropType，无限嵌套。\n\n让我们看看这些协议是否正确地模型化了实体类型之间的关系。回想一下在喂养动物之前，我们需要种植庄稼，然后会产出正确的动物要进食的食物。grow() 是 AnimalFeed 协议中的一个静态方法，这意味着它必须被遵循 AnimalFeed 协议的类型直接调用，而不是遵循 AnimalFeed 协议的具体类型的实例对象值。我们需要写下遵循 AnimalFeed 协议的类型的名称，但是我们有的只是一个遵循 Animal 协议的某个具体的类型，与 AnimalFeed 是不同的协议。\n\n我们可以用 type(of:) 方法得到 animal 实例的类型，我们知道它一定是遵循 Animal 协议的某个类型，Animal 有一个关联类型 FeedType，它遵循 AnimalFeed 协议。这个类可以被作为调用 grow() 方法的基本类型。\n\nAnimalFeed 协议的 grow() 方法返回一个值，这个值的类型是 AnimalFeed 的嵌套关联类型 CropType。我们知道 CropType 是遵循 Crop 协议的，所以可以对 CropType 的实例调用 harvest() 方法，但是我会得到什么呢？\n\nharvest() 被声明为返回一个遵循 Crop 协议的 FeedType 的关联类型。\n\n在我们的例子中，因为调用是基于 (some Animal).FeedType.CropType 的，harvest() 方法会输出一个 (some Animal).FeedType.CropType.FeedType。\n\n不幸的是，这是错误的类型。\n\n对 some Animal 调用 eat() 方法期待的返回值类型是 (some Animal).FeedType，而不是 (some Animal).FeedType.CropType.FeedType。\n\n![image-20220630143840680](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630143840680.png)\n\n这个程序类型是有问题的。\n\n![image-20220630163559858](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630163559858.png)\n\n这些协议的定义，并没有真实地保证如果我们从 AnimalFeed 类型开始，然后调用 grow() 和 harvest()，我们会得到与 AnimalFeed 开始时相同的类型，也就是我们所期待的动物进食食物的类型。\n\n另一种理解它的方式是，这些协议的定义太宽泛了，它们并没有准确地模型化我们对这些实体类型之间关系的期望，为了理解这是为什么，我们看一下 Hay 和 Alfalfa 类型。\n\n当我种下 Hay，可以得到 Alfalfa，当我收获 Alfalfa，可以得到 Hay。\n\n现在想象一下我重构这部分代码，我不小心修改了 Alfalfa 的 harvest() 方法的返回值类型，返回 Scratch 而不是 Hay。\n\n![IMG_2469](/Users/yanqizhao/Downloads/IMG_2469.JPG)\n\n被我不小心改掉之后，实体类型仍然满足 AnimalFeed 和 Crop 协议的要求，尽管我们违背了不改变 grow() 和 harvest() 方法返回值类型 crop 的初衷。\n\n让我们再看一次 AnimalFeed 这个协议，真正的问题是我们定义了太多不同的关联类型了。\n\n![IMG_2470](/Users/yanqizhao/Downloads/IMG_2470.JPG)\n\n我们需要写下这两种关联类型，它们是两种相同的实体类型，这将避免遵循协议时错误的实体类型。\n\n它也可以给 feedAnimal() 方法它所需要的值。\n\n我们可以使用一个相同类型要求的 where 语句来表达这两种关联类型的关系。\n\n一个相同类型的要求表达了两个不同的，可能是嵌套的关联类型，一定是相同的实体类型这样一个静态的保证。\n\n添加一个相同类型的要求采用了一个遵循 AnimalFeed 协议的实体类型的限制。\n\n![IMG_2471](/Users/yanqizhao/Downloads/IMG_2471.JPG)\n\n在这个相同类型要求里，我们声明了 Self.CropType.FeedType = Self，在图里看起来是什么样子呢，我们可以对其进行可视化。\n\n每个遵循 AnimalFeed 协议的实体类型都有一个遵循 Crop 的 CropType，然而这个 CropType 的 FeedType 并不是其他任何一个遵循 AnimalFeed 的类型，而是与之前相同的 AnimalFeed 类型。\n\n不在使用一个无穷的嵌套关联类型塔，取而代之的是，我把这些关系折叠为一对相关的关联类型。\n\n![IMG_2472](/Users/yanqizhao/Downloads/IMG_2472.JPG)那 Crop 协议怎么办，这里，Crop 的 FeedType 也折叠到一对类型里，但我们仍然多了一个关联类型。\n\n![IMG_2473](/Users/yanqizhao/Downloads/IMG_2473.JPG)\n\n我们想说，Crop 的 FeedType 的 CropType 也与开始的 Crop 相同。\n\n![IMG_2474](/Users/yanqizhao/Downloads/IMG_2474.JPG)\n\n现在这两个协议都配备了相同类型的要求，我们可以重新调用一次 feedAnimal() 方法了。\n\n![IMG_2475](/Users/yanqizhao/Downloads/IMG_2475.JPG)\n\n我们还是从 some Animal 开始，然后我们得到了 some Animal 的 FeedType，我们知道 FeedType 遵循 AnimalFeed 协议。\n\n当我们种下这种 Crop，我们得到了 some Animal 的 FeedType 的 CropType，但是现在，当我们收获这种 Crop 的时候，我们得到的不是到现在为止仍然是另一个嵌套的关联类型，取而代之的是，我们得到的恰恰是我们这个 Animal 对象所期待的 FeedType。\n\n现在这个快乐的 Animal 可以确保吃到正确的 AnimalFeed，就是我们刚刚种下的。\n\n最后，让我们看看 Animal 协议的关联类型图，它将我们目前看到的内容放在了一起。\n\n这是两部分协议遵循的实体类型：\n\n![IMG_2476](/Users/yanqizhao/Downloads/IMG_2476.JPG)\n\n首先我们有 Cow、Hay、Alfalfa，然后我们有 Chicken、Scratch、Millet，注意我们有三个协议精确地模型化了每部分的三个实体类型的关系。\n\n为了理解这些数据模型，你可以使用相同类型的要求来定义这些不同的嵌套关联类型的等价性。\n\n当泛型代码链接多个协议要求的调用时可以依赖这些关系。\n\n在这个视频中，我们探索了类型擦除何时才是安全的，以及类型关系的确保何时需要处在同一上下文中。\n\n然后我们讨论了如何使用既能用作不透明类型又能用作存在主义类型的主要关联类型做到保持丰富的类型信息与隐藏实现细节的平衡。\n\n最后，我们看到了使用代表类型之间关系的协议表达，如何确定并且确保相同类型要求的实体类型之间的关系。","source":"_drafts/WWDC 22 - 110353 设计 Swift 协议接口 直译.md","raw":"# WWDC 22 - 110353 设计 Swift 协议接口 直译\n\n我将会为你展示一些使用协议抽象实体类型和模型化类型关系的高级技巧， 这个视频会涉及到已经存在的语言特性与 Swift 5.7 引入的新的能力。\n\n这个视频有三个主题：\n\n首先，我将通过解释返回值类型擦除的例子来为你展示协议和关联类型与 any 的共同使用。\n\n![image-20220629164630483](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629164630483.png)\n\n接下来，我将通过隔离接口与实现来解释返回值使用不透明类型的进一步优化封装。\n\n![image-20220629164839506](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629164839506.png)\n\n最后一点，你将看到协议中相同类型的必要条件是如何模型化多种不同实体类型的关系的。\n\n![image-20220629165151452](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629165151452.png)\n\n\n\n首先让我们从学习协议和关联类型是如何与 any 共同作用的。\n\n这里，我们有一个包含多个协议和四个实体类型的数据模型。这里有两种动物，鸡和奶牛，和两种食物，鸡蛋和牛奶。\n\n![image-20220629165311725](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629165311725.png)\n\n鸡下蛋，奶牛产奶。\n\n![image-20220629165456814](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629165456814.png)\n\n为了抽象食物的产出，我为 Animal 协议添加了一个 produce() 方法。\n\n![image-20220629165620924](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629165620924.png)\n\n你应该还记得上一个视频中，对不同返回值类型进行抽象(如对奶牛和鸡分别调用 produce() 方法)的最佳方法是使用一个关联类型。\n\n通过使用关联类型，我们进行如下声明：\n\n给 Animal 声明一些实体类型，调用 produce() 方法返回某个具体的 Food 类型，是依赖于对应的 Animal 实体类型的。\n\n我们可以用一张图来表示这种关系。\n\n![image-20220629171008403](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629171008403.png)\n\n 协议中的 self 代表一个遵循 Animal 协议的真实的实体类型，self 类型有一个关联类型：CommodityType，这个类型遵循 Food 协议。\n\n让我们来看看奶牛和鸡这些实体类型与图中 Animal 协议的关联类型的关系。\n\n鸡类型遵循 Animal 协议，同时其 CommodityType 的类型为 Egg。\n\n![image-20220629171528411](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629171528411.png)\n\n而奶牛类型遵循 Animal 协议，其 CommodityType 为 Milk。\n\n![image-20220629171619514](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629171619514.png)\n\n现在我们可以说我们的农场里有好多种动物，animals 存储属性是一个元素为异源 any Animal 类型的数组。\n\n![image-20220629171725309](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629171725309.png)\n\n在上个视频中，我们看到了 any Animal 类型是如何拥有一个盒子而有能力动态存储任何实体动物类型的。为不同的实体类型使用相同的表达形式的策略叫做类型擦除。\n\nproduceCommodities() 方法遍历了 animals 数组并对每一个 animal 调用了 produce() 方法。\n\n这个方法看起来很简单，但是我们知道类型擦除会将动物的基本类型之间的静态关系消除掉，所以这值得我们深入了解一下，为什么会有这样的代码检查。\n\nmap 闭包中的 animal 实例的类型是 any Animal。\n\n![image-20220629172625634](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629172625634.png)\n\n而 produce() 方法返回值的类型是一个关联类型。\n\n![image-20220629172716930](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629172716930.png)\n\n当你调用一个方法，其返回值是一个存在主义类型实例的关联类型时，编译器会使用类型擦除来决定这次调用的返回值类型。\n\n![image-20220629172841153](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629172841153.png)\n\n类型擦除取代了这些关联类型和相关的存在主义类型，有相同的限制。\n\n![image-20220629173021458](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629173021458.png)\n\n我们通过使用 any Animal 和 any Food 擦除了 Animal 实体类型与关联类型 CommodityType 的关系。\n\nany Food 的类型被叫做关联类型 CommodityType 的上层限制。(upper bound)\n\n既然 produce() 方法是被 any Animal 调用的，而返回值类型又被擦除了，返回给我们的就是一个 any Food 的返回值类型，这恰恰是我们所期待的类型。\n\n![image-20220629174005511](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629174005511.png)\n\n让我们仔细看看 Swift 5.7 中的新特性关联类型的擦除是如何工作的。关联类型出现在协议方法返回值类型的位置，即在方法声明中箭头的右边被叫做“产出位置”，因为调用这个方法将会得出一个该类型的值。\n\n![image-20220629174027749](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629174027749.png)\n\n当我们对 any Animal 调用这个方法时，我们在编译时是不知道返回值的实体类型的，但是我们知道它是“上层限制”的某个子类。\n\n![image-20220629174451155](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629174451155.png)\n\n这里是一个示例，我们对 any Animal 调用 produce() 方法，在运行时，这个数组中只有一个 Cow() 实例，在这种情况下，produce() 方法返回值的类型是 Milk，Milk 是可以被存储在 any Food 中的，它是在 Animal 协议中被定义的关联类型 CommodityType 的“上层限制”。\n\n![image-20220629174755209](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629174755209.png)\n\n这在遵循 Animal 协议的实体类型中总是安全的。\n\n![image-20220629175017570](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629175017570.png)\n\n\n\n让我们考虑一下如果关联类型出现在方法的参数列表或者是构造器中在会发生什么吧。\n\n这里，Animal 协议中的 eat(:) 方法有一个关联类型 FeedType 在“消费位置”，我们调用这个方法的时候需要传递一个 FeedType 的值进去。因为转变(类型的确定)是在方法外部做的，这样就无法执行类型擦除了。\n\n![image-20220629175125068](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629175125068.png)\n\n关联类型的上层限制存在主义类型并不能安全地将其转换为真实的实体类型，因为实体类型是未知的。\n\n![image-20220630090442475](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630090442475.png)\n\n让我们来看一个例子，我们再一次用 any Animal 存储一个 Cow 实例。\n\n![image-20220630090754140](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630090754140.png)\n\n假设 Cow 的 eat(:)  方法传入的参数类型为 Hay，Animal 协议 FeedType 关联类型的上层限制是 any AnimalFeed。\n\n![image-20220630090825995](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630090825995.png)\n\n但是传入任意的 any AnimalFeed，就没有办法静态保证是 Hay 这个实体类型的实例了。\n\n![image-20220630091131974](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630091131974.png)\n\n类型擦除并不允许我们将关联类型作为参数放在消费位置使用的。\n\n取而代之的是，你必须通过将 any 类型的存在主义类型传给一个接收 some 不透明类型作为参数的函数进行拆包。\n\n有关联类型的类型擦除行为与 Swift 5.6 中已经存在的语言特性类似，考虑一个拷贝引用类型的协议，这个协议定义了一个 clone() 方法，返回值类型为 Self。\n\n![image-20220630091555660](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630091555660.png)\n\n当你对一个 any Cloneable 类型的实例调用 clone() 方法时，返回值类型 Self 就被弃上层限制擦除类型了。\n\n![image-20220630091709706](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630091709706.png)\n\nSelf 类型的上层限制总是协议本身，所以我们得到了一个新的 any Cloneable 类型的实例。\n\n![image-20220630091851919](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630091851919.png)\n\n所以总结一下，你可以使用 any 去声明一个存储了遵循某个协议的实体类型的存在主义类型的值，甚至可以是有关联类型的协议。\n\n当调用一个关联类型在产出位置的协议方法时，关联类型被类型擦除为其上层限制，是另一个存在主义类型，携带了关联类型的限制(我的理解是关系，比如 Milk 和 Cow 的关系)。\n\n![image-20220630092431718](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630092431718.png)\n\n\n\n抽象实体类型并不只是针对函数的输入，也可以用作函数输出，所以实体类型仅在函数实现中才能被看到。\n\n让我们看看如何将返回值位置的实体类型抽象出来，通过将必要的接口与实现细节隔离开来。使静态类型的赋值在发生变化时能够更加模块化与健壮。\n\n让我们笼统地认为动物都需要喂食。动物会饿，当它们饿的时候就需要进食。让我们添加一个 isHungry 属性给 Animal 协议。\n\n![image-20220630093842665](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630093842665.png)\n\nFarm 的 feedAnimals() 方法将会对饿了的动物进行喂食。我用 filter() 方法将饥饿的动物通过 isHungry 属性过滤出来并存在计算属性 hungryAnimals 中。对 any Animal 类型的数组元素调用 filter() 将会返回一个新的 any Animal 类型的数组。\n\n你可能注意到了 feedAnimals() 方法只对 hungryAnimals 遍历了一遍过后，就立刻忽略掉这个临时的数组了，如果农场有大量饥饿的动物的话，这是非常低效的。\n\n![image-20220630094032753](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630094032753.png)\n\n一种避免这种临时内存空间分配的方式是使用标准库中的懒加载集合特性。通过将 filter 替换为 lazy.filter，我们就能得到懒加载的集合了。懒加载集合与数组返回的元素是相同的，就是直白的调用了 filter，但是它可以避免临时内存空间的分配。\n\n然而，hungryAnimals 属性的类型声明就要比它本来的实体类型复杂了：遵循 LazyFilterSequence 协议的由 any Animal 类型元素组成的数组。\n\n这里暴露了许多不必要的实现细节。feedAnimals() 方法这个客户并不关心我们在 hungryAnimals 的实现中使用了 lazy.filter。\n\n![image-20220630094835199](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630094835199.png)\n\n它只需要知道它获取到的是一个可以遍历的集合就够了。\n\n可以使用一个不透明的返回值类型来隐藏抽象接口背后的复杂的实体类型集合。\n\n![image-20220630095819276](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630095819276.png)\n\n现在，客户调用 hungryAnimals 时只知道它们可以得到某个遵循 Collection 协议的实体类型，但是并不知道集合具体的实体类型是什么。\n\n然而，就像写着的那样，这样确实对客户隐藏了太多静态类型的信息。我们声明了 hungryAnimals 会输出某个遵循 Collection 协议的实体类型，但是我们对这个集合的元素类型一无所知。如果不知道这个集合的元素类型是 any Animal，我们对这个元素类型所能做的就只有将其进行传递，我们不能调用 Animal 协议中的任何方法，让我们把焦点放在遵循 Collection 协议的不透明类型的返回值上面吧。\n\n![image-20220630100218811](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630100218811.png)\n\n我们可以通过使用一个限制的不透明返回值类型来协调隐藏实现细节与暴露足够丰富的接口之间的平衡。\n\n限制的不透明返回值类型是 Swift 5.7 新增的特性。\n\n![image-20220630112236985](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630112236985.png)\n\n一个限制的不透明返回值类型是通过在协议之后提供尖括号包裹的类型参数声明的。\n\nCollection 协议有一个单一的类型参数，即元素的类型。\n\n现在，一旦 hungryAnimals 的声明是一个限制的不透明返回值类型，它是一个遵循 LazyFilterSequence 协议的元素为 any Animal 类型的数组这个事实就被隐藏起来不被客户看到了，但客户仍然知道它是某个遵循 Collection 协议的实体类型，且其元素的关联类型等价于 any Animal，这才是我们真正想要的接口。\n\n![image-20220630112538737](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630112538737.png)\n\n在 feedAnimals() 的 for 循环中，animal 变量的的类型是 any Animal，这就允许每个 hungryAnimal 都可以调用 Animal 协议中的方法。\n\n![image-20220630113056298](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630113056298.png)\n\n这都是因为 Collection 协议声明了 Element 这个主要的关联类型，所以才能行得通的。你也可以像这样通过在协议名之后命名一个或多个尖括号包裹的关联类型来声明你自己的拥有主要关联类型的协议。\n\n![image-20220630113349346](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630113349346.png)\n\n关联类型作为主要的关联类型总是被调用者提供，例如集合的 Element 类型，与之相对的是实现细节，就像是集合的迭代类型。\n\n你总是可以看到协议的主要关联类型与泛型的类型参数传入的实体类型之间的相关(相似)性。这里，你可以看到 Collection 协议的主要关联类型 Element 被 Element 泛型参数 Array 和 Set 实现了，这两个实体类型定义在标准库中，都遵循了 Collection 协议。\n\n![image-20220630113748370](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630113748370.png)\n\nCollection\\<Element\\> 可以通过 some 关键字的修饰被用作不透明的返回值类型。\n\n![image-20220630115019329](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630115019329.png)\n\n同样也可以通过 any 关键字的修饰被用作限制的存在主义类型。\n\n![image-20220630115034795](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630115034795.png)\n\n在 Swift 5.7 之前，你并不需要写自己的数据类型来代表一个有具体泛型参数的存在主义类型。Swift 5.7 引入限制的存在主义类型这个概念。\n\n如果我们希望 hungryAnimals 的计算拥有懒加载或是立刻加载(eagerly)的选择权，使用一个不透明的元素类型为 any Animal 的 Collection 会发生编译错误，因为返回了两个不同基本类型的值。\n\n![image-20220630130306325](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630130306325.png)\n\n![image-20220630130357415](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630130357415.png)\n\n我们可以用 any 替换 some，返回遵循 any Animal 协议的 any Collection 类型，提示这个 API 被调用时可以返回不同类型的值。\n\n![image-20220630130545010](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630130545010.png)\n\n限制主要关联类型的能力给不透明类型和存在主义类型提供了更多的表达能力，这个能力可以用在多种标准库协议中，例如 Collection，你也可以声明你自己的带有主要关联类型的协议。\n\n使用不透明类型编写泛型代码必须依赖于抽象类型之间的关系，让我们来探讨一下如何确定并保证使用相关联协议的多个抽象类型之间的必要关系。\n\n我们要给 Animal 协议新增一个关联类型 AnimalFeed 实体类型(动物进食的食物类型)，同时新增一个eat(:) 方法来告诉动物可以消费这种类型的食物。\n\n![image-20220630131309999](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630131309999.png)\n\n为了让事情变得更有趣，我将要介绍一个额外的复杂功能。在我们给动物喂食之前，我们必须种植合适的庄稼，并且收获庄稼产出的食物。这是第一部分实体类：\n\n![image-20220630131748293](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630131748293.png)\n\nCow 吃 Hay，所以我们首先需要种一些 Hay，这样可以得到 Alfalfa，它能够产出 Hay，这种 Cow 能吃的食物。\n\n这里是第二部分实体类：\n\n![image-20220630132014917](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630132014917.png)\n\nChicken 吃 Scratch，所以我们首先种一些 Millet，可以产出 Scratch，然后喂给 Chicken。\n\n我想将这两种相关的实体类型抽象出来，所以我可以实现一次 feedAnimal(:) 方法，就能同时喂养 Cow 和 Chicken，以及我之后可能会喂养的新的动物。\n\n![image-20220630133327284](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630133327284.png)\n\n因为 feedAnimal(:) 方法需要与 Animal 协议中的 eat(:) 方法共同作用，它在消费位置有一个关联类型，我将通过声明参数类型为 some Animal 的 feedAnimal(:) 方法来对存在主义类型进行拆包。\n\n开始之前，我先用我们目前对协议和关联类型所知的内容声明几个协议 AnimalFeed 和 Crop。\n\nAnimalFeed 有一个关联类型 CropType，它遵循 Crop 协议。Crop 有一个关联类型遵循 AnimalFeed。\n\n![image-20220630133922382](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630133922382.png)\n\n像之前那样，我们先看一组协议类型参数的图。\n\n我们先看 AnimalFeed，每个协议都有一个类型 Self，代表遵循协议的实体类型。\n\n![image-20220630134329982](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630134329982.png)\n\n我们的协议有一个关联类型 CropType，遵循 Crop 协议。\n\n![image-20220630134542175](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630134542175.png)\n\n关联类型 CropType 有一个内嵌的关联类型 FeedType，遵循 AnimalFeed 协议，这个 AnimalFeed 也有一个内嵌的关联类型 CropType，遵循 Crop 协议，循环往复，关联类型在 AnimalFeed 与 Crop 之间互相遵循，不断切换，无限嵌套。\n\n![image-20220630134846558](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630134846558.png)\n\n对于 Crop 协议也是相同的情况，从遵循 Crop 协议的 Self 类型开始，有一个遵循 AnimalFeed 协议的关联类型 FeedType，这个关联类型有一个内嵌的关联类型 CropType，无限嵌套。\n\n让我们看看这些协议是否正确地模型化了实体类型之间的关系。回想一下在喂养动物之前，我们需要种植庄稼，然后会产出正确的动物要进食的食物。grow() 是 AnimalFeed 协议中的一个静态方法，这意味着它必须被遵循 AnimalFeed 协议的类型直接调用，而不是遵循 AnimalFeed 协议的具体类型的实例对象值。我们需要写下遵循 AnimalFeed 协议的类型的名称，但是我们有的只是一个遵循 Animal 协议的某个具体的类型，与 AnimalFeed 是不同的协议。\n\n我们可以用 type(of:) 方法得到 animal 实例的类型，我们知道它一定是遵循 Animal 协议的某个类型，Animal 有一个关联类型 FeedType，它遵循 AnimalFeed 协议。这个类可以被作为调用 grow() 方法的基本类型。\n\nAnimalFeed 协议的 grow() 方法返回一个值，这个值的类型是 AnimalFeed 的嵌套关联类型 CropType。我们知道 CropType 是遵循 Crop 协议的，所以可以对 CropType 的实例调用 harvest() 方法，但是我会得到什么呢？\n\nharvest() 被声明为返回一个遵循 Crop 协议的 FeedType 的关联类型。\n\n在我们的例子中，因为调用是基于 (some Animal).FeedType.CropType 的，harvest() 方法会输出一个 (some Animal).FeedType.CropType.FeedType。\n\n不幸的是，这是错误的类型。\n\n对 some Animal 调用 eat() 方法期待的返回值类型是 (some Animal).FeedType，而不是 (some Animal).FeedType.CropType.FeedType。\n\n![image-20220630143840680](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630143840680.png)\n\n这个程序类型是有问题的。\n\n![image-20220630163559858](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630163559858.png)\n\n这些协议的定义，并没有真实地保证如果我们从 AnimalFeed 类型开始，然后调用 grow() 和 harvest()，我们会得到与 AnimalFeed 开始时相同的类型，也就是我们所期待的动物进食食物的类型。\n\n另一种理解它的方式是，这些协议的定义太宽泛了，它们并没有准确地模型化我们对这些实体类型之间关系的期望，为了理解这是为什么，我们看一下 Hay 和 Alfalfa 类型。\n\n当我种下 Hay，可以得到 Alfalfa，当我收获 Alfalfa，可以得到 Hay。\n\n现在想象一下我重构这部分代码，我不小心修改了 Alfalfa 的 harvest() 方法的返回值类型，返回 Scratch 而不是 Hay。\n\n![IMG_2469](/Users/yanqizhao/Downloads/IMG_2469.JPG)\n\n被我不小心改掉之后，实体类型仍然满足 AnimalFeed 和 Crop 协议的要求，尽管我们违背了不改变 grow() 和 harvest() 方法返回值类型 crop 的初衷。\n\n让我们再看一次 AnimalFeed 这个协议，真正的问题是我们定义了太多不同的关联类型了。\n\n![IMG_2470](/Users/yanqizhao/Downloads/IMG_2470.JPG)\n\n我们需要写下这两种关联类型，它们是两种相同的实体类型，这将避免遵循协议时错误的实体类型。\n\n它也可以给 feedAnimal() 方法它所需要的值。\n\n我们可以使用一个相同类型要求的 where 语句来表达这两种关联类型的关系。\n\n一个相同类型的要求表达了两个不同的，可能是嵌套的关联类型，一定是相同的实体类型这样一个静态的保证。\n\n添加一个相同类型的要求采用了一个遵循 AnimalFeed 协议的实体类型的限制。\n\n![IMG_2471](/Users/yanqizhao/Downloads/IMG_2471.JPG)\n\n在这个相同类型要求里，我们声明了 Self.CropType.FeedType = Self，在图里看起来是什么样子呢，我们可以对其进行可视化。\n\n每个遵循 AnimalFeed 协议的实体类型都有一个遵循 Crop 的 CropType，然而这个 CropType 的 FeedType 并不是其他任何一个遵循 AnimalFeed 的类型，而是与之前相同的 AnimalFeed 类型。\n\n不在使用一个无穷的嵌套关联类型塔，取而代之的是，我把这些关系折叠为一对相关的关联类型。\n\n![IMG_2472](/Users/yanqizhao/Downloads/IMG_2472.JPG)那 Crop 协议怎么办，这里，Crop 的 FeedType 也折叠到一对类型里，但我们仍然多了一个关联类型。\n\n![IMG_2473](/Users/yanqizhao/Downloads/IMG_2473.JPG)\n\n我们想说，Crop 的 FeedType 的 CropType 也与开始的 Crop 相同。\n\n![IMG_2474](/Users/yanqizhao/Downloads/IMG_2474.JPG)\n\n现在这两个协议都配备了相同类型的要求，我们可以重新调用一次 feedAnimal() 方法了。\n\n![IMG_2475](/Users/yanqizhao/Downloads/IMG_2475.JPG)\n\n我们还是从 some Animal 开始，然后我们得到了 some Animal 的 FeedType，我们知道 FeedType 遵循 AnimalFeed 协议。\n\n当我们种下这种 Crop，我们得到了 some Animal 的 FeedType 的 CropType，但是现在，当我们收获这种 Crop 的时候，我们得到的不是到现在为止仍然是另一个嵌套的关联类型，取而代之的是，我们得到的恰恰是我们这个 Animal 对象所期待的 FeedType。\n\n现在这个快乐的 Animal 可以确保吃到正确的 AnimalFeed，就是我们刚刚种下的。\n\n最后，让我们看看 Animal 协议的关联类型图，它将我们目前看到的内容放在了一起。\n\n这是两部分协议遵循的实体类型：\n\n![IMG_2476](/Users/yanqizhao/Downloads/IMG_2476.JPG)\n\n首先我们有 Cow、Hay、Alfalfa，然后我们有 Chicken、Scratch、Millet，注意我们有三个协议精确地模型化了每部分的三个实体类型的关系。\n\n为了理解这些数据模型，你可以使用相同类型的要求来定义这些不同的嵌套关联类型的等价性。\n\n当泛型代码链接多个协议要求的调用时可以依赖这些关系。\n\n在这个视频中，我们探索了类型擦除何时才是安全的，以及类型关系的确保何时需要处在同一上下文中。\n\n然后我们讨论了如何使用既能用作不透明类型又能用作存在主义类型的主要关联类型做到保持丰富的类型信息与隐藏实现细节的平衡。\n\n最后，我们看到了使用代表类型之间关系的协议表达，如何确定并且确保相同类型要求的实体类型之间的关系。","slug":"WWDC 22 - 110353 设计 Swift 协议接口 直译","published":0,"date":"2022-07-01T06:22:31.271Z","updated":"2022-07-01T06:27:33.422Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ejwd850002o4dx0chm2eke","content":"<h1 id=\"WWDC-22-110353-设计-Swift-协议接口-直译\"><a href=\"#WWDC-22-110353-设计-Swift-协议接口-直译\" class=\"headerlink\" title=\"WWDC 22 - 110353 设计 Swift 协议接口 直译\"></a>WWDC 22 - 110353 设计 Swift 协议接口 直译</h1><p>我将会为你展示一些使用协议抽象实体类型和模型化类型关系的高级技巧， 这个视频会涉及到已经存在的语言特性与 Swift 5.7 引入的新的能力。</p>\n<p>这个视频有三个主题：</p>\n<p>首先，我将通过解释返回值类型擦除的例子来为你展示协议和关联类型与 any 的共同使用。</p>\n<p>![image-20220629164630483](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629164630483.png)</p>\n<p>接下来，我将通过隔离接口与实现来解释返回值使用不透明类型的进一步优化封装。</p>\n<p>![image-20220629164839506](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629164839506.png)</p>\n<p>最后一点，你将看到协议中相同类型的必要条件是如何模型化多种不同实体类型的关系的。</p>\n<p>![image-20220629165151452](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629165151452.png)</p>\n<p>首先让我们从学习协议和关联类型是如何与 any 共同作用的。</p>\n<p>这里，我们有一个包含多个协议和四个实体类型的数据模型。这里有两种动物，鸡和奶牛，和两种食物，鸡蛋和牛奶。</p>\n<p>![image-20220629165311725](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629165311725.png)</p>\n<p>鸡下蛋，奶牛产奶。</p>\n<p>![image-20220629165456814](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629165456814.png)</p>\n<p>为了抽象食物的产出，我为 Animal 协议添加了一个 produce() 方法。</p>\n<p>![image-20220629165620924](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629165620924.png)</p>\n<p>你应该还记得上一个视频中，对不同返回值类型进行抽象(如对奶牛和鸡分别调用 produce() 方法)的最佳方法是使用一个关联类型。</p>\n<p>通过使用关联类型，我们进行如下声明：</p>\n<p>给 Animal 声明一些实体类型，调用 produce() 方法返回某个具体的 Food 类型，是依赖于对应的 Animal 实体类型的。</p>\n<p>我们可以用一张图来表示这种关系。</p>\n<p>![image-20220629171008403](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629171008403.png)</p>\n<p> 协议中的 self 代表一个遵循 Animal 协议的真实的实体类型，self 类型有一个关联类型：CommodityType，这个类型遵循 Food 协议。</p>\n<p>让我们来看看奶牛和鸡这些实体类型与图中 Animal 协议的关联类型的关系。</p>\n<p>鸡类型遵循 Animal 协议，同时其 CommodityType 的类型为 Egg。</p>\n<p>![image-20220629171528411](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629171528411.png)</p>\n<p>而奶牛类型遵循 Animal 协议，其 CommodityType 为 Milk。</p>\n<p>![image-20220629171619514](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629171619514.png)</p>\n<p>现在我们可以说我们的农场里有好多种动物，animals 存储属性是一个元素为异源 any Animal 类型的数组。</p>\n<p>![image-20220629171725309](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629171725309.png)</p>\n<p>在上个视频中，我们看到了 any Animal 类型是如何拥有一个盒子而有能力动态存储任何实体动物类型的。为不同的实体类型使用相同的表达形式的策略叫做类型擦除。</p>\n<p>produceCommodities() 方法遍历了 animals 数组并对每一个 animal 调用了 produce() 方法。</p>\n<p>这个方法看起来很简单，但是我们知道类型擦除会将动物的基本类型之间的静态关系消除掉，所以这值得我们深入了解一下，为什么会有这样的代码检查。</p>\n<p>map 闭包中的 animal 实例的类型是 any Animal。</p>\n<p>![image-20220629172625634](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629172625634.png)</p>\n<p>而 produce() 方法返回值的类型是一个关联类型。</p>\n<p>![image-20220629172716930](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629172716930.png)</p>\n<p>当你调用一个方法，其返回值是一个存在主义类型实例的关联类型时，编译器会使用类型擦除来决定这次调用的返回值类型。</p>\n<p>![image-20220629172841153](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629172841153.png)</p>\n<p>类型擦除取代了这些关联类型和相关的存在主义类型，有相同的限制。</p>\n<p>![image-20220629173021458](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629173021458.png)</p>\n<p>我们通过使用 any Animal 和 any Food 擦除了 Animal 实体类型与关联类型 CommodityType 的关系。</p>\n<p>any Food 的类型被叫做关联类型 CommodityType 的上层限制。(upper bound)</p>\n<p>既然 produce() 方法是被 any Animal 调用的，而返回值类型又被擦除了，返回给我们的就是一个 any Food 的返回值类型，这恰恰是我们所期待的类型。</p>\n<p>![image-20220629174005511](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629174005511.png)</p>\n<p>让我们仔细看看 Swift 5.7 中的新特性关联类型的擦除是如何工作的。关联类型出现在协议方法返回值类型的位置，即在方法声明中箭头的右边被叫做“产出位置”，因为调用这个方法将会得出一个该类型的值。</p>\n<p>![image-20220629174027749](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629174027749.png)</p>\n<p>当我们对 any Animal 调用这个方法时，我们在编译时是不知道返回值的实体类型的，但是我们知道它是“上层限制”的某个子类。</p>\n<p>![image-20220629174451155](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629174451155.png)</p>\n<p>这里是一个示例，我们对 any Animal 调用 produce() 方法，在运行时，这个数组中只有一个 Cow() 实例，在这种情况下，produce() 方法返回值的类型是 Milk，Milk 是可以被存储在 any Food 中的，它是在 Animal 协议中被定义的关联类型 CommodityType 的“上层限制”。</p>\n<p>![image-20220629174755209](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629174755209.png)</p>\n<p>这在遵循 Animal 协议的实体类型中总是安全的。</p>\n<p>![image-20220629175017570](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629175017570.png)</p>\n<p>让我们考虑一下如果关联类型出现在方法的参数列表或者是构造器中在会发生什么吧。</p>\n<p>这里，Animal 协议中的 eat(:) 方法有一个关联类型 FeedType 在“消费位置”，我们调用这个方法的时候需要传递一个 FeedType 的值进去。因为转变(类型的确定)是在方法外部做的，这样就无法执行类型擦除了。</p>\n<p>![image-20220629175125068](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629175125068.png)</p>\n<p>关联类型的上层限制存在主义类型并不能安全地将其转换为真实的实体类型，因为实体类型是未知的。</p>\n<p>![image-20220630090442475](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630090442475.png)</p>\n<p>让我们来看一个例子，我们再一次用 any Animal 存储一个 Cow 实例。</p>\n<p>![image-20220630090754140](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630090754140.png)</p>\n<p>假设 Cow 的 eat(:)  方法传入的参数类型为 Hay，Animal 协议 FeedType 关联类型的上层限制是 any AnimalFeed。</p>\n<p>![image-20220630090825995](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630090825995.png)</p>\n<p>但是传入任意的 any AnimalFeed，就没有办法静态保证是 Hay 这个实体类型的实例了。</p>\n<p>![image-20220630091131974](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630091131974.png)</p>\n<p>类型擦除并不允许我们将关联类型作为参数放在消费位置使用的。</p>\n<p>取而代之的是，你必须通过将 any 类型的存在主义类型传给一个接收 some 不透明类型作为参数的函数进行拆包。</p>\n<p>有关联类型的类型擦除行为与 Swift 5.6 中已经存在的语言特性类似，考虑一个拷贝引用类型的协议，这个协议定义了一个 clone() 方法，返回值类型为 Self。</p>\n<p>![image-20220630091555660](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630091555660.png)</p>\n<p>当你对一个 any Cloneable 类型的实例调用 clone() 方法时，返回值类型 Self 就被弃上层限制擦除类型了。</p>\n<p>![image-20220630091709706](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630091709706.png)</p>\n<p>Self 类型的上层限制总是协议本身，所以我们得到了一个新的 any Cloneable 类型的实例。</p>\n<p>![image-20220630091851919](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630091851919.png)</p>\n<p>所以总结一下，你可以使用 any 去声明一个存储了遵循某个协议的实体类型的存在主义类型的值，甚至可以是有关联类型的协议。</p>\n<p>当调用一个关联类型在产出位置的协议方法时，关联类型被类型擦除为其上层限制，是另一个存在主义类型，携带了关联类型的限制(我的理解是关系，比如 Milk 和 Cow 的关系)。</p>\n<p>![image-20220630092431718](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630092431718.png)</p>\n<p>抽象实体类型并不只是针对函数的输入，也可以用作函数输出，所以实体类型仅在函数实现中才能被看到。</p>\n<p>让我们看看如何将返回值位置的实体类型抽象出来，通过将必要的接口与实现细节隔离开来。使静态类型的赋值在发生变化时能够更加模块化与健壮。</p>\n<p>让我们笼统地认为动物都需要喂食。动物会饿，当它们饿的时候就需要进食。让我们添加一个 isHungry 属性给 Animal 协议。</p>\n<p>![image-20220630093842665](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630093842665.png)</p>\n<p>Farm 的 feedAnimals() 方法将会对饿了的动物进行喂食。我用 filter() 方法将饥饿的动物通过 isHungry 属性过滤出来并存在计算属性 hungryAnimals 中。对 any Animal 类型的数组元素调用 filter() 将会返回一个新的 any Animal 类型的数组。</p>\n<p>你可能注意到了 feedAnimals() 方法只对 hungryAnimals 遍历了一遍过后，就立刻忽略掉这个临时的数组了，如果农场有大量饥饿的动物的话，这是非常低效的。</p>\n<p>![image-20220630094032753](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630094032753.png)</p>\n<p>一种避免这种临时内存空间分配的方式是使用标准库中的懒加载集合特性。通过将 filter 替换为 lazy.filter，我们就能得到懒加载的集合了。懒加载集合与数组返回的元素是相同的，就是直白的调用了 filter，但是它可以避免临时内存空间的分配。</p>\n<p>然而，hungryAnimals 属性的类型声明就要比它本来的实体类型复杂了：遵循 LazyFilterSequence 协议的由 any Animal 类型元素组成的数组。</p>\n<p>这里暴露了许多不必要的实现细节。feedAnimals() 方法这个客户并不关心我们在 hungryAnimals 的实现中使用了 lazy.filter。</p>\n<p>![image-20220630094835199](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630094835199.png)</p>\n<p>它只需要知道它获取到的是一个可以遍历的集合就够了。</p>\n<p>可以使用一个不透明的返回值类型来隐藏抽象接口背后的复杂的实体类型集合。</p>\n<p>![image-20220630095819276](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630095819276.png)</p>\n<p>现在，客户调用 hungryAnimals 时只知道它们可以得到某个遵循 Collection 协议的实体类型，但是并不知道集合具体的实体类型是什么。</p>\n<p>然而，就像写着的那样，这样确实对客户隐藏了太多静态类型的信息。我们声明了 hungryAnimals 会输出某个遵循 Collection 协议的实体类型，但是我们对这个集合的元素类型一无所知。如果不知道这个集合的元素类型是 any Animal，我们对这个元素类型所能做的就只有将其进行传递，我们不能调用 Animal 协议中的任何方法，让我们把焦点放在遵循 Collection 协议的不透明类型的返回值上面吧。</p>\n<p>![image-20220630100218811](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630100218811.png)</p>\n<p>我们可以通过使用一个限制的不透明返回值类型来协调隐藏实现细节与暴露足够丰富的接口之间的平衡。</p>\n<p>限制的不透明返回值类型是 Swift 5.7 新增的特性。</p>\n<p>![image-20220630112236985](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630112236985.png)</p>\n<p>一个限制的不透明返回值类型是通过在协议之后提供尖括号包裹的类型参数声明的。</p>\n<p>Collection 协议有一个单一的类型参数，即元素的类型。</p>\n<p>现在，一旦 hungryAnimals 的声明是一个限制的不透明返回值类型，它是一个遵循 LazyFilterSequence 协议的元素为 any Animal 类型的数组这个事实就被隐藏起来不被客户看到了，但客户仍然知道它是某个遵循 Collection 协议的实体类型，且其元素的关联类型等价于 any Animal，这才是我们真正想要的接口。</p>\n<p>![image-20220630112538737](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630112538737.png)</p>\n<p>在 feedAnimals() 的 for 循环中，animal 变量的的类型是 any Animal，这就允许每个 hungryAnimal 都可以调用 Animal 协议中的方法。</p>\n<p>![image-20220630113056298](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630113056298.png)</p>\n<p>这都是因为 Collection 协议声明了 Element 这个主要的关联类型，所以才能行得通的。你也可以像这样通过在协议名之后命名一个或多个尖括号包裹的关联类型来声明你自己的拥有主要关联类型的协议。</p>\n<p>![image-20220630113349346](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630113349346.png)</p>\n<p>关联类型作为主要的关联类型总是被调用者提供，例如集合的 Element 类型，与之相对的是实现细节，就像是集合的迭代类型。</p>\n<p>你总是可以看到协议的主要关联类型与泛型的类型参数传入的实体类型之间的相关(相似)性。这里，你可以看到 Collection 协议的主要关联类型 Element 被 Element 泛型参数 Array 和 Set 实现了，这两个实体类型定义在标准库中，都遵循了 Collection 协议。</p>\n<p>![image-20220630113748370](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630113748370.png)</p>\n<p>Collection&lt;Element&gt; 可以通过 some 关键字的修饰被用作不透明的返回值类型。</p>\n<p>![image-20220630115019329](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630115019329.png)</p>\n<p>同样也可以通过 any 关键字的修饰被用作限制的存在主义类型。</p>\n<p>![image-20220630115034795](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630115034795.png)</p>\n<p>在 Swift 5.7 之前，你并不需要写自己的数据类型来代表一个有具体泛型参数的存在主义类型。Swift 5.7 引入限制的存在主义类型这个概念。</p>\n<p>如果我们希望 hungryAnimals 的计算拥有懒加载或是立刻加载(eagerly)的选择权，使用一个不透明的元素类型为 any Animal 的 Collection 会发生编译错误，因为返回了两个不同基本类型的值。</p>\n<p>![image-20220630130306325](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630130306325.png)</p>\n<p>![image-20220630130357415](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630130357415.png)</p>\n<p>我们可以用 any 替换 some，返回遵循 any Animal 协议的 any Collection 类型，提示这个 API 被调用时可以返回不同类型的值。</p>\n<p>![image-20220630130545010](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630130545010.png)</p>\n<p>限制主要关联类型的能力给不透明类型和存在主义类型提供了更多的表达能力，这个能力可以用在多种标准库协议中，例如 Collection，你也可以声明你自己的带有主要关联类型的协议。</p>\n<p>使用不透明类型编写泛型代码必须依赖于抽象类型之间的关系，让我们来探讨一下如何确定并保证使用相关联协议的多个抽象类型之间的必要关系。</p>\n<p>我们要给 Animal 协议新增一个关联类型 AnimalFeed 实体类型(动物进食的食物类型)，同时新增一个eat(:) 方法来告诉动物可以消费这种类型的食物。</p>\n<p>![image-20220630131309999](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630131309999.png)</p>\n<p>为了让事情变得更有趣，我将要介绍一个额外的复杂功能。在我们给动物喂食之前，我们必须种植合适的庄稼，并且收获庄稼产出的食物。这是第一部分实体类：</p>\n<p>![image-20220630131748293](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630131748293.png)</p>\n<p>Cow 吃 Hay，所以我们首先需要种一些 Hay，这样可以得到 Alfalfa，它能够产出 Hay，这种 Cow 能吃的食物。</p>\n<p>这里是第二部分实体类：</p>\n<p>![image-20220630132014917](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630132014917.png)</p>\n<p>Chicken 吃 Scratch，所以我们首先种一些 Millet，可以产出 Scratch，然后喂给 Chicken。</p>\n<p>我想将这两种相关的实体类型抽象出来，所以我可以实现一次 feedAnimal(:) 方法，就能同时喂养 Cow 和 Chicken，以及我之后可能会喂养的新的动物。</p>\n<p>![image-20220630133327284](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630133327284.png)</p>\n<p>因为 feedAnimal(:) 方法需要与 Animal 协议中的 eat(:) 方法共同作用，它在消费位置有一个关联类型，我将通过声明参数类型为 some Animal 的 feedAnimal(:) 方法来对存在主义类型进行拆包。</p>\n<p>开始之前，我先用我们目前对协议和关联类型所知的内容声明几个协议 AnimalFeed 和 Crop。</p>\n<p>AnimalFeed 有一个关联类型 CropType，它遵循 Crop 协议。Crop 有一个关联类型遵循 AnimalFeed。</p>\n<p>![image-20220630133922382](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630133922382.png)</p>\n<p>像之前那样，我们先看一组协议类型参数的图。</p>\n<p>我们先看 AnimalFeed，每个协议都有一个类型 Self，代表遵循协议的实体类型。</p>\n<p>![image-20220630134329982](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630134329982.png)</p>\n<p>我们的协议有一个关联类型 CropType，遵循 Crop 协议。</p>\n<p>![image-20220630134542175](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630134542175.png)</p>\n<p>关联类型 CropType 有一个内嵌的关联类型 FeedType，遵循 AnimalFeed 协议，这个 AnimalFeed 也有一个内嵌的关联类型 CropType，遵循 Crop 协议，循环往复，关联类型在 AnimalFeed 与 Crop 之间互相遵循，不断切换，无限嵌套。</p>\n<p>![image-20220630134846558](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630134846558.png)</p>\n<p>对于 Crop 协议也是相同的情况，从遵循 Crop 协议的 Self 类型开始，有一个遵循 AnimalFeed 协议的关联类型 FeedType，这个关联类型有一个内嵌的关联类型 CropType，无限嵌套。</p>\n<p>让我们看看这些协议是否正确地模型化了实体类型之间的关系。回想一下在喂养动物之前，我们需要种植庄稼，然后会产出正确的动物要进食的食物。grow() 是 AnimalFeed 协议中的一个静态方法，这意味着它必须被遵循 AnimalFeed 协议的类型直接调用，而不是遵循 AnimalFeed 协议的具体类型的实例对象值。我们需要写下遵循 AnimalFeed 协议的类型的名称，但是我们有的只是一个遵循 Animal 协议的某个具体的类型，与 AnimalFeed 是不同的协议。</p>\n<p>我们可以用 type(of:) 方法得到 animal 实例的类型，我们知道它一定是遵循 Animal 协议的某个类型，Animal 有一个关联类型 FeedType，它遵循 AnimalFeed 协议。这个类可以被作为调用 grow() 方法的基本类型。</p>\n<p>AnimalFeed 协议的 grow() 方法返回一个值，这个值的类型是 AnimalFeed 的嵌套关联类型 CropType。我们知道 CropType 是遵循 Crop 协议的，所以可以对 CropType 的实例调用 harvest() 方法，但是我会得到什么呢？</p>\n<p>harvest() 被声明为返回一个遵循 Crop 协议的 FeedType 的关联类型。</p>\n<p>在我们的例子中，因为调用是基于 (some Animal).FeedType.CropType 的，harvest() 方法会输出一个 (some Animal).FeedType.CropType.FeedType。</p>\n<p>不幸的是，这是错误的类型。</p>\n<p>对 some Animal 调用 eat() 方法期待的返回值类型是 (some Animal).FeedType，而不是 (some Animal).FeedType.CropType.FeedType。</p>\n<p>![image-20220630143840680](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630143840680.png)</p>\n<p>这个程序类型是有问题的。</p>\n<p>![image-20220630163559858](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630163559858.png)</p>\n<p>这些协议的定义，并没有真实地保证如果我们从 AnimalFeed 类型开始，然后调用 grow() 和 harvest()，我们会得到与 AnimalFeed 开始时相同的类型，也就是我们所期待的动物进食食物的类型。</p>\n<p>另一种理解它的方式是，这些协议的定义太宽泛了，它们并没有准确地模型化我们对这些实体类型之间关系的期望，为了理解这是为什么，我们看一下 Hay 和 Alfalfa 类型。</p>\n<p>当我种下 Hay，可以得到 Alfalfa，当我收获 Alfalfa，可以得到 Hay。</p>\n<p>现在想象一下我重构这部分代码，我不小心修改了 Alfalfa 的 harvest() 方法的返回值类型，返回 Scratch 而不是 Hay。</p>\n<p><img src=\"/Users/yanqizhao/Downloads/IMG_2469.JPG\" alt=\"IMG_2469\"></p>\n<p>被我不小心改掉之后，实体类型仍然满足 AnimalFeed 和 Crop 协议的要求，尽管我们违背了不改变 grow() 和 harvest() 方法返回值类型 crop 的初衷。</p>\n<p>让我们再看一次 AnimalFeed 这个协议，真正的问题是我们定义了太多不同的关联类型了。</p>\n<p><img src=\"/Users/yanqizhao/Downloads/IMG_2470.JPG\" alt=\"IMG_2470\"></p>\n<p>我们需要写下这两种关联类型，它们是两种相同的实体类型，这将避免遵循协议时错误的实体类型。</p>\n<p>它也可以给 feedAnimal() 方法它所需要的值。</p>\n<p>我们可以使用一个相同类型要求的 where 语句来表达这两种关联类型的关系。</p>\n<p>一个相同类型的要求表达了两个不同的，可能是嵌套的关联类型，一定是相同的实体类型这样一个静态的保证。</p>\n<p>添加一个相同类型的要求采用了一个遵循 AnimalFeed 协议的实体类型的限制。</p>\n<p><img src=\"/Users/yanqizhao/Downloads/IMG_2471.JPG\" alt=\"IMG_2471\"></p>\n<p>在这个相同类型要求里，我们声明了 Self.CropType.FeedType = Self，在图里看起来是什么样子呢，我们可以对其进行可视化。</p>\n<p>每个遵循 AnimalFeed 协议的实体类型都有一个遵循 Crop 的 CropType，然而这个 CropType 的 FeedType 并不是其他任何一个遵循 AnimalFeed 的类型，而是与之前相同的 AnimalFeed 类型。</p>\n<p>不在使用一个无穷的嵌套关联类型塔，取而代之的是，我把这些关系折叠为一对相关的关联类型。</p>\n<p><img src=\"/Users/yanqizhao/Downloads/IMG_2472.JPG\" alt=\"IMG_2472\">那 Crop 协议怎么办，这里，Crop 的 FeedType 也折叠到一对类型里，但我们仍然多了一个关联类型。</p>\n<p><img src=\"/Users/yanqizhao/Downloads/IMG_2473.JPG\" alt=\"IMG_2473\"></p>\n<p>我们想说，Crop 的 FeedType 的 CropType 也与开始的 Crop 相同。</p>\n<p><img src=\"/Users/yanqizhao/Downloads/IMG_2474.JPG\" alt=\"IMG_2474\"></p>\n<p>现在这两个协议都配备了相同类型的要求，我们可以重新调用一次 feedAnimal() 方法了。</p>\n<p><img src=\"/Users/yanqizhao/Downloads/IMG_2475.JPG\" alt=\"IMG_2475\"></p>\n<p>我们还是从 some Animal 开始，然后我们得到了 some Animal 的 FeedType，我们知道 FeedType 遵循 AnimalFeed 协议。</p>\n<p>当我们种下这种 Crop，我们得到了 some Animal 的 FeedType 的 CropType，但是现在，当我们收获这种 Crop 的时候，我们得到的不是到现在为止仍然是另一个嵌套的关联类型，取而代之的是，我们得到的恰恰是我们这个 Animal 对象所期待的 FeedType。</p>\n<p>现在这个快乐的 Animal 可以确保吃到正确的 AnimalFeed，就是我们刚刚种下的。</p>\n<p>最后，让我们看看 Animal 协议的关联类型图，它将我们目前看到的内容放在了一起。</p>\n<p>这是两部分协议遵循的实体类型：</p>\n<p><img src=\"/Users/yanqizhao/Downloads/IMG_2476.JPG\" alt=\"IMG_2476\"></p>\n<p>首先我们有 Cow、Hay、Alfalfa，然后我们有 Chicken、Scratch、Millet，注意我们有三个协议精确地模型化了每部分的三个实体类型的关系。</p>\n<p>为了理解这些数据模型，你可以使用相同类型的要求来定义这些不同的嵌套关联类型的等价性。</p>\n<p>当泛型代码链接多个协议要求的调用时可以依赖这些关系。</p>\n<p>在这个视频中，我们探索了类型擦除何时才是安全的，以及类型关系的确保何时需要处在同一上下文中。</p>\n<p>然后我们讨论了如何使用既能用作不透明类型又能用作存在主义类型的主要关联类型做到保持丰富的类型信息与隐藏实现细节的平衡。</p>\n<p>最后，我们看到了使用代表类型之间关系的协议表达，如何确定并且确保相同类型要求的实体类型之间的关系。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"WWDC-22-110353-设计-Swift-协议接口-直译\"><a href=\"#WWDC-22-110353-设计-Swift-协议接口-直译\" class=\"headerlink\" title=\"WWDC 22 - 110353 设计 Swift 协议接口 直译\"></a>WWDC 22 - 110353 设计 Swift 协议接口 直译</h1><p>我将会为你展示一些使用协议抽象实体类型和模型化类型关系的高级技巧， 这个视频会涉及到已经存在的语言特性与 Swift 5.7 引入的新的能力。</p>\n<p>这个视频有三个主题：</p>\n<p>首先，我将通过解释返回值类型擦除的例子来为你展示协议和关联类型与 any 的共同使用。</p>\n<p>![image-20220629164630483](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629164630483.png)</p>\n<p>接下来，我将通过隔离接口与实现来解释返回值使用不透明类型的进一步优化封装。</p>\n<p>![image-20220629164839506](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629164839506.png)</p>\n<p>最后一点，你将看到协议中相同类型的必要条件是如何模型化多种不同实体类型的关系的。</p>\n<p>![image-20220629165151452](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629165151452.png)</p>\n<p>首先让我们从学习协议和关联类型是如何与 any 共同作用的。</p>\n<p>这里，我们有一个包含多个协议和四个实体类型的数据模型。这里有两种动物，鸡和奶牛，和两种食物，鸡蛋和牛奶。</p>\n<p>![image-20220629165311725](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629165311725.png)</p>\n<p>鸡下蛋，奶牛产奶。</p>\n<p>![image-20220629165456814](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629165456814.png)</p>\n<p>为了抽象食物的产出，我为 Animal 协议添加了一个 produce() 方法。</p>\n<p>![image-20220629165620924](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629165620924.png)</p>\n<p>你应该还记得上一个视频中，对不同返回值类型进行抽象(如对奶牛和鸡分别调用 produce() 方法)的最佳方法是使用一个关联类型。</p>\n<p>通过使用关联类型，我们进行如下声明：</p>\n<p>给 Animal 声明一些实体类型，调用 produce() 方法返回某个具体的 Food 类型，是依赖于对应的 Animal 实体类型的。</p>\n<p>我们可以用一张图来表示这种关系。</p>\n<p>![image-20220629171008403](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629171008403.png)</p>\n<p> 协议中的 self 代表一个遵循 Animal 协议的真实的实体类型，self 类型有一个关联类型：CommodityType，这个类型遵循 Food 协议。</p>\n<p>让我们来看看奶牛和鸡这些实体类型与图中 Animal 协议的关联类型的关系。</p>\n<p>鸡类型遵循 Animal 协议，同时其 CommodityType 的类型为 Egg。</p>\n<p>![image-20220629171528411](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629171528411.png)</p>\n<p>而奶牛类型遵循 Animal 协议，其 CommodityType 为 Milk。</p>\n<p>![image-20220629171619514](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629171619514.png)</p>\n<p>现在我们可以说我们的农场里有好多种动物，animals 存储属性是一个元素为异源 any Animal 类型的数组。</p>\n<p>![image-20220629171725309](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629171725309.png)</p>\n<p>在上个视频中，我们看到了 any Animal 类型是如何拥有一个盒子而有能力动态存储任何实体动物类型的。为不同的实体类型使用相同的表达形式的策略叫做类型擦除。</p>\n<p>produceCommodities() 方法遍历了 animals 数组并对每一个 animal 调用了 produce() 方法。</p>\n<p>这个方法看起来很简单，但是我们知道类型擦除会将动物的基本类型之间的静态关系消除掉，所以这值得我们深入了解一下，为什么会有这样的代码检查。</p>\n<p>map 闭包中的 animal 实例的类型是 any Animal。</p>\n<p>![image-20220629172625634](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629172625634.png)</p>\n<p>而 produce() 方法返回值的类型是一个关联类型。</p>\n<p>![image-20220629172716930](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629172716930.png)</p>\n<p>当你调用一个方法，其返回值是一个存在主义类型实例的关联类型时，编译器会使用类型擦除来决定这次调用的返回值类型。</p>\n<p>![image-20220629172841153](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629172841153.png)</p>\n<p>类型擦除取代了这些关联类型和相关的存在主义类型，有相同的限制。</p>\n<p>![image-20220629173021458](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629173021458.png)</p>\n<p>我们通过使用 any Animal 和 any Food 擦除了 Animal 实体类型与关联类型 CommodityType 的关系。</p>\n<p>any Food 的类型被叫做关联类型 CommodityType 的上层限制。(upper bound)</p>\n<p>既然 produce() 方法是被 any Animal 调用的，而返回值类型又被擦除了，返回给我们的就是一个 any Food 的返回值类型，这恰恰是我们所期待的类型。</p>\n<p>![image-20220629174005511](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629174005511.png)</p>\n<p>让我们仔细看看 Swift 5.7 中的新特性关联类型的擦除是如何工作的。关联类型出现在协议方法返回值类型的位置，即在方法声明中箭头的右边被叫做“产出位置”，因为调用这个方法将会得出一个该类型的值。</p>\n<p>![image-20220629174027749](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629174027749.png)</p>\n<p>当我们对 any Animal 调用这个方法时，我们在编译时是不知道返回值的实体类型的，但是我们知道它是“上层限制”的某个子类。</p>\n<p>![image-20220629174451155](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629174451155.png)</p>\n<p>这里是一个示例，我们对 any Animal 调用 produce() 方法，在运行时，这个数组中只有一个 Cow() 实例，在这种情况下，produce() 方法返回值的类型是 Milk，Milk 是可以被存储在 any Food 中的，它是在 Animal 协议中被定义的关联类型 CommodityType 的“上层限制”。</p>\n<p>![image-20220629174755209](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629174755209.png)</p>\n<p>这在遵循 Animal 协议的实体类型中总是安全的。</p>\n<p>![image-20220629175017570](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629175017570.png)</p>\n<p>让我们考虑一下如果关联类型出现在方法的参数列表或者是构造器中在会发生什么吧。</p>\n<p>这里，Animal 协议中的 eat(:) 方法有一个关联类型 FeedType 在“消费位置”，我们调用这个方法的时候需要传递一个 FeedType 的值进去。因为转变(类型的确定)是在方法外部做的，这样就无法执行类型擦除了。</p>\n<p>![image-20220629175125068](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629175125068.png)</p>\n<p>关联类型的上层限制存在主义类型并不能安全地将其转换为真实的实体类型，因为实体类型是未知的。</p>\n<p>![image-20220630090442475](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630090442475.png)</p>\n<p>让我们来看一个例子，我们再一次用 any Animal 存储一个 Cow 实例。</p>\n<p>![image-20220630090754140](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630090754140.png)</p>\n<p>假设 Cow 的 eat(:)  方法传入的参数类型为 Hay，Animal 协议 FeedType 关联类型的上层限制是 any AnimalFeed。</p>\n<p>![image-20220630090825995](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630090825995.png)</p>\n<p>但是传入任意的 any AnimalFeed，就没有办法静态保证是 Hay 这个实体类型的实例了。</p>\n<p>![image-20220630091131974](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630091131974.png)</p>\n<p>类型擦除并不允许我们将关联类型作为参数放在消费位置使用的。</p>\n<p>取而代之的是，你必须通过将 any 类型的存在主义类型传给一个接收 some 不透明类型作为参数的函数进行拆包。</p>\n<p>有关联类型的类型擦除行为与 Swift 5.6 中已经存在的语言特性类似，考虑一个拷贝引用类型的协议，这个协议定义了一个 clone() 方法，返回值类型为 Self。</p>\n<p>![image-20220630091555660](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630091555660.png)</p>\n<p>当你对一个 any Cloneable 类型的实例调用 clone() 方法时，返回值类型 Self 就被弃上层限制擦除类型了。</p>\n<p>![image-20220630091709706](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630091709706.png)</p>\n<p>Self 类型的上层限制总是协议本身，所以我们得到了一个新的 any Cloneable 类型的实例。</p>\n<p>![image-20220630091851919](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630091851919.png)</p>\n<p>所以总结一下，你可以使用 any 去声明一个存储了遵循某个协议的实体类型的存在主义类型的值，甚至可以是有关联类型的协议。</p>\n<p>当调用一个关联类型在产出位置的协议方法时，关联类型被类型擦除为其上层限制，是另一个存在主义类型，携带了关联类型的限制(我的理解是关系，比如 Milk 和 Cow 的关系)。</p>\n<p>![image-20220630092431718](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630092431718.png)</p>\n<p>抽象实体类型并不只是针对函数的输入，也可以用作函数输出，所以实体类型仅在函数实现中才能被看到。</p>\n<p>让我们看看如何将返回值位置的实体类型抽象出来，通过将必要的接口与实现细节隔离开来。使静态类型的赋值在发生变化时能够更加模块化与健壮。</p>\n<p>让我们笼统地认为动物都需要喂食。动物会饿，当它们饿的时候就需要进食。让我们添加一个 isHungry 属性给 Animal 协议。</p>\n<p>![image-20220630093842665](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630093842665.png)</p>\n<p>Farm 的 feedAnimals() 方法将会对饿了的动物进行喂食。我用 filter() 方法将饥饿的动物通过 isHungry 属性过滤出来并存在计算属性 hungryAnimals 中。对 any Animal 类型的数组元素调用 filter() 将会返回一个新的 any Animal 类型的数组。</p>\n<p>你可能注意到了 feedAnimals() 方法只对 hungryAnimals 遍历了一遍过后，就立刻忽略掉这个临时的数组了，如果农场有大量饥饿的动物的话，这是非常低效的。</p>\n<p>![image-20220630094032753](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630094032753.png)</p>\n<p>一种避免这种临时内存空间分配的方式是使用标准库中的懒加载集合特性。通过将 filter 替换为 lazy.filter，我们就能得到懒加载的集合了。懒加载集合与数组返回的元素是相同的，就是直白的调用了 filter，但是它可以避免临时内存空间的分配。</p>\n<p>然而，hungryAnimals 属性的类型声明就要比它本来的实体类型复杂了：遵循 LazyFilterSequence 协议的由 any Animal 类型元素组成的数组。</p>\n<p>这里暴露了许多不必要的实现细节。feedAnimals() 方法这个客户并不关心我们在 hungryAnimals 的实现中使用了 lazy.filter。</p>\n<p>![image-20220630094835199](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630094835199.png)</p>\n<p>它只需要知道它获取到的是一个可以遍历的集合就够了。</p>\n<p>可以使用一个不透明的返回值类型来隐藏抽象接口背后的复杂的实体类型集合。</p>\n<p>![image-20220630095819276](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630095819276.png)</p>\n<p>现在，客户调用 hungryAnimals 时只知道它们可以得到某个遵循 Collection 协议的实体类型，但是并不知道集合具体的实体类型是什么。</p>\n<p>然而，就像写着的那样，这样确实对客户隐藏了太多静态类型的信息。我们声明了 hungryAnimals 会输出某个遵循 Collection 协议的实体类型，但是我们对这个集合的元素类型一无所知。如果不知道这个集合的元素类型是 any Animal，我们对这个元素类型所能做的就只有将其进行传递，我们不能调用 Animal 协议中的任何方法，让我们把焦点放在遵循 Collection 协议的不透明类型的返回值上面吧。</p>\n<p>![image-20220630100218811](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630100218811.png)</p>\n<p>我们可以通过使用一个限制的不透明返回值类型来协调隐藏实现细节与暴露足够丰富的接口之间的平衡。</p>\n<p>限制的不透明返回值类型是 Swift 5.7 新增的特性。</p>\n<p>![image-20220630112236985](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630112236985.png)</p>\n<p>一个限制的不透明返回值类型是通过在协议之后提供尖括号包裹的类型参数声明的。</p>\n<p>Collection 协议有一个单一的类型参数，即元素的类型。</p>\n<p>现在，一旦 hungryAnimals 的声明是一个限制的不透明返回值类型，它是一个遵循 LazyFilterSequence 协议的元素为 any Animal 类型的数组这个事实就被隐藏起来不被客户看到了，但客户仍然知道它是某个遵循 Collection 协议的实体类型，且其元素的关联类型等价于 any Animal，这才是我们真正想要的接口。</p>\n<p>![image-20220630112538737](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630112538737.png)</p>\n<p>在 feedAnimals() 的 for 循环中，animal 变量的的类型是 any Animal，这就允许每个 hungryAnimal 都可以调用 Animal 协议中的方法。</p>\n<p>![image-20220630113056298](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630113056298.png)</p>\n<p>这都是因为 Collection 协议声明了 Element 这个主要的关联类型，所以才能行得通的。你也可以像这样通过在协议名之后命名一个或多个尖括号包裹的关联类型来声明你自己的拥有主要关联类型的协议。</p>\n<p>![image-20220630113349346](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630113349346.png)</p>\n<p>关联类型作为主要的关联类型总是被调用者提供，例如集合的 Element 类型，与之相对的是实现细节，就像是集合的迭代类型。</p>\n<p>你总是可以看到协议的主要关联类型与泛型的类型参数传入的实体类型之间的相关(相似)性。这里，你可以看到 Collection 协议的主要关联类型 Element 被 Element 泛型参数 Array 和 Set 实现了，这两个实体类型定义在标准库中，都遵循了 Collection 协议。</p>\n<p>![image-20220630113748370](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630113748370.png)</p>\n<p>Collection&lt;Element&gt; 可以通过 some 关键字的修饰被用作不透明的返回值类型。</p>\n<p>![image-20220630115019329](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630115019329.png)</p>\n<p>同样也可以通过 any 关键字的修饰被用作限制的存在主义类型。</p>\n<p>![image-20220630115034795](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630115034795.png)</p>\n<p>在 Swift 5.7 之前，你并不需要写自己的数据类型来代表一个有具体泛型参数的存在主义类型。Swift 5.7 引入限制的存在主义类型这个概念。</p>\n<p>如果我们希望 hungryAnimals 的计算拥有懒加载或是立刻加载(eagerly)的选择权，使用一个不透明的元素类型为 any Animal 的 Collection 会发生编译错误，因为返回了两个不同基本类型的值。</p>\n<p>![image-20220630130306325](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630130306325.png)</p>\n<p>![image-20220630130357415](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630130357415.png)</p>\n<p>我们可以用 any 替换 some，返回遵循 any Animal 协议的 any Collection 类型，提示这个 API 被调用时可以返回不同类型的值。</p>\n<p>![image-20220630130545010](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630130545010.png)</p>\n<p>限制主要关联类型的能力给不透明类型和存在主义类型提供了更多的表达能力，这个能力可以用在多种标准库协议中，例如 Collection，你也可以声明你自己的带有主要关联类型的协议。</p>\n<p>使用不透明类型编写泛型代码必须依赖于抽象类型之间的关系，让我们来探讨一下如何确定并保证使用相关联协议的多个抽象类型之间的必要关系。</p>\n<p>我们要给 Animal 协议新增一个关联类型 AnimalFeed 实体类型(动物进食的食物类型)，同时新增一个eat(:) 方法来告诉动物可以消费这种类型的食物。</p>\n<p>![image-20220630131309999](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630131309999.png)</p>\n<p>为了让事情变得更有趣，我将要介绍一个额外的复杂功能。在我们给动物喂食之前，我们必须种植合适的庄稼，并且收获庄稼产出的食物。这是第一部分实体类：</p>\n<p>![image-20220630131748293](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630131748293.png)</p>\n<p>Cow 吃 Hay，所以我们首先需要种一些 Hay，这样可以得到 Alfalfa，它能够产出 Hay，这种 Cow 能吃的食物。</p>\n<p>这里是第二部分实体类：</p>\n<p>![image-20220630132014917](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630132014917.png)</p>\n<p>Chicken 吃 Scratch，所以我们首先种一些 Millet，可以产出 Scratch，然后喂给 Chicken。</p>\n<p>我想将这两种相关的实体类型抽象出来，所以我可以实现一次 feedAnimal(:) 方法，就能同时喂养 Cow 和 Chicken，以及我之后可能会喂养的新的动物。</p>\n<p>![image-20220630133327284](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630133327284.png)</p>\n<p>因为 feedAnimal(:) 方法需要与 Animal 协议中的 eat(:) 方法共同作用，它在消费位置有一个关联类型，我将通过声明参数类型为 some Animal 的 feedAnimal(:) 方法来对存在主义类型进行拆包。</p>\n<p>开始之前，我先用我们目前对协议和关联类型所知的内容声明几个协议 AnimalFeed 和 Crop。</p>\n<p>AnimalFeed 有一个关联类型 CropType，它遵循 Crop 协议。Crop 有一个关联类型遵循 AnimalFeed。</p>\n<p>![image-20220630133922382](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630133922382.png)</p>\n<p>像之前那样，我们先看一组协议类型参数的图。</p>\n<p>我们先看 AnimalFeed，每个协议都有一个类型 Self，代表遵循协议的实体类型。</p>\n<p>![image-20220630134329982](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630134329982.png)</p>\n<p>我们的协议有一个关联类型 CropType，遵循 Crop 协议。</p>\n<p>![image-20220630134542175](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630134542175.png)</p>\n<p>关联类型 CropType 有一个内嵌的关联类型 FeedType，遵循 AnimalFeed 协议，这个 AnimalFeed 也有一个内嵌的关联类型 CropType，遵循 Crop 协议，循环往复，关联类型在 AnimalFeed 与 Crop 之间互相遵循，不断切换，无限嵌套。</p>\n<p>![image-20220630134846558](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630134846558.png)</p>\n<p>对于 Crop 协议也是相同的情况，从遵循 Crop 协议的 Self 类型开始，有一个遵循 AnimalFeed 协议的关联类型 FeedType，这个关联类型有一个内嵌的关联类型 CropType，无限嵌套。</p>\n<p>让我们看看这些协议是否正确地模型化了实体类型之间的关系。回想一下在喂养动物之前，我们需要种植庄稼，然后会产出正确的动物要进食的食物。grow() 是 AnimalFeed 协议中的一个静态方法，这意味着它必须被遵循 AnimalFeed 协议的类型直接调用，而不是遵循 AnimalFeed 协议的具体类型的实例对象值。我们需要写下遵循 AnimalFeed 协议的类型的名称，但是我们有的只是一个遵循 Animal 协议的某个具体的类型，与 AnimalFeed 是不同的协议。</p>\n<p>我们可以用 type(of:) 方法得到 animal 实例的类型，我们知道它一定是遵循 Animal 协议的某个类型，Animal 有一个关联类型 FeedType，它遵循 AnimalFeed 协议。这个类可以被作为调用 grow() 方法的基本类型。</p>\n<p>AnimalFeed 协议的 grow() 方法返回一个值，这个值的类型是 AnimalFeed 的嵌套关联类型 CropType。我们知道 CropType 是遵循 Crop 协议的，所以可以对 CropType 的实例调用 harvest() 方法，但是我会得到什么呢？</p>\n<p>harvest() 被声明为返回一个遵循 Crop 协议的 FeedType 的关联类型。</p>\n<p>在我们的例子中，因为调用是基于 (some Animal).FeedType.CropType 的，harvest() 方法会输出一个 (some Animal).FeedType.CropType.FeedType。</p>\n<p>不幸的是，这是错误的类型。</p>\n<p>对 some Animal 调用 eat() 方法期待的返回值类型是 (some Animal).FeedType，而不是 (some Animal).FeedType.CropType.FeedType。</p>\n<p>![image-20220630143840680](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630143840680.png)</p>\n<p>这个程序类型是有问题的。</p>\n<p>![image-20220630163559858](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630163559858.png)</p>\n<p>这些协议的定义，并没有真实地保证如果我们从 AnimalFeed 类型开始，然后调用 grow() 和 harvest()，我们会得到与 AnimalFeed 开始时相同的类型，也就是我们所期待的动物进食食物的类型。</p>\n<p>另一种理解它的方式是，这些协议的定义太宽泛了，它们并没有准确地模型化我们对这些实体类型之间关系的期望，为了理解这是为什么，我们看一下 Hay 和 Alfalfa 类型。</p>\n<p>当我种下 Hay，可以得到 Alfalfa，当我收获 Alfalfa，可以得到 Hay。</p>\n<p>现在想象一下我重构这部分代码，我不小心修改了 Alfalfa 的 harvest() 方法的返回值类型，返回 Scratch 而不是 Hay。</p>\n<p><img src=\"/Users/yanqizhao/Downloads/IMG_2469.JPG\" alt=\"IMG_2469\"></p>\n<p>被我不小心改掉之后，实体类型仍然满足 AnimalFeed 和 Crop 协议的要求，尽管我们违背了不改变 grow() 和 harvest() 方法返回值类型 crop 的初衷。</p>\n<p>让我们再看一次 AnimalFeed 这个协议，真正的问题是我们定义了太多不同的关联类型了。</p>\n<p><img src=\"/Users/yanqizhao/Downloads/IMG_2470.JPG\" alt=\"IMG_2470\"></p>\n<p>我们需要写下这两种关联类型，它们是两种相同的实体类型，这将避免遵循协议时错误的实体类型。</p>\n<p>它也可以给 feedAnimal() 方法它所需要的值。</p>\n<p>我们可以使用一个相同类型要求的 where 语句来表达这两种关联类型的关系。</p>\n<p>一个相同类型的要求表达了两个不同的，可能是嵌套的关联类型，一定是相同的实体类型这样一个静态的保证。</p>\n<p>添加一个相同类型的要求采用了一个遵循 AnimalFeed 协议的实体类型的限制。</p>\n<p><img src=\"/Users/yanqizhao/Downloads/IMG_2471.JPG\" alt=\"IMG_2471\"></p>\n<p>在这个相同类型要求里，我们声明了 Self.CropType.FeedType = Self，在图里看起来是什么样子呢，我们可以对其进行可视化。</p>\n<p>每个遵循 AnimalFeed 协议的实体类型都有一个遵循 Crop 的 CropType，然而这个 CropType 的 FeedType 并不是其他任何一个遵循 AnimalFeed 的类型，而是与之前相同的 AnimalFeed 类型。</p>\n<p>不在使用一个无穷的嵌套关联类型塔，取而代之的是，我把这些关系折叠为一对相关的关联类型。</p>\n<p><img src=\"/Users/yanqizhao/Downloads/IMG_2472.JPG\" alt=\"IMG_2472\">那 Crop 协议怎么办，这里，Crop 的 FeedType 也折叠到一对类型里，但我们仍然多了一个关联类型。</p>\n<p><img src=\"/Users/yanqizhao/Downloads/IMG_2473.JPG\" alt=\"IMG_2473\"></p>\n<p>我们想说，Crop 的 FeedType 的 CropType 也与开始的 Crop 相同。</p>\n<p><img src=\"/Users/yanqizhao/Downloads/IMG_2474.JPG\" alt=\"IMG_2474\"></p>\n<p>现在这两个协议都配备了相同类型的要求，我们可以重新调用一次 feedAnimal() 方法了。</p>\n<p><img src=\"/Users/yanqizhao/Downloads/IMG_2475.JPG\" alt=\"IMG_2475\"></p>\n<p>我们还是从 some Animal 开始，然后我们得到了 some Animal 的 FeedType，我们知道 FeedType 遵循 AnimalFeed 协议。</p>\n<p>当我们种下这种 Crop，我们得到了 some Animal 的 FeedType 的 CropType，但是现在，当我们收获这种 Crop 的时候，我们得到的不是到现在为止仍然是另一个嵌套的关联类型，取而代之的是，我们得到的恰恰是我们这个 Animal 对象所期待的 FeedType。</p>\n<p>现在这个快乐的 Animal 可以确保吃到正确的 AnimalFeed，就是我们刚刚种下的。</p>\n<p>最后，让我们看看 Animal 协议的关联类型图，它将我们目前看到的内容放在了一起。</p>\n<p>这是两部分协议遵循的实体类型：</p>\n<p><img src=\"/Users/yanqizhao/Downloads/IMG_2476.JPG\" alt=\"IMG_2476\"></p>\n<p>首先我们有 Cow、Hay、Alfalfa，然后我们有 Chicken、Scratch、Millet，注意我们有三个协议精确地模型化了每部分的三个实体类型的关系。</p>\n<p>为了理解这些数据模型，你可以使用相同类型的要求来定义这些不同的嵌套关联类型的等价性。</p>\n<p>当泛型代码链接多个协议要求的调用时可以依赖这些关系。</p>\n<p>在这个视频中，我们探索了类型擦除何时才是安全的，以及类型关系的确保何时需要处在同一上下文中。</p>\n<p>然后我们讨论了如何使用既能用作不透明类型又能用作存在主义类型的主要关联类型做到保持丰富的类型信息与隐藏实现细节的平衡。</p>\n<p>最后，我们看到了使用代表类型之间关系的协议表达，如何确定并且确保相同类型要求的实体类型之间的关系。</p>\n"},{"_content":"# WWDC 22 - 110353 设计 Swift 协议接口 第一次整理\n\n抽象实体类型&模型化类型关系\n\n1. 类型擦除\n2. 返回值使用不透明类型\n3. 参数使用存在主义类型\n\n\n\n![image-20220629165456814](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629165456814.png)\n\n![image-20220629171528411](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629171528411.png)\n\n\n\n## 返回值位置使用 any——Swift 5.7\n\n## 返回值位置使用关联类型——Swift 5.7\n\n![image-20220629171725309](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629171725309.png)\n\n![image-20220629174027749](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629174027749.png)\n\n![image-20220629174755209](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629174755209.png)\n\n\n\n## 参数位置使用关联类型——Swift 5.7\n\n![image-20220629175125068](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629175125068.png)\n\n![image-20220630090825995](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630090825995.png)\n\n![image-20220630091131974](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630091131974.png)\n\n\n\n### 5.6 就有的语言特性(返回值位置)\n\n![image-20220630091555660](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630091555660.png)\n\n![image-20220630091709706](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630091709706.png)\n\n![image-20220630091851919](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630091851919.png)\n\n![image-20220630092431718](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630092431718.png)\n\n\n\n\n\n![image-20220630093842665](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630093842665.png)\n\n![image-20220630094032753](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630094032753.png)\n\n![image-20220630094835199](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630094835199.png)\n\n![image-20220630095819276](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630095819276.png)\n\n![image-20220630100218811](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630100218811.png)\n\n\n\n##  泛型限制位置使用 any——Swift 5.7\n\n![image-20220630112236985](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630112236985.png)\n\n![image-20220630113056298](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630113056298.png)\n\n![image-20220630113748370](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630113748370.png)\n\n## 返回值位置使用 some(有泛型)\n\n![image-20220630115019329](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630115019329.png)\n\n## 返回值位置使用 any(有泛型)——Swift 5.7\n\n![image-20220630115034795](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630115034795.png)\n\n![image-20220630130306325](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630130306325.png)\n\n![image-20220630130357415](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630130357415.png)\n\n![image-20220630130545010](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630130545010.png)\n\n\n\n## 参数位置使用关联类型 2——Swift 5.7\n\n![image-20220630131309999](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630131309999.png)\n\n![image-20220630131748293](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630131748293.png)\n\n![image-20220630132014917](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630132014917.png)\n\n![image-20220630133327284](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630133327284.png)\n\n对 some Animal 调用 eat() 方法期待的返回值类型是 (some Animal).FeedType，而不是 (some Animal).FeedType.CropType.FeedType。\n\n![image-20220630163559858](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630163559858.png)\n\n![IMG_2469](/Users/yanqizhao/Downloads/IMG_2469.JPG)\n\n![IMG_2474](/Users/yanqizhao/Downloads/IMG_2474.JPG)\n\n![IMG_2475](/Users/yanqizhao/Downloads/IMG_2475.JPG)\n\n![IMG_2476](/Users/yanqizhao/Downloads/IMG_2476.JPG)\n\n","source":"_drafts/WWDC 22 - 110353 设计 Swift 协议接口 第一次整理.md","raw":"# WWDC 22 - 110353 设计 Swift 协议接口 第一次整理\n\n抽象实体类型&模型化类型关系\n\n1. 类型擦除\n2. 返回值使用不透明类型\n3. 参数使用存在主义类型\n\n\n\n![image-20220629165456814](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629165456814.png)\n\n![image-20220629171528411](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629171528411.png)\n\n\n\n## 返回值位置使用 any——Swift 5.7\n\n## 返回值位置使用关联类型——Swift 5.7\n\n![image-20220629171725309](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629171725309.png)\n\n![image-20220629174027749](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629174027749.png)\n\n![image-20220629174755209](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629174755209.png)\n\n\n\n## 参数位置使用关联类型——Swift 5.7\n\n![image-20220629175125068](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629175125068.png)\n\n![image-20220630090825995](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630090825995.png)\n\n![image-20220630091131974](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630091131974.png)\n\n\n\n### 5.6 就有的语言特性(返回值位置)\n\n![image-20220630091555660](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630091555660.png)\n\n![image-20220630091709706](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630091709706.png)\n\n![image-20220630091851919](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630091851919.png)\n\n![image-20220630092431718](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630092431718.png)\n\n\n\n\n\n![image-20220630093842665](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630093842665.png)\n\n![image-20220630094032753](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630094032753.png)\n\n![image-20220630094835199](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630094835199.png)\n\n![image-20220630095819276](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630095819276.png)\n\n![image-20220630100218811](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630100218811.png)\n\n\n\n##  泛型限制位置使用 any——Swift 5.7\n\n![image-20220630112236985](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630112236985.png)\n\n![image-20220630113056298](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630113056298.png)\n\n![image-20220630113748370](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630113748370.png)\n\n## 返回值位置使用 some(有泛型)\n\n![image-20220630115019329](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630115019329.png)\n\n## 返回值位置使用 any(有泛型)——Swift 5.7\n\n![image-20220630115034795](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630115034795.png)\n\n![image-20220630130306325](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630130306325.png)\n\n![image-20220630130357415](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630130357415.png)\n\n![image-20220630130545010](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630130545010.png)\n\n\n\n## 参数位置使用关联类型 2——Swift 5.7\n\n![image-20220630131309999](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630131309999.png)\n\n![image-20220630131748293](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630131748293.png)\n\n![image-20220630132014917](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630132014917.png)\n\n![image-20220630133327284](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630133327284.png)\n\n对 some Animal 调用 eat() 方法期待的返回值类型是 (some Animal).FeedType，而不是 (some Animal).FeedType.CropType.FeedType。\n\n![image-20220630163559858](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630163559858.png)\n\n![IMG_2469](/Users/yanqizhao/Downloads/IMG_2469.JPG)\n\n![IMG_2474](/Users/yanqizhao/Downloads/IMG_2474.JPG)\n\n![IMG_2475](/Users/yanqizhao/Downloads/IMG_2475.JPG)\n\n![IMG_2476](/Users/yanqizhao/Downloads/IMG_2476.JPG)\n\n","slug":"WWDC 22 - 110353 设计 Swift 协议接口 第一次整理","published":0,"date":"2022-07-01T06:28:25.649Z","updated":"2022-07-02T05:03:00.381Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7ejwd850003o4dx0wak2eox","content":"<h1 id=\"WWDC-22-110353-设计-Swift-协议接口-第一次整理\"><a href=\"#WWDC-22-110353-设计-Swift-协议接口-第一次整理\" class=\"headerlink\" title=\"WWDC 22 - 110353 设计 Swift 协议接口 第一次整理\"></a>WWDC 22 - 110353 设计 Swift 协议接口 第一次整理</h1><p>抽象实体类型&amp;模型化类型关系</p>\n<ol>\n<li>类型擦除</li>\n<li>返回值使用不透明类型</li>\n<li>参数使用存在主义类型</li>\n</ol>\n<p>![image-20220629165456814](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629165456814.png)</p>\n<p>![image-20220629171528411](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629171528411.png)</p>\n<h2 id=\"返回值位置使用-any——Swift-5-7\"><a href=\"#返回值位置使用-any——Swift-5-7\" class=\"headerlink\" title=\"返回值位置使用 any——Swift 5.7\"></a>返回值位置使用 any——Swift 5.7</h2><h2 id=\"返回值位置使用关联类型——Swift-5-7\"><a href=\"#返回值位置使用关联类型——Swift-5-7\" class=\"headerlink\" title=\"返回值位置使用关联类型——Swift 5.7\"></a>返回值位置使用关联类型——Swift 5.7</h2><p>![image-20220629171725309](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629171725309.png)</p>\n<p>![image-20220629174027749](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629174027749.png)</p>\n<p>![image-20220629174755209](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629174755209.png)</p>\n<h2 id=\"参数位置使用关联类型——Swift-5-7\"><a href=\"#参数位置使用关联类型——Swift-5-7\" class=\"headerlink\" title=\"参数位置使用关联类型——Swift 5.7\"></a>参数位置使用关联类型——Swift 5.7</h2><p>![image-20220629175125068](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629175125068.png)</p>\n<p>![image-20220630090825995](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630090825995.png)</p>\n<p>![image-20220630091131974](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630091131974.png)</p>\n<h3 id=\"5-6-就有的语言特性-返回值位置\"><a href=\"#5-6-就有的语言特性-返回值位置\" class=\"headerlink\" title=\"5.6 就有的语言特性(返回值位置)\"></a>5.6 就有的语言特性(返回值位置)</h3><p>![image-20220630091555660](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630091555660.png)</p>\n<p>![image-20220630091709706](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630091709706.png)</p>\n<p>![image-20220630091851919](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630091851919.png)</p>\n<p>![image-20220630092431718](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630092431718.png)</p>\n<p>![image-20220630093842665](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630093842665.png)</p>\n<p>![image-20220630094032753](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630094032753.png)</p>\n<p>![image-20220630094835199](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630094835199.png)</p>\n<p>![image-20220630095819276](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630095819276.png)</p>\n<p>![image-20220630100218811](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630100218811.png)</p>\n<h2 id=\"泛型限制位置使用-any——Swift-5-7\"><a href=\"#泛型限制位置使用-any——Swift-5-7\" class=\"headerlink\" title=\"泛型限制位置使用 any——Swift 5.7\"></a>泛型限制位置使用 any——Swift 5.7</h2><p>![image-20220630112236985](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630112236985.png)</p>\n<p>![image-20220630113056298](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630113056298.png)</p>\n<p>![image-20220630113748370](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630113748370.png)</p>\n<h2 id=\"返回值位置使用-some-有泛型\"><a href=\"#返回值位置使用-some-有泛型\" class=\"headerlink\" title=\"返回值位置使用 some(有泛型)\"></a>返回值位置使用 some(有泛型)</h2><p>![image-20220630115019329](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630115019329.png)</p>\n<h2 id=\"返回值位置使用-any-有泛型-——Swift-5-7\"><a href=\"#返回值位置使用-any-有泛型-——Swift-5-7\" class=\"headerlink\" title=\"返回值位置使用 any(有泛型)——Swift 5.7\"></a>返回值位置使用 any(有泛型)——Swift 5.7</h2><p>![image-20220630115034795](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630115034795.png)</p>\n<p>![image-20220630130306325](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630130306325.png)</p>\n<p>![image-20220630130357415](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630130357415.png)</p>\n<p>![image-20220630130545010](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630130545010.png)</p>\n<h2 id=\"参数位置使用关联类型-2——Swift-5-7\"><a href=\"#参数位置使用关联类型-2——Swift-5-7\" class=\"headerlink\" title=\"参数位置使用关联类型 2——Swift 5.7\"></a>参数位置使用关联类型 2——Swift 5.7</h2><p>![image-20220630131309999](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630131309999.png)</p>\n<p>![image-20220630131748293](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630131748293.png)</p>\n<p>![image-20220630132014917](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630132014917.png)</p>\n<p>![image-20220630133327284](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630133327284.png)</p>\n<p>对 some Animal 调用 eat() 方法期待的返回值类型是 (some Animal).FeedType，而不是 (some Animal).FeedType.CropType.FeedType。</p>\n<p>![image-20220630163559858](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630163559858.png)</p>\n<p><img src=\"/Users/yanqizhao/Downloads/IMG_2469.JPG\" alt=\"IMG_2469\"></p>\n<p><img src=\"/Users/yanqizhao/Downloads/IMG_2474.JPG\" alt=\"IMG_2474\"></p>\n<p><img src=\"/Users/yanqizhao/Downloads/IMG_2475.JPG\" alt=\"IMG_2475\"></p>\n<p><img src=\"/Users/yanqizhao/Downloads/IMG_2476.JPG\" alt=\"IMG_2476\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"WWDC-22-110353-设计-Swift-协议接口-第一次整理\"><a href=\"#WWDC-22-110353-设计-Swift-协议接口-第一次整理\" class=\"headerlink\" title=\"WWDC 22 - 110353 设计 Swift 协议接口 第一次整理\"></a>WWDC 22 - 110353 设计 Swift 协议接口 第一次整理</h1><p>抽象实体类型&amp;模型化类型关系</p>\n<ol>\n<li>类型擦除</li>\n<li>返回值使用不透明类型</li>\n<li>参数使用存在主义类型</li>\n</ol>\n<p>![image-20220629165456814](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629165456814.png)</p>\n<p>![image-20220629171528411](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629171528411.png)</p>\n<h2 id=\"返回值位置使用-any——Swift-5-7\"><a href=\"#返回值位置使用-any——Swift-5-7\" class=\"headerlink\" title=\"返回值位置使用 any——Swift 5.7\"></a>返回值位置使用 any——Swift 5.7</h2><h2 id=\"返回值位置使用关联类型——Swift-5-7\"><a href=\"#返回值位置使用关联类型——Swift-5-7\" class=\"headerlink\" title=\"返回值位置使用关联类型——Swift 5.7\"></a>返回值位置使用关联类型——Swift 5.7</h2><p>![image-20220629171725309](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629171725309.png)</p>\n<p>![image-20220629174027749](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629174027749.png)</p>\n<p>![image-20220629174755209](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629174755209.png)</p>\n<h2 id=\"参数位置使用关联类型——Swift-5-7\"><a href=\"#参数位置使用关联类型——Swift-5-7\" class=\"headerlink\" title=\"参数位置使用关联类型——Swift 5.7\"></a>参数位置使用关联类型——Swift 5.7</h2><p>![image-20220629175125068](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220629175125068.png)</p>\n<p>![image-20220630090825995](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630090825995.png)</p>\n<p>![image-20220630091131974](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630091131974.png)</p>\n<h3 id=\"5-6-就有的语言特性-返回值位置\"><a href=\"#5-6-就有的语言特性-返回值位置\" class=\"headerlink\" title=\"5.6 就有的语言特性(返回值位置)\"></a>5.6 就有的语言特性(返回值位置)</h3><p>![image-20220630091555660](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630091555660.png)</p>\n<p>![image-20220630091709706](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630091709706.png)</p>\n<p>![image-20220630091851919](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630091851919.png)</p>\n<p>![image-20220630092431718](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630092431718.png)</p>\n<p>![image-20220630093842665](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630093842665.png)</p>\n<p>![image-20220630094032753](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630094032753.png)</p>\n<p>![image-20220630094835199](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630094835199.png)</p>\n<p>![image-20220630095819276](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630095819276.png)</p>\n<p>![image-20220630100218811](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630100218811.png)</p>\n<h2 id=\"泛型限制位置使用-any——Swift-5-7\"><a href=\"#泛型限制位置使用-any——Swift-5-7\" class=\"headerlink\" title=\"泛型限制位置使用 any——Swift 5.7\"></a>泛型限制位置使用 any——Swift 5.7</h2><p>![image-20220630112236985](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630112236985.png)</p>\n<p>![image-20220630113056298](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630113056298.png)</p>\n<p>![image-20220630113748370](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630113748370.png)</p>\n<h2 id=\"返回值位置使用-some-有泛型\"><a href=\"#返回值位置使用-some-有泛型\" class=\"headerlink\" title=\"返回值位置使用 some(有泛型)\"></a>返回值位置使用 some(有泛型)</h2><p>![image-20220630115019329](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630115019329.png)</p>\n<h2 id=\"返回值位置使用-any-有泛型-——Swift-5-7\"><a href=\"#返回值位置使用-any-有泛型-——Swift-5-7\" class=\"headerlink\" title=\"返回值位置使用 any(有泛型)——Swift 5.7\"></a>返回值位置使用 any(有泛型)——Swift 5.7</h2><p>![image-20220630115034795](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630115034795.png)</p>\n<p>![image-20220630130306325](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630130306325.png)</p>\n<p>![image-20220630130357415](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630130357415.png)</p>\n<p>![image-20220630130545010](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630130545010.png)</p>\n<h2 id=\"参数位置使用关联类型-2——Swift-5-7\"><a href=\"#参数位置使用关联类型-2——Swift-5-7\" class=\"headerlink\" title=\"参数位置使用关联类型 2——Swift 5.7\"></a>参数位置使用关联类型 2——Swift 5.7</h2><p>![image-20220630131309999](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630131309999.png)</p>\n<p>![image-20220630131748293](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630131748293.png)</p>\n<p>![image-20220630132014917](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630132014917.png)</p>\n<p>![image-20220630133327284](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630133327284.png)</p>\n<p>对 some Animal 调用 eat() 方法期待的返回值类型是 (some Animal).FeedType，而不是 (some Animal).FeedType.CropType.FeedType。</p>\n<p>![image-20220630163559858](/Users/yanqizhao/Library/Application Support/typora-user-images/image-20220630163559858.png)</p>\n<p><img src=\"/Users/yanqizhao/Downloads/IMG_2469.JPG\" alt=\"IMG_2469\"></p>\n<p><img src=\"/Users/yanqizhao/Downloads/IMG_2474.JPG\" alt=\"IMG_2474\"></p>\n<p><img src=\"/Users/yanqizhao/Downloads/IMG_2475.JPG\" alt=\"IMG_2475\"></p>\n<p><img src=\"/Users/yanqizhao/Downloads/IMG_2476.JPG\" alt=\"IMG_2476\"></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckqsw2n6r000151dx9oro0292","category_id":"ckqsw2n6v000451dxetdz3q52","_id":"ckqsw2n73000e51dx04r565fq"},{"post_id":"ckqsw2n6u000351dx8wbu6kz4","category_id":"ckqsw2n6y000951dxcpfi1gpz","_id":"ckqsw2n76000l51dx5wmg43ia"},{"post_id":"ckqsw2n6w000651dxh1ai8bdk","category_id":"ckqsw2n74000g51dxgglmayi3","_id":"ckqsw2n79000r51dxcz99fvac"},{"post_id":"ckqsw2n77000o51dx661vd36v","category_id":"ckqsw2n6v000451dxetdz3q52","_id":"ckqsw2n7b000v51dxa775hmca"},{"post_id":"ckqsw2n6x000751dxazf1031p","category_id":"ckqsw2n76000m51dx1ney4b3i","_id":"ckqsw2n7c000y51dxeydv8cq3"},{"post_id":"ckqsw2n78000p51dx14yz3tm5","category_id":"ckqsw2n6v000451dxetdz3q52","_id":"ckqsw2n7d001151dx06mg9i9z"},{"post_id":"ckqsw2n7a000u51dxgks05ptp","category_id":"ckqsw2n79000s51dxf87bfd9b","_id":"ckqsw2n7e001451dx2ijbdahp"},{"post_id":"ckqsw2n6y000851dxapo06css","category_id":"ckqsw2n79000s51dxf87bfd9b","_id":"ckqsw2n7f001851dxc3iw99qu"},{"post_id":"ckqsw2n7b000x51dx3r1iewiv","category_id":"ckqsw2n6y000951dxcpfi1gpz","_id":"ckqsw2n7h001c51dxdh8xe7yq"},{"post_id":"ckqsw2n7c001051dx8i2r8j9m","category_id":"ckqsw2n6y000951dxcpfi1gpz","_id":"ckqsw2n7j001g51dxfc761xgf"},{"post_id":"ckqsw2n71000c51dx23u15imh","category_id":"ckqsw2n79000s51dxf87bfd9b","_id":"ckqsw2n7l001j51dx3alrbl6z"},{"post_id":"ckqsw2n79000t51dx6lybe1ht","category_id":"ckqsw2n7e001551dx0fav1pjd","_id":"ckqsw2n7n001m51dxggfjam4n"},{"post_id":"ckqsw2n7i001f51dx9alfd6fw","category_id":"ckqsw2n79000s51dxf87bfd9b","_id":"ckqsw2n7r001p51dx07t5be29"},{"post_id":"ckqsw2n7d001351dxargmb36d","category_id":"ckqsw2n7h001d51dx33idh9g9","_id":"ckqsw2n7t001s51dx7tex5cl4"},{"post_id":"ckqsw2n7k001i51dxa6lgh356","category_id":"ckqsw2n79000s51dxf87bfd9b","_id":"ckqsw2n7t001u51dx1r8obmgf"},{"post_id":"ckqsw2n7f001751dxape851wi","category_id":"ckqsw2n7l001k51dx41s805xu","_id":"ckqsw2n7u001x51dx2hyz5j34"},{"post_id":"ckqsw2n7o001o51dx37xqa8b3","category_id":"ckqsw2n79000s51dxf87bfd9b","_id":"ckqsw2n7v002051dx3wgb4dxd"},{"post_id":"ckqsw2n7g001b51dx773dgix2","category_id":"ckqsw2n7s001r51dxgl4q0tye","_id":"ckqsw2n7v002251dx9afwedrd"},{"post_id":"ckqsw2n7m001l51dxhgv7bjs5","category_id":"ckqsw2n7u001y51dx1efiggox","_id":"ckqsw2n7w002451dx3yobckx6"},{"post_id":"ckqsw2n75000j51dx94l495st","category_id":"ckqsw2n79000s51dxf87bfd9b","_id":"ckqsx2q1c0005kfdx1tb76keg"},{"post_id":"ckqsw2n72000d51dx9zhy54sw","category_id":"ckqsx2q150000kfdxcd505kgw","_id":"ckqsx2q1c0007kfdx5b47cqc4"},{"post_id":"ckqsw2n74000i51dx8ody69rg","category_id":"ckqsx2q150000kfdxcd505kgw","_id":"ckqsx2q1d000bkfdx55y87v6l"},{"post_id":"cl4ve2euy0000y2dx7721c01k","category_id":"ckqsw2n79000s51dxf87bfd9b","_id":"cl4ve2ev60003y2dxch6u8idb"}],"PostTag":[{"post_id":"ckqsw2n6r000151dx9oro0292","tag_id":"ckqsw2n6w000551dx3hnp43l4","_id":"ckqsw2n70000b51dx9v6o7e7t"},{"post_id":"ckqsw2n6u000351dx8wbu6kz4","tag_id":"ckqsw2n6w000551dx3hnp43l4","_id":"ckqsw2n74000h51dxevhzf3n7"},{"post_id":"ckqsw2n6w000651dxh1ai8bdk","tag_id":"ckqsw2n6w000551dx3hnp43l4","_id":"ckqsw2n77000n51dx3s0ggbit"},{"post_id":"ckqsw2n6y000851dxapo06css","tag_id":"ckqsw2n76000k51dx3vu7ggzf","_id":"ckqsw2n7e001651dx9923h3kn"},{"post_id":"ckqsw2n6y000851dxapo06css","tag_id":"ckqsw2n79000q51dxafku7l2z","_id":"ckqsw2n7g001951dxalj3efht"},{"post_id":"ckqsw2n6y000851dxapo06css","tag_id":"ckqsw2n7b000w51dx0gg615qq","_id":"ckqsw2n7i001e51dxg42021qj"},{"post_id":"ckqsw2n71000c51dx23u15imh","tag_id":"ckqsw2n76000k51dx3vu7ggzf","_id":"ckqsw2n7s001q51dxcyryc3pt"},{"post_id":"ckqsw2n71000c51dx23u15imh","tag_id":"ckqsw2n79000q51dxafku7l2z","_id":"ckqsw2n7t001t51dxd23ed9p9"},{"post_id":"ckqsw2n71000c51dx23u15imh","tag_id":"ckqsw2n7b000w51dx0gg615qq","_id":"ckqsw2n7u001w51dx295x39ec"},{"post_id":"ckqsw2n77000o51dx661vd36v","tag_id":"ckqsw2n7n001n51dx9pmr9q6d","_id":"ckqsw2n7v001z51dx9sh11gvf"},{"post_id":"ckqsw2n78000p51dx14yz3tm5","tag_id":"ckqsw2n7t001v51dx46dk7zxf","_id":"ckqsw2n7x002551dx5gdu1x98"},{"post_id":"ckqsw2n78000p51dx14yz3tm5","tag_id":"ckqsw2n7v002151dxdxc8ecx5","_id":"ckqsw2n7x002651dx6xhl5ijv"},{"post_id":"ckqsw2n79000t51dx6lybe1ht","tag_id":"ckqsw2n7w002351dx4bzafc4r","_id":"ckqsw2n7y002851dx96z83vv4"},{"post_id":"ckqsw2n7a000u51dxgks05ptp","tag_id":"ckqsw2n76000k51dx3vu7ggzf","_id":"ckqsw2n7z002a51dx1t2x1dzp"},{"post_id":"ckqsw2n7a000u51dxgks05ptp","tag_id":"ckqsw2n7x002751dx5brqg0vp","_id":"ckqsw2n7z002b51dxfunfcy6q"},{"post_id":"ckqsw2n7b000x51dx3r1iewiv","tag_id":"ckqsw2n7t001v51dx46dk7zxf","_id":"ckqsw2n80002e51dx785w0nu5"},{"post_id":"ckqsw2n7b000x51dx3r1iewiv","tag_id":"ckqsw2n7z002c51dx13m7gaoj","_id":"ckqsw2n81002f51dxgnns5ma8"},{"post_id":"ckqsw2n7c001051dx8i2r8j9m","tag_id":"ckqsw2n7n001n51dx9pmr9q6d","_id":"ckqsw2n81002h51dxb6vt14yy"},{"post_id":"ckqsw2n7d001351dxargmb36d","tag_id":"ckqsw2n7t001v51dx46dk7zxf","_id":"ckqsw2n83002k51dxe8m123sa"},{"post_id":"ckqsw2n7d001351dxargmb36d","tag_id":"ckqsw2n7v002151dxdxc8ecx5","_id":"ckqsw2n83002l51dxgxug49jh"},{"post_id":"ckqsw2n7f001751dxape851wi","tag_id":"ckqsw2n7t001v51dx46dk7zxf","_id":"ckqsw2n84002o51dx2if9hkh1"},{"post_id":"ckqsw2n7f001751dxape851wi","tag_id":"ckqsw2n7v002151dxdxc8ecx5","_id":"ckqsw2n84002p51dx24lvcabo"},{"post_id":"ckqsw2n7g001b51dx773dgix2","tag_id":"ckqsw2n7t001v51dx46dk7zxf","_id":"ckqsw2n84002r51dxhquk4qwd"},{"post_id":"ckqsw2n7i001f51dx9alfd6fw","tag_id":"ckqsw2n76000k51dx3vu7ggzf","_id":"ckqsw2n85002u51dxbfzmadyh"},{"post_id":"ckqsw2n7i001f51dx9alfd6fw","tag_id":"ckqsw2n84002q51dxc3f2ddnz","_id":"ckqsw2n86002v51dx7n3rfyhq"},{"post_id":"ckqsw2n7i001f51dx9alfd6fw","tag_id":"ckqsw2n7n001n51dx9pmr9q6d","_id":"ckqsw2n86002x51dxcvxheiyb"},{"post_id":"ckqsw2n7k001i51dxa6lgh356","tag_id":"ckqsw2n76000k51dx3vu7ggzf","_id":"ckqsw2n87002z51dx5y2tf510"},{"post_id":"ckqsw2n7k001i51dxa6lgh356","tag_id":"ckqsw2n7z002c51dx13m7gaoj","_id":"ckqsw2n87003051dx8xtpble8"},{"post_id":"ckqsw2n7k001i51dxa6lgh356","tag_id":"ckqsw2n86002w51dx3g95c9lu","_id":"ckqsw2n88003251dxgxsbdmxr"},{"post_id":"ckqsw2n7m001l51dxhgv7bjs5","tag_id":"ckqsw2n86002y51dxcjb94gjx","_id":"ckqsw2n88003451dxaltl3i5x"},{"post_id":"ckqsw2n7m001l51dxhgv7bjs5","tag_id":"ckqsw2n86002w51dx3g95c9lu","_id":"ckqsw2n88003551dx7cmzezo1"},{"post_id":"ckqsw2n7o001o51dx37xqa8b3","tag_id":"ckqsw2n7n001n51dx9pmr9q6d","_id":"ckqsw2n89003751dx98jz47fb"},{"post_id":"ckqsw2n7o001o51dx37xqa8b3","tag_id":"ckqsw2n88003651dx2z7i6k1w","_id":"ckqsw2n89003851dxgwqvfl0u"},{"post_id":"ckqsw2n72000d51dx9zhy54sw","tag_id":"ckqsw2n76000k51dx3vu7ggzf","_id":"ckqsx2q1c0004kfdxbdc69vh8"},{"post_id":"ckqsw2n72000d51dx9zhy54sw","tag_id":"ckqsx2q190001kfdxa1ao20f4","_id":"ckqsx2q1c0006kfdxc0h82qtl"},{"post_id":"ckqsw2n74000i51dx8ody69rg","tag_id":"ckqsw2n76000k51dx3vu7ggzf","_id":"ckqsx2q1d0009kfdxef664esv"},{"post_id":"ckqsw2n74000i51dx8ody69rg","tag_id":"ckqsx2q190001kfdxa1ao20f4","_id":"ckqsx2q1d000akfdx65tx4l6e"},{"post_id":"ckqsw2n75000j51dx94l495st","tag_id":"ckqsw2n76000k51dx3vu7ggzf","_id":"ckqsx2q1d000ckfdxc2bkdj8t"},{"post_id":"ckqsw2n75000j51dx94l495st","tag_id":"ckqsx2q1c0008kfdxclmh25qv","_id":"ckqsx2q1e000dkfdx57x79l10"},{"post_id":"cl4ve2euy0000y2dx7721c01k","tag_id":"ckqsw2n76000k51dx3vu7ggzf","_id":"cl4ve2ev60004y2dxhu44hx0i"},{"post_id":"cl4ve2euy0000y2dx7721c01k","tag_id":"cl4ve2ev10001y2dx2nzu2ncq","_id":"cl4ve2ev60005y2dx75lc8m3c"}],"Tag":[{"name":"学习记录","_id":"ckqsw2n6w000551dx3hnp43l4"},{"name":"iOS","_id":"ckqsw2n76000k51dx3vu7ggzf"},{"name":"SDK","_id":"ckqsw2n79000q51dxafku7l2z"},{"name":"支付","_id":"ckqsw2n7b000w51dx0gg615qq"},{"name":"学习资料","_id":"ckqsw2n7n001n51dx9pmr9q6d"},{"name":"编程语言","_id":"ckqsw2n7t001v51dx46dk7zxf"},{"name":"语法基础","_id":"ckqsw2n7v002151dxdxc8ecx5"},{"name":"数据结构与算法","_id":"ckqsw2n7w002351dx4bzafc4r"},{"name":"问题","_id":"ckqsw2n7x002751dx5brqg0vp"},{"name":"UI","_id":"ckqsw2n7z002c51dx13m7gaoj"},{"name":"优化","_id":"ckqsw2n84002q51dxc3f2ddnz"},{"name":"总结","_id":"ckqsw2n86002w51dx3g95c9lu"},{"name":"Tools","_id":"ckqsw2n86002y51dxcjb94gjx"},{"name":"热修复","_id":"ckqsw2n88003651dx2z7i6k1w"},{"name":"Bazel","_id":"ckqsx2q190001kfdxa1ao20f4"},{"name":"Block","_id":"ckqsx2q1c0008kfdxclmh25qv"},{"name":"动态化","_id":"cl4ve2ev10001y2dx2nzu2ncq"}]}}